
import cn.hutool.core.map.MapUtil;
import cn.hutool.core.util.ImageUtil;
import cn.hutool.core.util.RuntimeUtil;
import cn.hutool.extra.qrcode.QrCodeUtil;
import cn.hutool.extra.qrcode.QrConfig;
import cn.hutool.http.HttpUtil;
import cn.hutool.json.JSONUtil;
import it.sauronsoftware.jave.Encoder;
import it.sauronsoftware.jave.MultimediaInfo;
import it.sauronsoftware.jave.VideoSize;

import com.alibaba.fastjson.JSONArray;
import com.alibaba.fastjson.JSONObject;
import com.drew.imaging.jpeg.JpegMetadataReader;
import com.drew.imaging.jpeg.JpegProcessingException;
import com.drew.metadata.Directory;
import com.drew.metadata.Metadata;
import com.drew.metadata.Tag;
import com.drew.metadata.exif.ExifIFD0Directory;
import com.github.javaparser.JavaParser;
import com.github.javaparser.ast.*;
import com.github.javaparser.ast.body.*;
import com.google.common.collect.Maps;
import com.itextpdf.text.Document;
import com.itextpdf.text.DocumentException;
import com.itextpdf.text.pdf.PdfCopy;
import com.itextpdf.text.pdf.PdfImportedPage;
import com.itextpdf.text.pdf.PdfReader;
import com.itextpdf.text.pdf.PdfWriter;
import com.luciad.imageio.webp.WebPReadParam;
import com.mpatric.mp3agic.ID3v1;
import com.mpatric.mp3agic.ID3v2;
import com.mpatric.mp3agic.Mp3File;
import com.spire.presentation.FileFormat;
import com.spire.presentation.IAutoShape;
import com.spire.presentation.IEmbedImage;
import com.spire.presentation.ISlide;
import com.spire.presentation.PortionEx;
//import com.sun.tools.sjavac.CopyFile;
import com.spire.presentation.Presentation;
import com.spire.presentation.ShapeType;
import com.spire.presentation.drawing.FillFormatType;
import com.sun.mail.util.MailSSLSocketFactory;


import net.jimmc.jshortcut.JShellLink;
import net.sourceforge.pinyin4j.PinyinHelper;
import net.sourceforge.pinyin4j.format.HanyuPinyinCaseType;
import net.sourceforge.pinyin4j.format.HanyuPinyinOutputFormat;
import net.sourceforge.pinyin4j.format.HanyuPinyinToneType;
import net.sourceforge.pinyin4j.format.exception.BadHanyuPinyinOutputFormatCombination;

import java.awt.*;
import java.awt.font.FontRenderContext;
import java.awt.geom.Rectangle2D;
import java.awt.image.BufferedImage;
import java.io.*;

import java.math.BigInteger;
import java.net.*;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.text.Collator;
import java.text.NumberFormat;
import java.text.SimpleDateFormat;
import java.util.*;
import java.util.List;
import java.util.concurrent.TimeUnit;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.zip.GZIPInputStream;
import java.text.DecimalFormat;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;
import javax.crypto.Cipher;
import javax.imageio.ImageIO;
import javax.imageio.ImageReader;
import javax.imageio.stream.FileImageInputStream;
import javax.imageio.stream.ImageOutputStream;
import javax.mail.internet.MimeBodyPart;
import javax.mail.internet.MimeMessage;
import javax.swing.*;

import javax.mail.MessagingException;

import javax.mail.internet.MimeMultipart;
import javax.mail.internet.MimeUtility;
import javax.mail.search.FlagTerm;
import javax.mail.search.SearchTerm;

import javax.mail.Authenticator;
import javax.mail.PasswordAuthentication;

import org.apache.commons.io.FileUtils;
import org.apache.pdfbox.io.MemoryUsageSetting;
import org.apache.pdfbox.multipdf.PDFMergerUtility;
import org.apache.poi.hssf.usermodel.HSSFWorkbook;
import org.apache.poi.openxml4j.util.ZipSecureFile;
import org.apache.poi.ss.usermodel.Cell;
import org.apache.poi.ss.usermodel.DateUtil;
import org.apache.poi.ss.usermodel.Row;
import org.apache.poi.ss.usermodel.Sheet;
import org.apache.poi.ss.usermodel.Workbook;
import org.apache.poi.xslf.usermodel.XMLSlideShow;
import org.apache.poi.xslf.usermodel.XSLFSlide;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.jsoup.Connection;
import org.jsoup.Jsoup;
import org.jsoup.select.Elements;
import org.mp4parser.IsoFile;
import org.mp4parser.boxes.iso14496.part12.MovieBox;
import org.mp4parser.boxes.iso14496.part12.TrackBox;
import org.openqa.selenium.By;
import org.openqa.selenium.Keys;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.interactions.Actions;
import org.openxmlformats.schemas.spreadsheetml.x2006.main.impl.CTCellFormulaImpl;

import java.security.Key;
import java.security.Security;

// 对于  文件类型_操作Index  执行对应的操作逻辑
public class G2_ApplyRuleFor_TypeFile {

    // 类型_索引 ，对当前类型的文件执行索引执行的操作 html1---对html类型的子文件执行 索引为1 的逻辑操作 String
    // apply(String)
    static ArrayList<String> Rule_Identify_TypeIndexList = new ArrayList<String>();

    static String Cur_Batch_End = ".bat";
    static String G2_Bat_Name = "zrule_apply_G2";
    static String Cur_Bat_Name = "zrule_apply_G2";
    static String zbinPath = System.getProperties().getProperty("user.home") + File.separator + "Desktop"
            + File.separator + "zbin";
    static String G2_File_Path = zbinPath + File.separator + "G2";
    static String Win_Lin_Mac_ZbinPath = "";

    static File G2_Properties_File = new File(System.getProperties().getProperty("user.home") + File.separator
            + "Desktop" + File.separator + "zbin" + File.separator + "G2.properties");
    static InputStream G2_Properties_InputStream;
    static OutputStream G2_Properties_OutputStream;
    static Properties G2_Properties = new Properties();
    static Map<String, String> propKey2ValueList = new HashMap<String, String>();

    static int BYTE_CONTENT_LENGTH_Rule7 = 1024 * 10 * 10; // 读取文件Head字节数常数
    static String strDefaultKey_Rule7 = "zukgit12"; // 8-length
    // static String strDefaultKey_Rule7 = "1234567812345678"; // 8-length

    static String strZ7DefaultKey_PSW_Rule19 = "752025"; // 8-length
    public static byte[] TEMP_Rule7 = new byte[BYTE_CONTENT_LENGTH_Rule7];

    static G2_ApplyRuleFor_TypeFile mG2_Object;

    static {
        try {
            if (!G2_Properties_File.exists()) {
                G2_Properties_File.createNewFile();
            }
            G2_Properties_InputStream = new BufferedInputStream(
                    new FileInputStream(G2_Properties_File.getAbsolutePath()));
            G2_Properties.load(G2_Properties_InputStream);
            Iterator<String> it = G2_Properties.stringPropertyNames().iterator();
            while (it.hasNext()) {
                String key = it.next();
                // System.out.println("key:" + key + " value: " +
                // G2_Properties.getProperty(key));
                propKey2ValueList.put(key, G2_Properties.getProperty(key));
            }
            G2_Properties_InputStream.close();
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    static void setProperity() {
        try {
            G2_Properties_OutputStream = new BufferedOutputStream(
                    new FileOutputStream(G2_Properties_File.getAbsolutePath()));
            G2_Properties.store(G2_Properties_OutputStream, "");
            G2_Properties_OutputStream.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    enum OS_TYPE {
        Windows, Linux, MacOS
    }

    // JDK 的路径
    static String JDK_BIN_PATH = "";

    static File G2_Temp_Text_File = new File(
            System.getProperties().getProperty("user.home") + File.separator + "Desktop" + File.separator + "zbin"
                    + File.separator + get_Bat_Sh_FlagNumber(Cur_Bat_Name) + "_Temp_Text.txt");

    static File G2_Temp_Bat_File = new File(
            System.getProperties().getProperty("user.home") + File.separator + "Desktop" + File.separator + "zbin"
                    + File.separator + get_Bat_Sh_FlagNumber(Cur_Bat_Name) + "_Temp_Bat.bat");
    
    static File G2_Temp_Dir_File = new File(
            System.getProperties().getProperty("user.home") + File.separator + "Desktop" + File.separator + "zbin"
                    + File.separator + get_Bat_Sh_FlagNumber(Cur_Bat_Name) +"_Temp_Dir");



    static OS_TYPE CUR_OS_TYPE = OS_TYPE.Windows;
    static String curOS_ExeTYPE = "";
    static ArrayList<String> mKeyWordName = new ArrayList<String>();

    // 当前Shell目录下的 文件类型列表 抽取出来 通用
    static HashMap<String, ArrayList<File>> CurDirFileTypeMap = new HashMap<String, ArrayList<File>>();;

    static void initSystemInfo() {
        String osName = System.getProperties().getProperty("os.name").toLowerCase();
        String curLibraryPath = System.getProperties().getProperty("java.library.path");
        if (osName.contains("window")) {
            CUR_OS_TYPE = OS_TYPE.Windows;
            Cur_Bat_Name = Cur_Bat_Name + ".bat";
            Cur_Batch_End = ".bat";
            curOS_ExeTYPE = ".exe";
            initJDKPath_Windows(curLibraryPath);
            Win_Lin_Mac_ZbinPath = zbinPath + File.separator + "win_zbin";

        } else if (osName.contains("linux")) {
            CUR_OS_TYPE = OS_TYPE.Linux;
            Cur_Bat_Name = Cur_Bat_Name + ".sh";
            curOS_ExeTYPE = "";
            Cur_Batch_End = ".sh";
            initJDKPath_Linux_MacOS(curLibraryPath);
            Win_Lin_Mac_ZbinPath = zbinPath + File.separator + "lin_zbin";

        } else if (osName.contains("mac")) {
            CUR_OS_TYPE = OS_TYPE.MacOS;
            Cur_Bat_Name = Cur_Bat_Name + ".sh";
            curOS_ExeTYPE = "";
            Cur_Batch_End = ".sh";
            initJDKPath_Linux_MacOS(curLibraryPath);
            Win_Lin_Mac_ZbinPath = zbinPath + File.separator + "mac_zbin";

        }

    }

    static void initJDKPath_Linux_MacOS(String environmentPath) {
        String[] environmentArr = environmentPath.split(":");
        for (int i = 0; i < environmentArr.length; i++) {
            String pathItem = environmentArr[i];
            if (pathItem.contains("jdk") && pathItem.contains("bin")) {
                JDK_BIN_PATH = pathItem;
            }
        }
    }

    static void initJDKPath_Windows(String environmentPath) {
        String[] environmentArr = environmentPath.split(";");
        for (int i = 0; i < environmentArr.length; i++) {
            String pathItem = environmentArr[i];
            if (pathItem.contains("jdk") && pathItem.contains("bin")) {
                JDK_BIN_PATH = pathItem;
            }
        }
    }

    static String curDirPath = ""; // 当前 SHELL 所在目录 默认是main中的第一个 arg[0] 就是shell路径
    static File curDirFile;

    private static String REGEX_CHINESE = "[\u4e00-\u9fa5]";

    public static String clearChinese(String lineContent) {
        if (lineContent == null || lineContent.trim().isEmpty()) {
            return null;
        }
        Pattern pat = Pattern.compile(REGEX_CHINESE);
        Matcher mat = pat.matcher(lineContent);
        return mat.replaceAll(" ");
    }

    void InitRule() {

        realTypeRuleList.add(new HTML_Rule_1());
        realTypeRuleList.add(new File_Name_Rule_2());
        realTypeRuleList.add(new Image2Jpeg_Rule_3());
        realTypeRuleList.add(new Image2Png_Rule_4());
        realTypeRuleList.add(new AVI_Rule_5());
        realTypeRuleList.add(new SubDirRename_Rule_6());
        realTypeRuleList.add(new Encropty_Rule_7());
        realTypeRuleList.add(new ClearChineseType_8());
        realTypeRuleList.add(new FileType_Rule_9());
        realTypeRuleList.add(new DirOperation_Rule_10());
        realTypeRuleList.add(new AllDirSubFile_Order_Rule_11());

        realTypeRuleList.add(new CalCulMediaHtml_Rule_12());
        realTypeRuleList.add(new CalMP4_DIR_HTML_Rule_13());
        realTypeRuleList.add(new CreateIconFile_KuaiJieFangShi_Rule_14());
        realTypeRuleList.add(new Webp_To_Jpg_Gif_Rule_15());

        realTypeRuleList.add(new File_TimeName_Rule_16());
        realTypeRuleList.add(new Make_ZRuleDir_Rule_17());
        realTypeRuleList.add(new MD_ReName_Rule_18());
        realTypeRuleList.add(new ExpressTo7z_PassWord_Rule_19());
        realTypeRuleList.add(new Land_Port_Classify_Rule_20());
        realTypeRuleList.add(new Rename_Img_WithSize_Rule_21());
        realTypeRuleList.add(new ReSize_Img_Rule_22());

        // 23
        realTypeRuleList.add(new CheckFileRealFormat_Rule_23());
        realTypeRuleList.add(new add_Middle_Dir_Rule_24()); // 在当前的目录 与 子目录 之间 新增 一层文件夹 , 文件夹名称任意 用户输入

        // 从上往下打印 年月 标示 接受来自 输入的参数 打开 临时文件
        // ## 2020
        // ### 2020.01
        // ### 2020.02
        // zrule_apply_G2.bat #_25 1992_2021 这样
        realTypeRuleList.add(new Time_Head_Rule_25());
        realTypeRuleList.add(new Rename_By_Dir_Rule_26());
        realTypeRuleList.add(new Rercovery_Type_By_DirName_Rule_27());
        // 把当前的 图片 文件 jpg png 等 转为 一个 PPTX 文件 方便 分享 查看
        realTypeRuleList.add(new makeJpg2PPTX_Rule_28());

        // 把 当前 目录的 多个 pptx 合并成 一个 pptx 文件
        realTypeRuleList.add(new mergeSomePPTXAsOne_Rule_29());

        // 对文件的名称进行修改
        realTypeRuleList.add(new FileRenameOperation_Rule_30());

        // 创建文件 创建模板文件
        realTypeRuleList.add(new MakeFile_E5_Rule_31());

        // 把当前目录的 jpg png 文件转为 一个 pdf文件
        realTypeRuleList.add(new MakeJpg2PDF_Rule_32());

        // 把当前目录mp3 文件进行 属性的更改
        realTypeRuleList.add(new MP3_Prop_Fixed_Rule_33());

        // 把当前的 MP3文件转为 JSON 格式数据 方便 布局 树形 结构
        realTypeRuleList.add(new MP3_Revert2JSOn_Rule_34());
        realTypeRuleList.add(new Append_Pdf_Rule_35()); // 把 pdf 文件 追加 合并为 一个文件
        realTypeRuleList.add(new Seperate_Pdf_Rule_36()); // 把 pdf中指定的页数 分隔出来作为一个新的pdf文件

        realTypeRuleList.add(new Zapp_Zmain_dir_Create_Rule_37()); // 在本地目录创建 /sdcard/zapp 和 /sdcard/zmain 相关的 dir目录

        // 把 当前的 xlsx xls 文件 转为 对应的 json 文件
        realTypeRuleList.add(new Revert_xlsx2json_Rule_38());

// 监听 当前 微信的 接收文件 , 判断是否 有新的txt文件  如果有 读取它 , 执行 执行 相应的 命令  如果是 http路径 那么 下载它
        realTypeRuleList.add(new Monitor_WeChatFile_ForWindows_Rule_39());

        // 对网站进行抓取资源到本地
        realTypeRuleList.add(new Monitor_Browser_ForWindows_Rule_40());

// 	// 读取当前文件夹下的jpg文件(仅仅时当前目录) 然后 读取当前的jpg的 artist  Desc  Make  Mode  Copyright UserComment 信息 来生成 .md文件

        realTypeRuleList.add(new Read_Jpg_Exif_Info_Create_MDContent_Rule_41());

        // 传递一个地址 然后返回这个地址的所有的网页的代码 打印在 Temp.txt 中 , 循环到底 持续五分钟 并执行一直写入txt的操作
        // 必须以 http 开头
        realTypeRuleList.add(new GetHttpCode_Rule_42());

// 传递一个 txt文本文件 以及一个 splitstr_XXXX 到程序中,将会去把当前所有的字符串进行split分隔，并输入split分隔后的第一个空格前的字符串

        realTypeRuleList.add(new SqlitTxt_Return_FirstBlankStr_Rule_43());

        realTypeRuleList.add(new Land_Port_Mp4Rename_Rule_44());

        realTypeRuleList.add(new Jpg_Stock_Port_To_MD_Rule_45());

        // 在 jpg 图片 本身 标记 一些 这个图片本身的一些属性
        realTypeRuleList.add(new ShowJpgTagContent_To_Image_Rule_46());

        // 给定一个 西瓜视频 主页 下载 该页面内的所有视频文件
        realTypeRuleList.add(new Download_XiGua_HomeVideo_Rule_47());

        // voice_fafaefafea 读取 voice 的 内容
        realTypeRuleList.add(new Read_Speak_Word_Rule_48());

        // 给定一个 类型的 模板 起始页(默认1) 最终页(默认100)
        // 是否代理(默认false) itemtag(页面内的标记用于过滤) imagetag(详细内容也的照片的标示)
        // CategoryModel_HttpPage_Download_Rule_49
        realTypeRuleList.add(new CategoryModel_HttpPage_Download_Rule_49());

        // 把 当前的 输入的 jpg 或者 当前目录下的 jpg文件 动态计算成 320 宽度的 字符串 并 在打开的文件中打印
        realTypeRuleList.add(new JPG_To_TextChar_Rule_50());

        // 把 当前的 原目录中的所有文件 复制到 对应目录的文件， 如果文件大小一直 那么就跳过复制的过程
        // tip: git action 操作过程中 文件大小不变 但是 它的MD5值 变化了 导致每次都 更新相同的文件
        realTypeRuleList.add(new SrcDir_Copy2_DstDir_WithFileLength_Rule_51());

        // 去除在 一个文件夹中 多余的相同的 MD5 文件 只保留 一个MD5 去重操作
        realTypeRuleList.add(new Delete_SameMD5File_OnlyExistOneInDir_Rule_52());
        // initrule

        // 在 一个 android-studio apk 目录执行的 用于 克隆一个工程到同目录 但工程名称可选
        realTypeRuleList.add(new Copy_APK_Product_ChangeProductName_Rule_53());

        realTypeRuleList.add(new Send_Email_TO_Dst_Rule_54());


        //读取到当前 所有 目录的 .rs 文件  对于 【pub fn】___ 【pub const fn】 pub unsafe   字样的 字符串 并且不是// 开头的字符串打印出一份详情清单
        realTypeRuleList.add(new Read_RS_File_Print_Pub_Fn_Method_To_MD_Rule_55());


        // 对 输入的字符串   进行 加密  并打印 前后数据 对比
        realTypeRuleList.add(new Encry_StringByte_To_Print_Rule_56());

        // 对 build_device.bash  和 build_msi_device.sh  两个 编译文件 添加 修改 埋点
        // bash   sh    java   等等  需要   添加Log 的 操作
        realTypeRuleList.add(new AddLog_CompileCheck_For_File_Rule_57());

        /*
         * { "jpg_lin_land":{"":["12.jpg","34.jpg"],"123":["123.jpg"]},
         * "jpg_lin_port":{"":["12.jpg","34.jpg"],"123":["123.jpg"]} }
         */
        //  对输入的目录结构进行文件统计 并生成 json 数据输出

        realTypeRuleList.add(new InputDirSearch_To_JsonSummary_Rule_58());

// 把图片分类到 对应的分辨率目录  1980x1280 文件夹
        realTypeRuleList.add(new Picture_Classify_To_WidthHeighDir_Rule_59());


        //  读取 releasenote.html  解析出来数据 然后 产生 tip 文件
        realTypeRuleList.add(new ReleaseNoteHtml_Revert_TipTxt_Rule_60());

        //  把在 zmain-Life 中实现的  Wireless 相关 逻辑 通过  这个规则 移植到  AOSP的 Settings 中 使得 能在系统层级调用以及对应设备 调用一些相关代码逻辑
        realTypeRuleList.add(new Add_Zmain_Life_Wireless_Embedded_AOSP_Settings_Rule61());


        // 输入 bssid_11:11:11:11:55  mac_11:22:33:44:55  来统计所有的 过滤条件  可多输入   一比一匹配
        //    bssid_11:11:11:11:55  mac_11:22:33:44:55   bssid_00:11:11:11:55  mac_aa:22:33:44:55
        realTypeRuleList.add(new Wifi_Wireshark_Fliter_Calcul_Rule62());


        // 对当前目录 执行 打印 当前 结构的操作
        realTypeRuleList.add(new Print_Dir_FileTree_Info_Rule63());

        //  对当前  依据  md5_type  组成的规则的文件  还原为  md5.type 这样的 文件
        realTypeRuleList.add(new Make_Md5Type_Hide_File_Back_To_FileType_Rule64());

        // 对于 ZHide 文件夹内的所有文件 进行 md5_type 操作  md5.type 操作
        realTypeRuleList.add(new ZHide_MD5Type_Operation_Rule_65());

        // 指定文件 进行 文本的 替换
        realTypeRuleList.add(new ReplaceTxtFile_Src_to_Dst_Rule_66());


        // 指定src文件  放入 dest.txt 文件指向的每一行目录
        realTypeRuleList.add(new CopyFile_Src_to_Dst_Rule_67());

        // 指定当前 src 源目录文件夹 在该路径搜索指定 tagString , 然后在目的Dst路径搜索
        // 如果 后缀路径与 src源匹配 并且 也有匹配到 tagString 那么替换该字符串所在行
        realTypeRuleList.add(new AOSP_Replace_Src_TagFlag_Dst_Rule_68());


        // 实现一个模拟的 HTTP 服务器 为 无线 adb 做准备
        realTypeRuleList.add(new PC_Show_QrCode_HttpServer_Rule69());
        

        // 往 当前目录的 jpg  draw 画当前的 text 当前名字
        realTypeRuleList.add(new Draw_FileNameText_To_JPG_Top_Rule_70());

        
        // 统计当前输入文件夹 文件大小 占用情况   并输出到指定的文件夹 可以是 README.md
        realTypeRuleList.add(new CalCul_DirFile_SizeSpace_Rule_71());

        
        
        // 在当前 GIT 的根目录执行 用来给 GIT 增加 Git Action 
        realTypeRuleList.add(new Add_GitAction_To_GitDir_72());
        
     
    }
    

    
    
    //   mdshow_filesize  //按 文件大小 排序 ，
    //   mdshow_dirtime   //  按照 时间文件夹排序

    class Add_GitAction_To_GitDir_72 extends Basic_Rule {

     
    	int  mMdShowTyle = 0;  // md显示的方式类型  默认是0  按照文件大小
    	
    	File curShellPathFile ;   //  当前的 Shell 目录的 File 类
        Add_GitAction_To_GitDir_72() {
            super("#", 72, 4); //
            mMdShowTyle = 0; 
        }

        @Override
        boolean allowEmptyDirFileList() {
            return true;
        }
        
        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // mdname_true // kaoyan_true gaokao_true

//			src_xxxxxx
//			dst_xxxxx

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem_lower_trim = inputParamList.get(i);
//				String paramItem_lower_trim = paramItem.toLowerCase().trim();

                if (paramItem_lower_trim.startsWith("mdshow_filesize")) {
                	mMdShowTyle = 0 ;
                			
                }

                
                if (paramItem_lower_trim.startsWith("mdshow_dirtime")) {
                	mMdShowTyle = 1 ;
                			
                }
     

            }
            
            curShellPathFile = new File(curDirPath) ;
            
            System.out.println("mMdShowTyle="+mMdShowTyle+"   curDirPath="+curDirPath +"  curShellPathFile="+curShellPathFile);
            

            File mREADME_File =  new File(curDirPath+File.separator+"README.md");
            
            if(!mREADME_File.exists()) {
            	
            	System.out.println("当前目录没有 README.md 可能不是GIT的根目录, 如需要继续执行程序 请执行 【 echo AA > README.md 】  创建本地 README.md 后再执行新增Git Action的规则"+rule_index);
            	
            	
            	return false;
            }
            

            
            
            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }

        // 如果当前的需要 提交的 文件中 不包含 json 文件 那么 不提交这次文件 以达到 省空间的 目的
        // xlsx 每次更新都是全替换 而不是 部分替换 导致 更新文件大小过大

        @Override
        String simpleDesc() {

            return "\n"
                    + Cur_Bat_Name + " #_" + rule_index + "  // 【需要在Git Setting目录增加Action的读写权限】 在当前的Git目录中 增加 GitAction 用于统计当前文件详情到 README.md 文件中( 默认文件大小排序)  \n"
                    + Cur_Bat_Name + "  #_" + rule_index + "mdshow_filesize  ### 【需要在Git Setting目录增加Action的读写权限】 mdshow_filesize 标识按照大小排序 在当前的Git目录中 增加 GitAction 用于统计当前文件详情到 README.md 文件中( 默认文件大小排序)   \n"
                    + Cur_Bat_Name + "  #_" + rule_index + "mdshow_dirtime  ### mdshow_dirtime 标识按照文件目录以及时间排序 在当前的Git目录中 增加 GitAction 用于统计当前文件详情到 README.md 文件中(按照文件目录以及时间排序)   \n"

                    + ""
//			zrule_apply_G2.bat  #_46  copyright_show  harddir_true
                    ;
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

        	//1.1  复制 Desktop/zbin 下面的 G2 开头的文件 和 文件夹
        	//1.2   复制 Desktop/zbin/win_zbin  到当前的 zbin/win_zbin 目录
        	//    读取 G2_rule72_main.yml  并替换 mp4_lin_action1_2412 为当前根目录
        	
        	File mDesktopZbinFile = new File(zbinPath);
        	
        	
        	if(!mDesktopZbinFile.exists()) {
        		System.out.println("当前不存在 ~/Desktop/zbin 目录 程序失败退出! 请检查!!  mDesktopZbinFile="+mDesktopZbinFile.getAbsolutePath());
        	
        		return  null ;
        	}
        	
        	
        	ArrayList<File> allG2RealFileList = new ArrayList<File> ();
        	File[] fileArr = mDesktopZbinFile.listFiles();
        	
        	
        	for (int i = 0; i < fileArr.length; i++) {
				File mFileItem =  fileArr[i];
				String  fileName_lower = mFileItem.getName().toLowerCase().trim();
				if(mFileItem.isFile() && fileName_lower.startsWith("g2")) {
					
					// 不复制 .class 的文件
					if(!fileName_lower.endsWith(".class")) {
						
						allG2RealFileList.add(mFileItem);
					}
			
					
				}
			}
        	
        	
        	for (int i = 0; i < allG2RealFileList.size(); i++) {
        		File mCopyFileItem = allG2RealFileList.get(i);
        		String rawFileName = mCopyFileItem.getName();
        		fileCopy(mCopyFileItem, new File(curShellPathFile.getAbsolutePath()+File.separator+"zbin"+File.separator+rawFileName));
				
        		System.out.println("G2_File["+allG2RealFileList.size()+"_"+i+"] "+mCopyFileItem.getAbsolutePath()+" Copy!");
			}
        	
        	
        	
        	//1.2   win_zbin 目录的复制 
        	File mWinZbinFile = new File(zbinPath+File.separator+"win_zbin");
        	
        	ArrayList<File> allWinZBinBatRealFileList = new ArrayList<File> ();
        	File[] winzbinFileArr = mWinZbinFile.listFiles();
        	
        	
        	for (int i = 0; i < winzbinFileArr.length; i++) {
				File mFileItem =  winzbinFileArr[i];
				String  fileName_lower = mFileItem.getName().toLowerCase().trim();
				if(mFileItem.isFile() && fileName_lower.endsWith(".bat")) {
					allWinZBinBatRealFileList.add(mFileItem);
					
				}
			}
        	
        	
        	for (int i = 0; i < allWinZBinBatRealFileList.size(); i++) {
        		File mCopyFileItem = allWinZBinBatRealFileList.get(i);
        		String rawFileName = mCopyFileItem.getName();
        		fileCopy(mCopyFileItem, new File(curShellPathFile.getAbsolutePath()+File.separator+"zbin"+File.separator+"win_zbin"+File.separator+rawFileName));
        		System.out.println("WinZbin_File["+allWinZBinBatRealFileList.size()+"_"+i+"] "+mCopyFileItem.getAbsolutePath()+" Copy!");

			}
        	
        	// 2. 创建目录  .github\workflows\main.yml
        	
        	File G2_main_yml_File = new File(mDesktopZbinFile+File.separator+"G2_rule72_main.yml");
        	
        	if(!G2_main_yml_File.exists()) {
        		
        		System.out.println("当前 Git Action 的模板  G2_main_yml_File="+G2_main_yml_File+" 不存在 请检查！ 失败退出!");
        		return null;
        	}
        			
        	
        	String  mMainYmlContent = ReadFileContent_UTF8(G2_main_yml_File);
        	
        	
        	
        	mMainYmlContent = mMainYmlContent.replace("mp4_lin_action1_2412", curShellPathFile.getName()) ;
        	
        	
        	
        	File targetMainYmlFile = new File(curShellPathFile.getAbsolutePath()+File.separator+".github"+File.separator+"workflows"+File.separator+"main.yml");
        	
        	writeContentToFile(targetMainYmlFile, mMainYmlContent);
        	
        	System.out.println(targetMainYmlFile.getAbsolutePath()+" Git Action 配置文件导入完成! ");
        	
        	//  3. 复制 win_zbin/zbatrule_I9_Rule30.bat
        	
        	
        	File batRuleSrcFile = new  File(mDesktopZbinFile.getAbsolutePath()+File.separator+"win_zbin"+File.separator+"zbatrule_I9_Rule30.bat");
        	
        	if(!batRuleSrcFile.exists()) {
        		
        		System.out.println("当前 Git Action 的模板 zbatrule_I9_Rule30.bat="+ batRuleSrcFile.getAbsolutePath()+" 不存在 ！ 程序执行失败退出!");

        		return null ;
        	}
        	
        	
        	File batRuleDstFile = new File(curShellPathFile.getAbsolutePath()+File.separator+File.separator+"zbatrule_I9_Rule30.bat");
        	
        	
        	
        	fileCopy(batRuleSrcFile, batRuleDstFile);
        	
        	System.out.println(batRuleDstFile.getAbsolutePath()+" Git Action 的 zbatrule_I9_Rule30.bat 文件复制成功!  ");

        	System.out.println("程序执行结束!  Success! ");
        	
            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);

        }

  

    }

    
    class CalCul_DirFile_SizeSpace_Rule_71 extends Basic_Rule {
        boolean isDirInput; //   是否有指定的 目录进行输入
        ArrayList<File> inputDirFileList;   // 输入的目录的集合
        
        boolean isNeedOutFile ; // 是否 需要输出 文件 
        String outFileName ;  //  输出的文件名称
        String outDirPath ;   //  输出的文件的目录
        File outResultFile ; 
        ArrayList<String>  outResultTipList  ;  // 输出文件的内容
        CalCul_DirFile_SizeSpace_Rule_71() {
            super("#", 71, 5); //
            inputDirFileList = new ArrayList<File>();
            isDirInput = false;
            outFileName = "README.md";
            outResultFile = null ;
            outResultTipList =  new ArrayList<String>();
        }

        @Override
        boolean allowEmptyDirFileList() {
            // TODO Auto-generated method stub
            return true;
        }


        @Override
        String simpleDesc() {
            return "  \n"
                    + Cur_Bat_Name  + " #_"+rule_index+"    ### 统计当前输入文件夹 文件大小 占用情况   并输出到指定的文件夹 可以是 README.md \n"
                    + Cur_Bat_Name  + " #_"+rule_index+"    ### 统 无参数 默认只打印 当前目录 的文件占用情况 \n"
                    + Cur_Bat_Name  + " #_"+rule_index+"  outname_README.md   outdir_D:\\\\ScreenShot\\\\0    D:\\ScreenShot\\0A ###  输入指定文件夹  outname_指定输出文件名称  outdir_指定输出文案目录 默认打印当前目录 \n"
                    + Cur_Bat_Name  + " #_"+rule_index+"  outname_README.md   outdir_D:\\Git_Dir\\mp4_lin_action  ###  在GIT根目录执行 选中需要解析的目录 可以把文件夹内容更新到 README.md \n"

                    
                    ;
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // mdname_true // kaoyan_true gaokao_true

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem_trim = inputParamList.get(i);

                File input_dir_file = new File(paramItem_trim);

                if(input_dir_file.exists() && input_dir_file.isDirectory()) {

                    inputDirFileList.add(input_dir_file);
                }


                if(paramItem_trim.toLowerCase().trim().startsWith("outdir_")) {

                    String outDirPathInput = paramItem_trim.replace("outdir_", "");

                    File outDirFile = new File(outDirPathInput);
                    
                    System.out.println("outdir_ 原始输入: paramItem_trim["+ paramItem_trim+"] outDirPath["+outDirPath+"]" +"outDirFile.exists()["+outDirFile.exists()+"]");

                    
                    if(outDirFile.exists() && outDirFile.isDirectory()) {
                    	outDirPath = outDirFile.getAbsolutePath();

                        isNeedOutFile = true;
                        System.out.println("选中 outDirPath = "+ outDirPathInput);
                    }

                }

                
                if(paramItem_trim.toLowerCase().trim().startsWith("outname_")) {

                    String outName = paramItem_trim.replace("outname_", "");

                    outFileName = outName;
                    isNeedOutFile = true;

                }
                


            }


            if(outDirPath == null && outFileName == null) {
                System.out.println("当前 没有指定输出文件夹路径 outDirPath="+outDirPath+"  没有指定输出文件名称  outFileName="+ outFileName+" 使用默认路径: curDirPath="+curDirPath+" 默认文件名称:  rule_"+ rule_index+"_filesummary.txt" );

                outFileName =  "rule_"+rule_index+"_filesummary.txt";
                outDirPath = curDirPath;
         
            } else if(outDirPath != null && outFileName == null)  {

                System.out.println("当前指定的"+outFileName+" 文件输出目录:"+ outDirPath +" 默认文件名称:  rule_"+ rule_index+"_filesummary.txt" );
         
                outFileName =  "rule_"+rule_index+"_filesummary.txt";

            }else if(outDirPath == null && outFileName != null)  {

                System.out.println("当前 没有指定输出文件夹路径 outDirPath="+outDirPath+"  有指定输出文件名称  outFileName="+ outFileName+" 使用默认路径: curDirPath="+curDirPath );
         
                outDirPath = curDirPath;

            }
            System.out.println("outDirPath = "+ outDirPath);
            System.out.println("outFileName = "+ outFileName);
            


            outResultFile = new File(outDirPath+File.separator+outFileName);

            System.out.println("是否输出文件标识: isNeedOutFile="+isNeedOutFile+"  输出out文件路径: "+ outResultFile.getAbsolutePath() );

          

            if(inputDirFileList.size() != 0) {
                isDirInput = true;

                for (int i = 0; i < inputDirFileList.size(); i++) {
                    File dirFile = inputDirFileList.get(i);
                
                        System.out.println("SearchDir统计文件夹列表["+i+"]["+inputDirFileList.size()+"] = "+  dirFile.getAbsolutePath());

                   
                }
            } else {

                System.out.println("当前没有 指定输入文件夹! 将把Shell目录 "+curDirPath+" 作为输入参数 统计文件情况  输出Flag: isNeedOutFile="+isNeedOutFile );
            }

            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }



        void filesummary_operation(ArrayList<File> inputDirFileList) {


            for (int i = 0; i < inputDirFileList.size(); i++) {
                File inputDirFile = inputDirFileList.get(i);
                
                
                
                 ArrayList<String> summaryTipList = new ArrayList<String>();
            	 ArrayList<String> dirFileTipList = new ArrayList<String>();
            	 ArrayList<String> realFileTipList = new ArrayList<String>();
                 ArrayList<String> fileTypeTipList = new ArrayList<String>();
            	 HashMap<File,Long> dirFileSizeMap = new HashMap<File,Long> ();
            	
            	
            	 
            	Set<File> allDirFileSet = new HashSet<>(); // 工程下所有的 文件夹文件
            	Set<File> allSimpleFileSet = new HashSet<>();
            	// 文件 类型 对应的 文件集合
            	HashMap<String, ArrayList<File>> arrFileMap = new HashMap<String, ArrayList<File>>();

            	 
            	 
                 ArrayList<File> allSubDir = 	getAllSubDirFile(inputDirFile);

         		
         		ArrayList<File> allDirFileArr = new ArrayList<File>();
        		
        		allDirFileArr.addAll(allSubDir);
         	
         		
        		long allDirFileSize = 0 ; // 当前所有目录 所有文件的大小
        		
        		
        		for (int j = 0; j < allDirFileArr.size(); j++) {
        			
        		File dirFile = allSubDir.get(j);
        		if(dirFile.isFile()) {
        			continue;
        		}
        		long dirLength = getDirectorySizeByte(dirFile);
        			
        		dirFileSizeMap.put(dirFile, dirLength);
        		
        		allDirFileSize += dirLength;
        			
        		}
        		
        		allDirFileArr.sort(new Comparator<File>() {
        			@Override
        			public int compare(File o1, File o2) {
        				// TODO Auto-generated method stub
        				Long o1_length = dirFileSizeMap.get(o1);
        				Long o2_length = dirFileSizeMap.get(o2);
        				if(o1_length > o2_length) {
        					
        					return -1;
        				}
        				if(o1_length < o2_length) {
        					
        					return 1;
        				}
        				return 0;
        			}
        		});
        		

//        		System.out.println("AllSize_"+"[ "+get15FixedType(""+(getPaddingString(getFileSizeGBString(allDirFileSize), 8, " ", true))).trim()+" ]"+" [ "+get15FixedType(""+(getPaddingString(getFileSizeMBString(allDirFileSize), 8, " ", true))).trim()+" ]");

//        		System.out.println("文件夹总数:"+ dirFileSizeMap.size() );
//        		System.out.println("文件总数:" );

        		summaryTipList.add("AllSize_"+"[ "+get15FixedType(""+(getPaddingString(getFileSizeGBString(allDirFileSize), 8, " ", true))).trim()+" ]"+" [ "+get15FixedType(""+(getPaddingString(getFileSizeMBString(allDirFileSize), 8, " ", true))).trim()+" ]");
        		summaryTipList.add("AllDireCount:["+ getPaddingIntString(dirFileSizeMap.size(),6," ",true)+"   ]");

        		int fileDirIndex = 1;
        		for (File dirFile : allDirFileArr) {
//        			System.out.println("Dir[ " + allDirFileArr.size()+"_" +getPaddingIntString(fileDirIndex,5," ",false) + "]"+ "   " +"Size["+ get15FixedType(""+(getPaddingString(getFileSizeMBString(dirFileSizeMap.get(dirFile)), 9, " ", true)))+"]"+"    " + dirFile.getAbsolutePath());
        		
        			dirFileTipList.add("Dir[ " + allDirFileArr.size()+"_" +getPaddingIntString(fileDirIndex,5," ",false) + "]"+ "   " +"Size["+ get15FixedType(""+(getPaddingString(getFileSizeMBString(dirFileSizeMap.get(dirFile)), 9, " ", true)))+"]"+"    " + dirFile.getAbsolutePath());
        		
        			fileDirIndex++;
        		}
        		
        		
        		for (File dirFile : allDirFileArr) {  //  获取到 所有实体文件
        			File[] childFileList = dirFile.listFiles();
        		if (childFileList != null && childFileList.length > 0) {
        			for (int x = 0; x < childFileList.length; x++) {
        				if (!childFileList[x].isDirectory()) {
        					allSimpleFileSet.add(childFileList[x]);
        				}
        			}

        		   }
        		}
        		
        		
        		//----------- 获取到 所有实体文件的 类型 Begin -----------
        		int mFileTypeindex = 1;
        		System.out.println();
        		System.out.println();
        		int allFileCount = allSimpleFileSet.size();
        		
        		ArrayList<File> allFileArray = new ArrayList<File> ();
        		allFileArray.addAll(allSimpleFileSet);
        		
        		allFileArray.sort(fileSizeCompara);
        	
        		for (File curFile : allFileArray) {
        			String fileName = curFile.getName();
//        			System.out.println("文件索引[ " + allFileCount+"_"+getPaddingIntString(index,6," ",false) + "]"+" Size[ " +getPaddingString(getFileSizeMBString(curFile.length()),9," ",true)+" ]"+"  路径: " + curFile.getAbsolutePath() );
        			realFileTipList.add("File[ " + allFileCount+"_"+getPaddingIntString(mFileTypeindex,6," ",false) + "]"+" Size[ " +getPaddingString(getFileSizeMBString(curFile.length()),9," ",true)+" ]"+"  Path: " + curFile.getAbsolutePath() );
        		
        			if (!fileName.contains(".")) {
        				addFileMapItemWithKey("unknow", curFile,arrFileMap);
        				
        			} else {
        				String suffix = fileName.substring(fileName.lastIndexOf(".")).trim().toLowerCase();
        				addFileMapItemWithKey(suffix, curFile,arrFileMap);
        			}
        			mFileTypeindex++;

        		}
        		//----------- 获取到 所有实体文件的 类型 End -----------

 
        		
        		//----------- 遍历所有文件 Begin  -----------

        		int fileSumIndex = 0;
        		System.out.println();
        		System.out.println();
        		Map.Entry<String, ArrayList<File>> entry;
        		if (arrFileMap != null) {
        			Iterator iterator = arrFileMap.entrySet().iterator();
        			while (iterator.hasNext()) {
        				entry = (Map.Entry<String, ArrayList<File>>) iterator.next();
        				String typeStr = entry.getKey(); // Map的Value
        				ArrayList<File> fileArr = entry.getValue(); // Map的Value
        				
        			    long mSameTypeFileSize = 0 ;
        			    if(fileArr != null && fileArr.size() > 0 ) {
        			    	
        			    	for (int k = 0; k < fileArr.size(); k++) {
        			    		mSameTypeFileSize  +=  ( fileArr.get(k) == null ? 0 : fileArr.get(k).length());
        					}
        			    }
        				int curFileSize = fileArr.size();
        				fileSumIndex = fileSumIndex + curFileSize;
        				// System.out.println("文件类型:" + get15FixedType(typeStr) + " 匹配文件个数:" +
        				// fileArr.size());
        				
        				fileTypeTipList.add("FileType:" + get15FixedType(typeStr) + "  MatchCount:" + get15FixedType(""+curFileSize) +"TypeSpace:"+get15FixedType(""+(getPaddingString(getFileSizeMBString(mSameTypeFileSize), 9, " ", true)))+typeStr);
        			
        			
        			}
        		}
        		fileTypeTipList.sort(strCompara);
//        		for (String infoItem : fileTypeTipList) {
//        			System.out.println(infoItem);
//        		}
//        		System.out.println("文件夹总数:" + allSimpleFileSet.size() +"           匹配文件类型总数:"+fileTypeTipList.size());
//        		System.out.println("文件总数:" + fileSum);
        		summaryTipList.add("AllFileCount:[" + getPaddingIntString(fileSumIndex,6," ",true)+"   ]");
        		
        		
        		summaryTipList.add("AllTypeCount:["+getPaddingIntString(fileTypeTipList.size(),6," ",true)+"   ]"  );
        		summaryTipList.add("CurPath: "+inputDirFile.getAbsoluteFile());
        		//----------- 遍历所有文件 End  -----------

        		
        		//----------- 打印 所有文件  End  -----------
        		
        		
        		ArrayList<String> allPrintInfo = new 	ArrayList<String>();
        		
        		
        		for (String infoItem : summaryTipList) {
        			System.out.println(infoItem);
        			allPrintInfo.add(infoItem);
        		}
        		
        		System.out.println();
        		System.out.println();
        		allPrintInfo.add("\n");
          		allPrintInfo.add("\n");
        		for (String infoItem : dirFileTipList) {
        			System.out.println(infoItem);
        			allPrintInfo.add(infoItem);
        		}
        		
        		System.out.println();
        		System.out.println();
        		allPrintInfo.add("\n");
          		allPrintInfo.add("\n");
        		
        		for (String infoItem : realFileTipList ) {
        			System.out.println(infoItem);
         			allPrintInfo.add(infoItem);
        		}
        		
        		System.out.println();
        		System.out.println();
        		allPrintInfo.add("\n");
          		allPrintInfo.add("\n");
          		
        		for (String infoItem : fileTypeTipList) {
        		System.out.println(infoItem);
      			allPrintInfo.add(infoItem);
        	    }

        		System.out.println();
        		allPrintInfo.add("\n");
        		
        		for (String infoItem : summaryTipList) {
        			System.out.println(infoItem);
          			allPrintInfo.add(infoItem);
        		}
        		
           		allPrintInfo.add("\n");
           		allPrintInfo.add("\n");
           		allPrintInfo.add("\n");
        		
        		
        		//----------- 打印 所有文件 Begin   -----------
        		
       

           		if(isNeedOutFile ) {
           			outResultTipList.add("```");
           			outResultTipList.addAll(allPrintInfo);
           			outResultTipList.add("```");

           		}

          

            }

            System.out.println();
            
            if(isNeedOutFile && outResultFile != null) {
            	System.out.println("输出当前目录详情到 out文件 : "+ outResultFile.getAbsolutePath());
            	
            	writeContentToFile(outResultFile, outResultTipList);
            	
            } else {
            	
            	System.out.println("当前 无输出文件!  无输出 outname_  outdir_参数 仅打印 目录情况!");

            }
            
            System.out.println("________程序结束___________");

            
        }

        
        void addFileMapItemWithKey(String keyType, File curFile , HashMap<String, ArrayList<File>> arrFileMap) {
    		if (arrFileMap.containsKey(keyType)) {
    			ArrayList<File> fileList = arrFileMap.get(keyType);
    			fileList.add(curFile);
    		} else {
    			ArrayList<File> fileList = new ArrayList<File>();
    			fileList.add(curFile);
    			arrFileMap.put(keyType, fileList);
    		}
    	}
        
        
    
        @Override
        ArrayList<File> applyDir_SubFileListRule5(ArrayList<File> allSubDirFileList,
                                                  ArrayList<File> allSubRealFileList) {



            if(isDirInput) {   // 对输入的 目录 进行统计

                filesummary_operation(inputDirFileList);

            } else {  //  对自身Shell 路径进行统计

                System.out.println("当前没有 指定遍历的目录 对当前shell路径进行遍历:"+ curDirPath);

                ArrayList<File> searchDirFileList = new ArrayList<File> ();

                searchDirFileList.add(new File(curDirPath));

                filesummary_operation(searchDirFileList);
                System.out.println("当前没有 指定遍历的目录 对当前shell路径进行遍历:"+ curDirPath);

            }



            return super.applyDir_SubFileListRule5(allSubDirFileList, allSubRealFileList);
        }


        String getRelativeSubDirName(String subDirAbsPath , String rootDirAbsPath) {
            String relative_name = subDirAbsPath.replace(rootDirAbsPath, "");

            return relative_name;
        }

    

    }
    
    
	public static Comparator strCompara = new Comparator<String>() {
		@Override
		public int compare(String o1, String o2) {
			return o1.compareTo(o2);
		}
	};
    
	public static Comparator fileSizeCompara = new Comparator<File>() {
		@Override
		public int compare(File o1, File o2) {
			if(o1.length() > o2.length()) {
				return -1;
			}
			
			if(o1.length() == o2.length()) {
			  return 0 ; 	
			 }
			
			return 1;
			
		}
	};
    
	static String get15FixedType(String type) {
		// type 最长保留10位
		String fixedType = "";
		int curLength = type.length();
		if (curLength < 15) {
			int blankIndex = 15 - curLength;
			for (int i = 0; i < blankIndex; i++) {
				fixedType = " " + fixedType;
			}

		}

		return type + fixedType;
	}


	static String getPaddingString(String rawStr, int padinglength, String oneStr, boolean dirPre) {
		String result = "" + rawStr;
		int length = ("" + rawStr).length();

		if (length < padinglength) {
			int distance = padinglength - length;
			for (int i = 0; i < distance; i++) {
				if (dirPre) {
					result = oneStr + result;
				} else {
					result = result + oneStr;
				}

			}

		}
		return result;

	}
	
	

	
    public static String getFileSizeGBString(long fileSize) {
    	double length = 0;

    	length = (double) ((double) fileSize / (1024*1024*1024));

    	String result = decimalFormatOne.format(length)+"GB";
//    	System.out.println("GGGGGBBBBresult="+result+"   length="+length+"   fileSize="+fileSize);

    	
        return result;
    }
    
    
    public static String getFileSizeMBString(long fileSize) {
    	double length = 0;

    	length = (double) ((double)  fileSize / (1024*1024));

    	String result = decimalFormatOne.format(length)+"MB";
    	
//    	System.out.println("result="+result+"   length="+length+"   fileSize="+fileSize);
    	
        return result;
    }
    
	
    public static double getFileSizeMBLong(long fileSize) {
    	double length = 0;

    	length = (double) ((double) fileSize / (1024*1024));

    	
    	
        return (long)length;
    }
    
	static  DecimalFormat decimalFormatOne = new DecimalFormat("#0.0");

    
    /**
     * This method gets you the total size in Mb of a given directory
     *
     * @param dir Directory
     * @return Total size in Mb (int)
     */
    public static double getDirectorySizeMb(File dir) {
        double length = 0;
        File[] files = dir.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isFile())
                    length += (double)file.length() / (1024 * 1024);
                else
                    length += getDirectorySizeMb(file);
            }
        }

        return length;
    }

    
    public static long getDirectorySizeByte(File dir) {
        long length = 0;
        File[] files = dir.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isFile())
                    length += file.length() ;
                else
                    length += getDirectorySizeMb(file);
            }
        }

        return length;
    }
    
    
    public static double getDirectorySizeMb(String path) {
        return getDirectorySizeMb(new File(path));
    }
    
    class Draw_FileNameText_To_JPG_Top_Rule_70 extends Basic_Rule {
    	
    	
    	boolean mDrawName = false;
    	
    	String mOutDirTimeStamp; 
    	
    	File curShellDir ; 
    	
    	File outJpgDir ;

    	
    	Draw_FileNameText_To_JPG_Top_Rule_70() {
            super("#", 70, 4);
            mDrawName = false;
            mOutDirTimeStamp = getTimeStamp_yyyyMMdd_HHmmss();
        }
        
    	
        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {


        	curShellDir = curDirFile;
        	
        	outJpgDir = new File(curDirFile.getAbsoluteFile()+File.separator+mOutDirTimeStamp+"_"+"drawFileName");
        	

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramStr = inputParamList.get(i);
                System.out.println("param" + i + "[" + paramStr + "] ");
       
                
                if (paramStr.toLowerCase().contains("drawname_true")) {
                	mDrawName = true;
                }
                

            
            }
            
            System.out.println("curShellDir " + curShellDir.getAbsolutePath() + "mDrawName[" + mDrawName + "] ");

            
             return super.initParamsWithInputList(inputParamList);
        }

        
        @Override
        String simpleDesc() {
            return "  \n"
                    + Cur_Bat_Name  + " #_"+rule_index+" drawname_true   ### 往 当前目录的 jpg,png 文件  draw 画当前的 文件名字 \n"

                    ;
        }
        
        
        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

        	if(!mDrawName) {
                System.out.println("Rule"+rule_index+":   当前执行往jpg文件添加 文件名称的启动参数 mDrawName=" +mDrawName+" 请检查是否输入参数 drawname_true !");

            	return null ; 
        		
        	}
            System.out.println("Rule"+rule_index+":   搜索到的实体文件个数:" + curRealFileList.size());

            ArrayList<File> pictureFileList = new ArrayList<File>();
            int picture_index = 1;
            for (int i = 0; i < curRealFileList.size(); i++) {
                File curFile = curRealFileList.get(i);
                String currentFileName = curFile.getName().toLowerCase();
                if (currentFileName.endsWith(".jpg") || currentFileName.endsWith(".png")) {
                    pictureFileList.add(curFile);
                    System.out.println("picture_index[" + picture_index + "] = " + curFile.getAbsolutePath());
                    picture_index++;
                }

            }
            
            
            System.out.println("pictureFileList.size() = [" + pictureFileList.size() + "]");

            if(pictureFileList.size() == 0) {
                System.out.println("Rule"+rule_index+":   搜索到的jpg png文件个数:" + pictureFileList.size()+" 请检查!");

            	return null ; 
            }
            
            for (int i = 0; i < pictureFileList.size(); i++) {
            	
            	File jpgFile = pictureFileList.get(i);
            	
            	DrawFileName(jpgFile,outJpgDir);
				
			}

            return curRealFileList;
        }
        
        
        void DrawFileName(File srcJpgFile, File outJpgDir) {
        	
        	String fileName = srcJpgFile.getName();
          	String fileName_NoPoint = getFileNameNoPoint(srcJpgFile);
        	File dstJpgFile = new File(outJpgDir.getAbsolutePath()+File.separator+fileName);
        	
        	
            fileCopy(srcJpgFile, dstJpgFile);
            File mCurFile = srcJpgFile;
        	
            
            ImageIcon imageIcon = new ImageIcon(dstJpgFile.getAbsolutePath());

            BufferedImage bi = getBufferedImage(dstJpgFile);
            int heigh = bi.getHeight();
            int width = bi.getWidth();
            int jpg_width = width;
            int jpg_hight = heigh;
            
            
            Graphics2D g2 = (Graphics2D) bi.getGraphics();
            
            g2.setColor(new Color(255, 0, 0));// 设置颜色
            int frontSize = 28;

            Font f = new Font("楷体",  Font.BOLD, frontSize);
            g2.setFont(f); // 设置字体:字体、字号、大小
            
            FontRenderContext context = g2.getFontRenderContext();
            Rectangle2D mUpBounds = f.getStringBounds(fileName + "", context);
            
            int centerx = jpg_width / 2;
            int centery = jpg_hight / 2;
            
            g2.drawString(fileName_NoPoint + "", 30 ,  30); // 向图片上写字符串
            
            try {
//  					dstJpgFile.createNewFile();
                ImageIO.write(bi, "jpg", new FileOutputStream(dstJpgFile));// 保存图片 JPEG表示保存格式
//                  System.out.println("创建文件[" + dstJpgFile.getName() + "]  = " + dstJpgFile.getAbsolutePath() + "成功");
            } catch (Exception e) {
                System.out.println("复制图片格式出现异常！");
            }
            
            
        	
        }
        
    	
    }



    class PC_Show_QrCode_HttpServer_Rule69 extends Basic_Rule {

        String  mQrCodeImageName;
        File  mQrCodeImageFile;
        File  mDetailQrCodeImageFile;
        int Client_Index = 1 ;
        String upTipStr ;
        String downTipStr ;

        String  mQrCodeRule1Tag ;
        int monitorPort = 8888;

        PC_Show_QrCode_HttpServer_Rule69() {
            super("#", 69, 4);
            mQrCodeImageName = getTimeStamp_yyyyMMdd_HHmmssSSS()+".jpg";
            mQrCodeRule1Tag = "wirelessadb_connect_rule1";
            monitorPort = 8888 ;
        }

        
   
        
        @Override
        boolean allowEmptyDirFileList() {
            return true;
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {


            Http_Main();




            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }


        void Http_Main() {


            // ServerSocket指定端口port
            java.net.ServerSocket serverSocket = null ;
   
            try {

                // http://192.168.199.11:65000/wirelessadb_connect_rule1


                InetAddress addr;
                addr = InetAddress.getLocalHost();  // 【InetAddress.getLocalHost().getHostAddress()】
                String localHostIpAddr = addr.getHostAddress();


                String localWifiIpAddr = null ;


                Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
                int network_interface_index = 1;

                while (networkInterfaces.hasMoreElements()) {
                    NetworkInterface networkInterface = networkInterfaces.nextElement();

                    System.out.println("networkInterface["+network_interface_index+"].getName() = "+ networkInterface.getName());

                    if (networkInterface.getName().startsWith("wlan")) {
                        Enumeration<InetAddress> inetAddresses = networkInterface.getInetAddresses();
                        while (inetAddresses.hasMoreElements()) {
                            InetAddress inetAddress = inetAddresses.nextElement();
                            if (!inetAddress.isLoopbackAddress() && inetAddress.isSiteLocalAddress()) {
                                System.out.println("HostIpAddr IP Address: " + inetAddress.getHostAddress());
                                System.out.println("Wifi IP Address: " + inetAddress.getHostAddress());
                                localWifiIpAddr = inetAddress.getHostAddress();
                            }
                        }
                    }
                    network_interface_index++;
                }

                if(localWifiIpAddr != null && !localWifiIpAddr.equals(localHostIpAddr)){
                    localHostIpAddr = localWifiIpAddr;
                }

                upTipStr = "复制无线调式IP地址和端口 && ZMain执行Rule1_WirelessAdb扫描操作";
                downTipStr = "http://"+localHostIpAddr+":"+monitorPort+"/"+mQrCodeRule1Tag;
                serverSocket = new java.net.ServerSocket(monitorPort);

                if(serverSocket == null) {
                    System.out.println("无法启动Http服务---ip:port【"+localHostIpAddr+":"+monitorPort+"】");
                    return ;
                }


                String mQrCodeTipStr = "http://"+localHostIpAddr+":"+monitorPort+"/"+mQrCodeRule1Tag;
                downTipStr = mQrCodeTipStr;
                QrCodeOperation(mQrCodeTipStr);

                System.out.println("启动Http服务---ip:port【"+localHostIpAddr+":"+monitorPort+"】");

                while(true){
                    // 阻塞到有连接访问，拿到socket

                    System.out.println("主线程开始在端口______"+"【"+localHostIpAddr+":"+monitorPort+"】监听Accept()方法_______");
                    Socket 	socket = serverSocket.accept();
                    System.out.println();
                    System.out.println();
                    System.out.println();
                    System.out.println("主线程监听到在端口______"+"【"+localHostIpAddr+":"+monitorPort+"】有请求,从Accept()阻塞方法中苏醒_执行逻辑_______");


                    System.out.println("主线程接受到 客户端Client_Socket HashCode:"+socket.hashCode());

                    // STEP. 启动线程
                    new Thread(()->{
                        try {
                            // STEP. 获取输入流、输出流
                            OutputStream outputStream = null;
                            InputStream inputStream = null;
                            inputStream = socket.getInputStream();
                            outputStream = socket.getOutputStream();

                            // STEP. 获取输入内容
                            byte[] bytes = new byte[inputStream.available()];
                            int result = inputStream.read(bytes);
                            String clientIp = "";
                            if (result != -1) {
                                System.out.println("_________子线程客户ID["+Client_Index+"]打印Begin_______");
                                String mByteStr = new String(bytes);
                                System.out.println(mByteStr);
                                clientIp =   Operation_MobileUrl(mByteStr);
                                System.out.println("_________子线程客户ID["+Client_Index+"]End_______");


                            }

                            // STEP. 响应内容
                            // http 状态
                            String httpStatus = "200 OK";
                            // String httpStatus = "404 Not Found";
                            // String httpStatus = "500 Internal Server Error";

                            // 状态行、响应头部、空行、响应信息
                            String body = "<h1>hello_"+clientIp+"</h1>";
                            String responseStatusLine = "HTTP/1.1 "+httpStatus+"\r\n";
                            String responseHeader = "";
                            responseHeader += "Content-Length: " + body.getBytes().length + "\r\n";
                            responseHeader += "Content-Type: text/html; charset-utf-8\r\n";
                            String responseLine = "\r\n";
                            String responseBody = body + "\r\n";
                            String response = responseStatusLine + responseHeader +responseLine + responseBody;

                            // 输出响应内容、关闭流
                            outputStream.write(response.getBytes());//按照协议，将返回请求由outputStream写入
                            outputStream.flush();
                            socket.shutdownInput();
                            socket.shutdownOutput();
                            socket.close();
                            Client_Index++;
                        }catch (Exception e){
                            e.printStackTrace();
                        }

                    },String.valueOf(socket.hashCode())).start();
                }

            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

            System.out.println("_______Port:"+monitorPort+" While(true) 结束!_______");


        }


        String Operation_MobileUrl(String message) {
            String[] mMessageList = message.split("\n");

            String mTargetMessage = null ;
            if(mMessageList != null ) {

                for (int i = 0; i < mMessageList.length; i++) {
                    String mMessageItem = mMessageList[i];

                    System.out.println("mMessageList["+i+"_"+mMessageList.length+"] = "+ mMessageItem);

                    if(mMessageItem.contains(mQrCodeRule1Tag)) {
                        mTargetMessage = mMessageItem;
                    }

                }

            }else {

                System.out.println("message【"+message+"】  以\n 切割 为空  mMessageList ="+ mMessageList);
                return null;
            }

            // mMessageList[0_7] = GET /wirelessadb_connect_rule1?ip=192.168.1.102&port=37897 HTTP/1.1
            if(mTargetMessage == null) {
                System.out.println("message【"+message+"】  以\n 找不到包含 【"+mQrCodeRule1Tag+"】  mTargetMessage 的字符串 ="+ mTargetMessage);
                return null;

            }

            if(mTargetMessage.contains(" ")) {
                String[] mItemList = 	mTargetMessage.split(" ");

                for (int i = 0; i < mItemList.length; i++) {
                    String mMessageItem = mItemList[i];

                    System.out.println("mItemList["+i+"_"+mItemList.length+"] = "+ mMessageItem);

                    if(mMessageItem.contains(mQrCodeRule1Tag)) {
                        mTargetMessage = mMessageItem;
                    }

                }
            }


            // /wirelessadb_connect_rule1?ip=192.168.1.102&port=37897

            String shortUrl = mTargetMessage.replace(mQrCodeRule1Tag, "").replace("/", "").replace("?", "").trim();


//			System.out.println("shortUrl  = "+ shortUrl);


            System.out.println("shortUrl["+ shortUrl+"]");

            if(!shortUrl.contains("&")) {
                System.out.println("shortUrl = "+ shortUrl +" 携带的参数不够  没有包含& 符号!! 请检查!! ");
                return null;

            }

            String[] urlParams = shortUrl.split("&");

            String mobile_ip = "";

            String mobile_port = "";

            for (int i = 0; i < urlParams.length; i++) {
                String mParamItem = urlParams[i];

                System.out.println("mParamItem["+i+"_"+urlParams.length+"] = "+ mParamItem);


                if(mParamItem.startsWith("ip=")) {
                    mobile_ip = mParamItem.replace("ip=", "");

                }

                if(mParamItem.startsWith("port=")) {
                    mobile_port = mParamItem.replace("port=", "");

                }

            }

            if("".equals(mobile_ip) || "".equals(mobile_port)) {

                System.out.println("mobile_ip = "+ mobile_ip +" mobile_port["+mobile_port+"]  为空! 请检查! ");
                return null;
            }
            
            
        	String ipPortStr = mobile_ip+":"+mobile_port;
        	

            System.out.println("Success---> "+"mobile_ip["+ mobile_ip +"]  mobile_port["+mobile_port+"]  ");

            String adb_connect_command = "  adb start-server &&  adb connect  "+mobile_ip+":"+mobile_port +" && "+" adb -s "+mobile_ip+":"+mobile_port+" shell ";


            System.out.println("Success_adbconnect_command--->  \n"+adb_connect_command);

            // adb kill-server && adb connect

            
        	// 写入 adb**.bat 文件   然后 执行 
        	ArrayList<String> mWindowAdbCommandList = new ArrayList<String>();
        	mWindowAdbCommandList.add("@ECHO off");
        	mWindowAdbCommandList.add("Setlocal ENABLEDELAYEDEXPANSION");
        	mWindowAdbCommandList.add("adb start-server");
        	mWindowAdbCommandList.add("adb connect "+ ipPortStr);
        	mWindowAdbCommandList.add("set ip="+ipPortStr+"");
        	mWindowAdbCommandList.add("adb devices");
        	mWindowAdbCommandList.add("set device_name=\"\"");
        	mWindowAdbCommandList.add("for /F \"delims=\" %%i in ('adb -s "+ipPortStr +  " shell getprop ro.product.name') do set device_name=%%i");
        	mWindowAdbCommandList.add("set device_brand=\"\"");
        	mWindowAdbCommandList.add("for /F \"delims=\" %%i in ('adb -s "+ ipPortStr +" shell getprop ro.product.brand') do set device_brand=%%i");
        	mWindowAdbCommandList.add("echo adb start-server ^&^&^  adb connect "+ipPortStr+"  ^&^&^ adb -s "+ipPortStr+" shell ");
        	mWindowAdbCommandList.add("echo  _______brand[%device_brand%]_______name[%device_name%]_______ip[%ip%]_______");
        	mWindowAdbCommandList.add("adb -s "+ipPortStr+" shell");
        	
        	writeContentToFile(G2_Temp_Bat_File , mWindowAdbCommandList);
        	
            try {


            	// 这里 需要 改进 ， 新打开 Cmd 后 执行命令 并显示命令结果 
                String cmdCommand = "CMD.exe /c start cmd /k  " + G2_Temp_Bat_File.getAbsolutePath();
                System.out.println("Success_cmd_command--->  exe bat File -> \n"+G2_Temp_Bat_File.getAbsolutePath());
//  	  		execCMD(cmdCommand);


                Runtime.getRuntime().exec(cmdCommand);
//  				Runtime.getRuntime().exec(cmdCommand);
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

            return mobile_ip;
        }


        void QrCodeOperation(String message) {

            // 创建 二维码

            // 显示二维码

            if (CUR_OS_TYPE == OS_TYPE.Windows) {
                TextAs_QrCode_Rule_15_Win(message);
            } else if (CUR_OS_TYPE == OS_TYPE.MacOS || CUR_OS_TYPE == OS_TYPE.Linux) {
                // 实现 Mac 下 显示 二维码
                TextAs_QrCode_Rule_15_Mac(message);

            }


        }

        void TextAs_QrCode_Rule_15_Win(String mQrCodeStr) {

            QrConfig config = new QrConfig();
            if(G2_Temp_Dir_File != null && !G2_Temp_Dir_File.exists()) {

                G2_Temp_Dir_File.mkdirs();
            }

            mQrCodeImageFile =  new File(G2_Temp_Dir_File.getAbsolutePath() + File.separator + mQrCodeImageName);

            config.setMargin(10);
            config.setWidth(500);
            config.setHeight(500);

            File targetQrCodeImageFile = QrCodeUtil.generate(mQrCodeStr, config, mQrCodeImageFile );
            mDetailQrCodeImageFile = new File(G2_Temp_Dir_File.getAbsolutePath() + File.separator + "detail_"+mQrCodeImageName);

            drawTagJpg(targetQrCodeImageFile,mDetailQrCodeImageFile,upTipStr,downTipStr);


//             System.out.println("targetQrCodeImageFile = "+ targetQrCodeImageFile.getAbsolutePath());
            RuntimeUtil.exec("rundll32.exe C:\\\\Windows\\\\System32\\\\shimgvw.dll,ImageView_Fullscreen  " + mDetailQrCodeImageFile.getAbsolutePath());


        }

        void TextAs_QrCode_Rule_15_Mac(String mQrCodeStr) {

        }


        void drawTagJpg(File srcJpgFile, File dstJpgFile, String upTip ,  String downTip) {

            if (!dstJpgFile.getParentFile().exists()) {
                dstJpgFile.getParentFile().mkdirs();
            }

            fileCopy(srcJpgFile, dstJpgFile);
            File mCurFile = srcJpgFile;

            ImageIcon imageIcon = new ImageIcon(dstJpgFile.getAbsolutePath());

            BufferedImage bi = getBufferedImage(dstJpgFile);
            int heigh = bi.getHeight();
            int width = bi.getWidth();
            int jpg_width = width;
            int jpg_hight = heigh;

//  				BufferedImage bi = new BufferedImage(width, heigh, BufferedImage.TYPE_INT_RGB);// INT精确度达到一定,RGB三原色，高度70,宽度150
            // 得到它的绘制环境(这张图片的笔)
            Graphics2D g2 = (Graphics2D) bi.getGraphics();
//  				g2.fillRect(0, 0, jpg_width, jpg_width);// 填充一个矩形 左上角坐标(0,0),宽500,高500;填充整张图片
            g2.setColor(new Color(0, 0, 0));// 设置颜色
//  				g2.fillRect(0, 0, width, heigh);// 填充整张图片(其实就是设置背景颜色)
            int frontSize = 14;
            int centerx = jpg_width / 2;
            int centery = jpg_hight / 2;

            int centery_20 = jpg_hight / 20;
            int centerx_20 = (jpg_width / 20) * 19;

            Font f = new Font("楷体",  Font.BOLD, frontSize);
            g2.setFont(f); // 设置字体:字体、字号、大小
            FontRenderContext context = g2.getFontRenderContext();
            Rectangle2D mUpBounds = f.getStringBounds(upTip + "", context);

            Rectangle2D mDownBounds = f.getStringBounds(downTip + "", context);

//              g2.setColor(Color.RED);
            g2.drawString(upTip + "", (float) (centerx - mUpBounds.getCenterX() ),
                    (float) (centery -   mUpBounds.getCenterY() - 200)); // 向图片上写字符串

//              g2.setColor(Color.BLACK);
            g2.drawString(downTip + "", (float) (centerx - mDownBounds.getCenterX() ),
                    (float) (centery + mDownBounds.getCenterY() + 200)); // 向图片上写字符串

//  				g2.drawString(drawText + "", (float) (centerx - bounds.getCenterX()),	(float) (centery - bounds.getCenterY())); // 向图片上写字符串

            try {
//  					dstJpgFile.createNewFile();
                ImageIO.write(bi, "jpg", new FileOutputStream(dstJpgFile));// 保存图片 JPEG表示保存格式
//                  System.out.println("创建文件[" + dstJpgFile.getName() + "]  = " + dstJpgFile.getAbsolutePath() + "成功");
            } catch (Exception e) {
                System.out.println("复制图片格式出现异常！");
            }

        }


        @Override
        String simpleDesc() {
        String addressTip ="HTTP";
		try {
			addressTip = "http://"+InetAddress.getLocalHost().getHostAddress();
		} catch (UnknownHostException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
        	
            return "  \n"
                    + Cur_Bat_Name  + " #_"+rule_index+"  ## 实现一个模拟的 "+addressTip +":"+monitorPort+" 服务器 为 无线 adb 做准备\n"
                    + Cur_Bat_Name  + " #_"+rule_index+"  ## 实现一个模拟的 "+addressTip+":"+monitorPort+" 服务器 为 无线 adb 做准备 \n"

                    ;
        }


        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            return super.initParamsWithInputList(inputParamList);
        }

    }



    class AOSP_Replace_Src_TagFlag_Dst_Rule_68 extends Basic_Rule {


        // 从 输入的 目录  已经 tag ,得到的所有文件 以及 该文件所在的 tagStr 所在行
        HashMap<File,String> mSrcFile_TagStr_FileMap;   // 从输入文件得到的  原内容 和 替换内容的集合Map
        HashMap<File,String> mDstFile_TagStr_FileMap;  //  包含 TagStr 的 文件的集合

        //   res/values-zh-rCN/string.xml   <TagStr> 相对路径的Map
        HashMap<String,String> mSrcRelativePath_TagStr_Map;
        HashMap<String,String> mDstRelativePath_TagStr_Map;

        //   res/values-zh-rCN/string.xml     SrcFile
        HashMap<String,File> mSrcRelativePath_SrcFile_Map;
        HashMap<String,File> mDstRelativePath_DstFile_Map;


        File srcSearchDirFile ;
        String tagStrFlag ;     //  标识 行 字符串
        File dstSearchDirFile ;


        AOSP_Replace_Src_TagFlag_Dst_Rule_68() {
            super("#", 68, 4); //
            mSrcFile_TagStr_FileMap = new HashMap<File,String>();
            mDstFile_TagStr_FileMap =  new HashMap<File,String>();


            mSrcRelativePath_TagStr_Map = new  HashMap<String,String>();
            mDstRelativePath_TagStr_Map  = new  HashMap<String,String>();

            mSrcRelativePath_SrcFile_Map =  new HashMap<String,File>();
            mDstRelativePath_DstFile_Map =  new HashMap<String,File>();

        }



        @Override
        String simpleDesc() {
            if(CUR_OS_TYPE == OS_TYPE.Windows) {

                return
                        Cur_Bat_Name + " #_" + rule_index + "  [src源路径][tag标识符][dst目的目录]    ##   AOSP中字符串的替换      // 指定当前 src 源目录文件夹 在该路径搜索指定 tagString , 然后在目的Dst路径搜索 如果 后缀路径与 src源匹配 并且 也有匹配到 tagString 那么替换该字符串所在行\r\n"
                                + "           \n"
                                +   Cur_Bat_Name + " #_" + rule_index + "  [D:\\jira_work\\143453\\src][wifi_hotspot_maximize_compatibility_single_ap_summary][D:\\jira_work\\143453\\dst]     ##  指定src目录 查询 tagString所在字符串行 匹配替换到dst目录查询到的路径名称相同的文件内   \n"

                        ;


            }

            return
                    Cur_Bat_Name + " #_" + rule_index + "  '[src源路径][tag标识符][dst目的目录]'    ##   AOSP中字符串的替换      // 指定当前 src 源目录文件夹 在该路径搜索指定 tagString , 然后在目的Dst路径搜索 如果 后缀路径与 src源匹配 并且 也有匹配到 tagString 那么替换该字符串所在行\r\n"
                            + "           \n"
                            +   Cur_Bat_Name + " #_" + rule_index + "  '[D:\\jira_work\\143453\\src][wifi_hotspot_maximize_compatibility_single_ap_summary][D:\\jira_work\\143453\\dst]'     ##  指定src目录 查询 tagString所在字符串行 匹配替换到dst目录查询到的路径名称相同的文件内   \n"

                    ;
        }



        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            File  srcDirFile = null ;
            File  dstDirFile = null ;

            for (int i = 0; i < inputParamList.size(); i++) {
                String strInput = inputParamList.get(i);

                File tempFile_relative = new File(curDirPath + File.separator + strInput);   // 相对路径
                File  tempFile_abs = new File(strInput);   // 相对路径


                String oneLine = inputParamList.get(i).trim();


                if(oneLine.startsWith("[") && oneLine.endsWith("]") && oneLine.contains("][")){

                    String clear_pre_end_str = oneLine.substring(1,oneLine.length()-1);

                    String[] splitArr = clear_pre_end_str.split("\\]\\[");
                    if(splitArr == null || splitArr.length != 3){
                        System.out.println("当前行["+(i+1)+"]输入参数内容: "+ oneLine+"  无法解析为  【Src目录路径】【StrFlag标识字符串】【Dst目录路径】 跳过该行  请注意!");
                        continue;
                    }

                    String srcPathStr = splitArr[0].trim();

                    String mStrFlag = splitArr[1].trim();
                    tagStrFlag = mStrFlag;
                    String dstPathStr = splitArr[2].trim();


                    System.out.println("param["+i+"_"+""+inputParamList.size()+"] ____ value["+oneLine+"]"+ "SrcPathStr["+srcPathStr+"]  StrFlag["+mStrFlag+"]   DstPathStr["+dstPathStr+"]");

                    //  如果 当前  src[] dst[]  那么 忽略 这样的文本替换  [][]   [][]   [][]   [][]   [][]
                    if("".equals(srcPathStr) ||  "".equals(dstPathStr) ||  "".equals(mStrFlag) ){
                        System.out.println("当前输入参数 param["+i+"_"+""+inputParamList.size()+"] ____ value["+oneLine+"]"+ "SrcPathStr["+srcPathStr+"]  StrFlag["+mStrFlag+"]   DstPathStr["+dstPathStr+"]  可能都为空  [][][] 无法执行搜索关键字行替换规则! 请检查输入 ");

                        continue;
                    }

                    srcDirFile =new File(srcPathStr);
                    dstDirFile =new File(dstPathStr);

                    if(!srcDirFile.exists() || !dstDirFile.exists() ) {
                        if(!srcDirFile.exists()) {
                            System.out.println("当前输入参数 ["+i+"_"+inputParamList.size()+"] [src][dst]!!  SrcFile路径为空!  srcPathStr ["+srcPathStr+"]可能都为空 无法作为 [][][] 文本替换源");
                        }

                        if(!dstDirFile.exists()) {
                            System.out.println("当前输入参数 ["+i+"_"+inputParamList.size()+"] DstDirFile 路径为空! DstDirFile["+dstDirFile+"] 可能都为空 无法作为 [][][] 文本替换源");
                        }


                    }


                }

            }



            if(srcDirFile == null || dstDirFile == null || !srcDirFile.exists() || !dstDirFile.exists() || "".equals(tagStrFlag)) {

                System.out.println("当前输入参数SrcPathStr["+srcDirFile+"]  StrFlag["+tagStrFlag+"]   DstPathStr["+dstDirFile+"]  可能都为空  [][][] 无法执行搜索关键字行替换规则! 请检查输入 !!!");

                return false;

            }

            srcSearchDirFile = srcDirFile;
            dstSearchDirFile = dstDirFile;


            System.out.println("开始执行替换规则:  SrcPathStr["+srcDirFile+"]  StrFlag["+tagStrFlag+"]   DstPathStr["+dstDirFile+"]");

            return super.initParamsWithInputList(inputParamList);
        }


        void showStringFileMapTip(HashMap<String,File> src_dst_map , String tag ){
            StringBuilder  tipSB = new StringBuilder();


            Map.Entry<String, File> entryItem;
            int item_index = 0;
            int map_size = 0;
            map_size = src_dst_map.size();
            Iterator iterator = src_dst_map.entrySet().iterator();
            while (iterator.hasNext()) {
                entryItem = (Map.Entry<String, File>) iterator.next();
                String src_realtive_path  = entryItem.getKey(); // Map的Key
                File matchFile = entryItem.getValue(); // Map的Value

                tipSB.append(tag+"["+item_index+"_"+map_size+"]___key:["+src_realtive_path+"] value:["+matchFile.getAbsolutePath()+"]\n");
                item_index++;
            }

            System.out.println(tipSB.toString());

//        return tipSB.toString();

        }

        void showStringMapTip(HashMap<String,String> src_dst_map , String tag ){
            StringBuilder  tipSB = new StringBuilder();


            Map.Entry<String, String> entryItem;
            int item_index = 0;
            int map_size = 0;
            map_size = src_dst_map.size();
            Iterator iterator = src_dst_map.entrySet().iterator();
            while (iterator.hasNext()) {
                entryItem = (Map.Entry<String, String>) iterator.next();
                String src_realtive_path  = entryItem.getKey(); // Map的Key
                String matchLine = entryItem.getValue(); // Map的Value

                tipSB.append(tag+"["+item_index+"_"+map_size+"]___key:["+src_realtive_path+"] value:["+matchLine+"]\n");
                item_index++;
            }

            System.out.println(tipSB.toString());

//        return tipSB.toString();

        }

        void showMapTip(HashMap<File,String> src_dst_map , String tag ){
            StringBuilder  tipSB = new StringBuilder();


            Map.Entry<File, String> entryItem;
            int item_index = 0;
            int map_size = 0;
            map_size = src_dst_map.size();
            Iterator iterator = src_dst_map.entrySet().iterator();
            while (iterator.hasNext()) {
                entryItem = (Map.Entry<File, String>) iterator.next();
                File src_file = entryItem.getKey(); // Map的Key
                String matchLine = entryItem.getValue(); // Map的Value

                tipSB.append(tag+"["+item_index+"_"+map_size+"]___["+src_file.getAbsolutePath()+"]["+matchLine+"]\n");
                item_index++;
            }

            System.out.println(tipSB.toString());

//        return tipSB.toString();

        }



        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList, HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList, ArrayList<File> curRealFileList) {


            System.out.println("begin applySubFileListRule4 _____");


            ArrayList<File> allSrcFile = getAllSubFile(srcSearchDirFile);
            ArrayList<File> allDstFile = getAllSubFile(dstSearchDirFile);


            mSrcFile_TagStr_FileMap = calculAllFliterFile(allSrcFile,tagStrFlag);
            if(mSrcFile_TagStr_FileMap == null || mSrcFile_TagStr_FileMap.size() == 0) {

                System.out.println("当前从 源目录"+srcSearchDirFile.getAbsolutePath()+" 读取到所有文件数量【"+allSrcFile.size()+"】过滤关键字 【"+ tagStrFlag +"】后的文件数量为空!!! 执行失败! 请检查!");
                return null;
            }






            mDstFile_TagStr_FileMap = calculAllFliterFile(allDstFile,tagStrFlag);
            if(mDstFile_TagStr_FileMap == null || mDstFile_TagStr_FileMap.size() == 0) {

                System.out.println("当前从 目的目录"+dstSearchDirFile.getAbsolutePath()+" 读取到所有文件数量【"+allDstFile.size()+"】过滤关键字 【"+ tagStrFlag +"】后的文件数量为空!!! 执行失败! 请检查!");
                return null;
            }


            System.out.println("【1】_________srcFile["+mSrcFile_TagStr_FileMap.size()+"]________");

            showMapTip(mSrcFile_TagStr_FileMap,"src");
            System.out.println("");
            System.out.println("【1】_________dstFile["+mDstFile_TagStr_FileMap.size()+"]________");
            showMapTip(mDstFile_TagStr_FileMap,"dst");



            mSrcRelativePath_SrcFile_Map = calRelativePath_FileValue_Map(mSrcFile_TagStr_FileMap,srcSearchDirFile);
            mDstRelativePath_DstFile_Map = calRelativePath_FileValue_Map(mDstFile_TagStr_FileMap,dstSearchDirFile);
            System.out.println("【2】_________src_RelativePath_SrcFile_Map["+mSrcRelativePath_TagStr_Map.size()+"]________");
            showStringFileMapTip(mSrcRelativePath_SrcFile_Map,"realtivePathSrcFileMap");
            System.out.println("【2】_________src_RelativePath_SrcFile_Map["+mSrcRelativePath_TagStr_Map.size()+"]________");
            showStringFileMapTip(mDstRelativePath_DstFile_Map,"realtivePathSrcFileMap");


            mSrcRelativePath_TagStr_Map = calRelativePath_tagLineStr_Map(mSrcFile_TagStr_FileMap,srcSearchDirFile);
            mDstRelativePath_TagStr_Map = calRelativePath_tagLineStr_Map(mDstFile_TagStr_FileMap,dstSearchDirFile);


            System.out.println("【3】_________src_RelativePath_OneLine_Map["+mSrcRelativePath_TagStr_Map.size()+"]________");
            showStringMapTip(mSrcRelativePath_TagStr_Map,"src");

            System.out.println("【3】_________dst_RelativePath_OneLine_Map["+mDstRelativePath_TagStr_Map.size()+"]________");
            showStringMapTip(mDstRelativePath_TagStr_Map,"dst");



            // 1.开始 遍历 mDstRelativePath_TagStr_Map 拿到对应的路径
            // 2. 拿到 对应的 src 中的 StrLine
            // 3. 拿到 对应的 dst 中的 File
            // 重新写入 包含 String Tag 的 那行

            replaceOperation();

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        // 1.开始 遍历 mDstRelativePath_TagStr_Map 拿到对应的路径
        // 2. 拿到 对应的 src 中的 StrLine
        // 3. 拿到 对应的 dst 中的 File
        // 重新写入 包含 String Tag 的 那行
        void  replaceOperation(){



            Map.Entry<String, String> entryItem;
            int item_index = 0;
            int map_size = 0;
            map_size = mDstRelativePath_TagStr_Map.size();
            Iterator iterator = mDstRelativePath_TagStr_Map.entrySet().iterator();
            while (iterator.hasNext()) {
                entryItem = (Map.Entry<String, String>) iterator.next();
                String dst_realtive_path  = entryItem.getKey(); // Map的Key
                String oldLine  = entryItem.getValue(); //  需要 被替换的那行


                // 新的 那行 从 src 得到的那行
                String newLine = mSrcRelativePath_TagStr_Map.get(dst_realtive_path);

                File dstFile = mDstRelativePath_DstFile_Map.get(dst_realtive_path);

                if(newLine == null || "".equals(newLine.trim()) || dstFile ==null ||!dstFile.exists()) {
                    System.out.println("当前Map["+item_index+"_"+map_size+"] newLine【"+newLine+"】 替换oldLine【"+oldLine+"】 相对路径【"+dst_realtive_path+"】 绝对路径【"+dstFile+"】 出错,请检查!! ");
                    continue;
                }
                System.out.println("__执行当前替换操作__ Map["+item_index+"_"+map_size+"] newLine【"+newLine+"】 替换oldLine【"+oldLine+"】 相对路径【"+dst_realtive_path+"】 绝对路径【"+dstFile+"】  ");

                ArrayList<String> dstFileContentList = ReadFileContentAsList(dstFile);
                ArrayList<String> newFileContentList = new   ArrayList<String>();

                for (int i = 0; i < dstFileContentList.size(); i++) {
                    String lineItem =  dstFileContentList.get(i);
                    if(lineItem.contains(oldLine)) {
                        newFileContentList.add(newLine);
                        continue;
                    }
                    newFileContentList.add(lineItem);

                }
                System.out.println("目标文件行数:["+dstFileContentList.size()+"] 新文件行数:["+newFileContentList.size()+"]");
                System.out.println("替换_oldLine:["+oldLine+"]");
                System.out.println("替换_newLine:["+newLine+"]");
                writeContentToFile(dstFile, newFileContentList);

                System.out.println();
                System.out.println();
                item_index++;
            }



        }


        HashMap<String,File>   calRelativePath_FileValue_Map(HashMap<File,String> matchMap, File dirFile){
            HashMap<String,File>  resultMap = new  HashMap<String,File> ();


            Map.Entry<File, String> entryItem;
            int item_index = 0;
            int map_size = 0;
            map_size = matchMap.size();
            Iterator iterator = matchMap.entrySet().iterator();
            while (iterator.hasNext()) {
                entryItem = (Map.Entry<File, String>) iterator.next();
                File src_file = entryItem.getKey(); // Map的Key
                String src_realtive_path = src_file.getAbsolutePath().replace(dirFile.getAbsolutePath(), "");
                String matchLine = entryItem.getValue(); // Map的Value

                resultMap.put(src_realtive_path, src_file);
            }

            return resultMap;

        }


        HashMap<String,String>   calRelativePath_tagLineStr_Map(HashMap<File,String> matchMap, File dirFile){
            HashMap<String,String>  resultMap = new  HashMap<String,String> ();


            Map.Entry<File, String> entryItem;
            int item_index = 0;
            int map_size = 0;
            map_size = matchMap.size();
            Iterator iterator = matchMap.entrySet().iterator();
            while (iterator.hasNext()) {
                entryItem = (Map.Entry<File, String>) iterator.next();
                File src_file = entryItem.getKey(); // Map的Key
                String src_realtive_path = src_file.getAbsolutePath().replace(dirFile.getAbsolutePath(), "");
                String matchLine = entryItem.getValue(); // Map的Value

                resultMap.put(src_realtive_path, matchLine);
            }

            return resultMap;

        }

        HashMap<File,String>   calculAllFliterFile(ArrayList<File> fileList, String tagStr){
            HashMap<File,String>  resultMap = new  HashMap<File,String> ();

            for (int i = 0; i < fileList.size(); i++) {
                File fileItem = fileList.get(i);

                ArrayList<String> contentList = ReadFileContentAsList(fileItem);

                String matchLine = getContainLineInStrList(contentList, tagStr);

                if(matchLine != null) {
                    resultMap.put(fileItem, matchLine);
                }
            }
            return resultMap;
        }


    }



    class CopyFile_Src_to_Dst_Rule_67 extends Basic_Rule {


        HashMap<File,File> mSrc_Dst_FileMap;   // 从输入文件得到的  原内容 和 替换内容的集合Map


        boolean isMakeNewDir = false;   // 是否在没有路径的文件创建新的文件夹路径

        CopyFile_Src_to_Dst_Rule_67() {
            super("#", 67, 4); //
            mSrc_Dst_FileMap = new HashMap<File,File>();

        }



        @Override
        String simpleDesc() {
            if(CUR_OS_TYPE == OS_TYPE.Windows) {

                return
                        Cur_Bat_Name + " #_" + rule_index + "  [raw文件路径][路径内容txt文件路径]    ## 指定src文件  放入 dest.txt 文件指向的每一行目录    \n"
                                +   Cur_Bat_Name + " #_" + rule_index + "  [D:\\jira_work\\143453\\src.so][D:\\jira_work\\143453\\dst.txt]     ##  指定src.so文件  放入 dest.txt 文件每一行存在的文件路径   \n"
                                +   Cur_Bat_Name + " #_" + rule_index + " makedir_true   [D:\\jira_work\\143453\\src.so][D:\\jira_work\\143453\\dst.txt]     ##  指定src.so文件  放入 dest.txt 文件每一行存在的文件路径   \n"
                                +   Cur_Bat_Name + " #_" + rule_index + "    [src_file][path_list_file]     ##  指定 src_file.so 文件  放入 path_list_file 文件每一行存在的文件路径   \n"
                                +   Cur_Bat_Name + " #_" + rule_index + "    [][]     ##  指定 src_file.so 文件  放入 path_list_file 文件每一行存在的文件路径   \n"

                        ;


            }

            return
                    Cur_Bat_Name + " #_" + rule_index + "  '[raw文件路径][路径内容txt文件路径]'    ## 指定src文件  放入 dest.txt 文件指向的每一行目录    \n"
                            +   Cur_Bat_Name + " #_" + rule_index + "  '[D:\\jira_work\\143453\\src.so][D:\\jira_work\\143453\\dst.txt]'     ##  指定src.so文件  放入 dest.txt 文件每一行存在的文件路径   \n"
                            +   Cur_Bat_Name + " #_" + rule_index + " makedir_true   '[D:\\jira_work\\143453\\src.so][D:\\jira_work\\143453\\dst.txt]'     ##  指定src.so文件  放入 dest.txt 文件每一行存在的文件路径   \n"
                            +   Cur_Bat_Name + " #_" + rule_index + "    '[src_file][path_list_file]'     ##  指定 src_file.so 文件  放入 path_list_file 文件每一行存在的文件路径   \n"
                            +   Cur_Bat_Name + " #_" + rule_index + "    '[][]'     ##  指定 src_file.so 文件  放入 path_list_file 文件每一行存在的文件路径   \n"

                    ;
        }



        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {
                String strInput = inputParamList.get(i);

                File tempFile_relative = new File(curDirPath + File.separator + strInput);   // 相对路径
                File  tempFile_abs = new File(strInput);   // 相对路径


                String oneLine = inputParamList.get(i).trim();
                if("makedir_true".equals(oneLine)) {
                    isMakeNewDir = true;
                }

                if(oneLine.startsWith("[") && oneLine.endsWith("]") && oneLine.contains("][")){

                    String clear_pre_end_str = oneLine.substring(1,oneLine.length()-1);

                    String[] splitArr = clear_pre_end_str.split("\\]\\[");
                    if(splitArr == null || splitArr.length != 2){
                        System.out.println("当前行["+(i+1)+"]输入参数内容: "+ oneLine+"  无法解析为  【Src文件路径】【Dst内容路径】 跳过该行  请注意!");
                        continue;
                    }

                    String srcStr = splitArr[0].trim();

                    String dstStr = splitArr[1].trim();

                    System.out.println("param["+i+"_"+""+inputParamList.size()+"] ____ value["+oneLine+"]"+ "srcStr["+srcStr+"]  dstStr["+dstStr+"]   ["+srcStr+"]["+dstStr+"]");

                    //  如果 当前  src[] dst[]  那么 忽略 这样的文本替换  [][]   [][]   [][]   [][]   [][]
                    if("".equals(srcStr) && "".equals(dstStr)){
                        System.out.println("当前输入参数 ["+i+"_"+inputParamList.size()+"] [src][dst]!!   ["+srcStr+"]["+dstStr+"] 可能都为空 无法作为 [][] 文本替换源");

                        continue;
                    }

                    File  srcFile =new File(srcStr);
                    File  dstContentFile =new File(dstStr);

                    if(!srcFile.exists() || !dstContentFile.exists() ) {
                        if(!srcFile.exists()) {
                            System.out.println("当前输入参数 ["+i+"_"+inputParamList.size()+"] [src][dst]!!  SrcFile路径为空! ["+srcStr+"]["+dstStr+"] 可能都为空 无法作为 [][] 文本替换源");
                        }

                        if(!dstContentFile.exists()) {
                            System.out.println("当前输入参数 ["+i+"_"+inputParamList.size()+"] [src][dst]!!  DstContentFile路径为空! ["+srcStr+"]["+dstStr+"] 可能都为空 无法作为 [][] 文本替换源");
                        }

                    }


                    if(srcFile.exists() && dstContentFile.exists() ) {
                        mSrc_Dst_FileMap.put(srcFile,dstContentFile);
                    }

                }

            }



            if (mSrc_Dst_FileMap.size() == 0  ) {
                System.out.println("当前没有输入任何 src文件 dstPathTxt文件  以及 输入文本替换为 空  [][]  请检查输入! ");
                return  false;
            }


            System.out.println("开始执行替换规则: "+ buildReplaceFileTip(mSrc_Dst_FileMap));

            return super.initParamsWithInputList(inputParamList);
        }

        String buildReplaceFileTip(HashMap<File,File> src_dst_map  ){
            StringBuilder  tipSB = new StringBuilder();


            Map.Entry<File, File> entryItem;
            int item_index = 0;
            int map_size = 0;
            map_size = src_dst_map.size();
            Iterator iterator = src_dst_map.entrySet().iterator();
            while (iterator.hasNext()) {
                entryItem = (Map.Entry<File, File>) iterator.next();
                File src_file = entryItem.getKey(); // Map的Key
                File dst_content_file = entryItem.getValue(); // Map的Value

                tipSB.append("["+src_file.getAbsolutePath()+"]["+dst_content_file.getAbsolutePath()+"] ");
            }


            return tipSB.toString();

        }



        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList, HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList, ArrayList<File> curRealFileList) {


            System.out.println("begin applySubFileListRule4 _____");



            Map.Entry<File, File> entryItem;
            int item_index = 0;
            int map_size = 0;
            map_size = mSrc_Dst_FileMap.size();
            Iterator iterator = mSrc_Dst_FileMap.entrySet().iterator();
            while (iterator.hasNext()) {
                entryItem = (Map.Entry<File, File>) iterator.next();
                File src_file = entryItem.getKey(); // Map的Key
                File dst_content_file = entryItem.getValue(); // Map的Value


                ArrayList<String> dstAllContent =  ReadFileContentAsList(dst_content_file);

                System.out.println("╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤ InputSrcDstFile["+item_index+"_"+map_size+"]_"+src_file.getAbsolutePath()+"_"+"begin ╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤");


                for (int i = 0; i < dstAllContent.size(); i++) {
                    String oneLine = dstAllContent.get(i).trim();

                    File tempDir = new File(oneLine);


                    System.out.println("══════ InputSrcDstFile["+item_index+"_"+map_size+"]_["+i+"_"+dstAllContent.size()+"]"+src_file.getAbsolutePath()+"____"+oneLine);



                    if(tempDir.exists()) {
                        File tempDstFile = new File(tempDir.getAbsolutePath()+File.separator+src_file.getName());


                        fileCopy(src_file, tempDstFile);

                        System.out.println("InputSrcDstFile["+item_index+"_"+map_size+"]_["+i+"_"+dstAllContent.size()+"]"+" CopyResult:"+tempDstFile.exists()+"  DstPath:"+tempDstFile.getAbsolutePath());
                        System.out.println();
                    }
                }
                item_index++;
                System.out.println();
            }


            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }




    }



    class ReplaceTxtFile_Src_to_Dst_Rule_66 extends Basic_Rule {


        HashMap<String,String> mSrc_Dst_StrMap;   // 从输入文件得到的  原内容 和 替换内容的集合Map
        ArrayList<String> mSrcList ;   //  原始替换内容的集合  用于快速查询当前是否有 匹配的字符串


        boolean   isSearAllLocalFile = true;     // 无参数输入 那么 搜索所有文件
        ArrayList<File> inputFileList;    // 输入的文件 和 文件夹集合

        ArrayList<File> mOperationFileList;   //  需要操作文件的集合

        ReplaceTxtFile_Src_to_Dst_Rule_66() {
            super("#", 66, 4); //
            mSrc_Dst_StrMap = new HashMap<String,String>();
            mSrcList = new ArrayList<String>() ;
            inputFileList = new  ArrayList<File>();
            mOperationFileList = new  ArrayList<File>();
            isSearAllLocalFile = false;
        }



        @Override
        String simpleDesc() {
            if(CUR_OS_TYPE == OS_TYPE.Windows) {

                return
                        Cur_Bat_Name + " #_" + rule_index + "  [][]     ##  无文件参数 那么默认读取本地路径下文件 【American 替换为 美国的操作】 文本替换 每行 [src][dst] [American][美国]    \n"
                                +   Cur_Bat_Name + " #_" + rule_index + "  [][]  [American][美国]   ## 读取当前指定输入文件的命令 或者当前 所有文件 进行文字上 【American 替换为 美国的操作】 文本替换 每行 [src][dst] [American][美国]    \n"
                                +   Cur_Bat_Name + " #_" + rule_index + "  [**zukgit**][*Big*]  [American][美国]   ## *代表一个空格  @_@代表空''  z_z代表等号=  读取当前指定输入文件的命令 或者当前 所有文件 进行文字上 【American 替换为 美国的操作】 文本替换 每行 [src][dst] [American][美国]    \n"
                                + Cur_Bat_Name + " #_" + rule_index + " all_file  [][]  [American][美国]     ### *代表一个空格  @_@代表空''  z_z代表等号=  ~_~代表双引号  解析当前目录下所有文件 包含孙文件 进行文件内容的替换    \n"

                                + Cur_Bat_Name + " #_" + rule_index + " A.txt B.txt  [][]  [American][美国]     ### 解析当前目录下所有的 A.txt B.txt  尝试按照文本替换 每行 [src][dst] 替换   \n"
                        ;


            }

            return
                    Cur_Bat_Name + " #_" + rule_index + "  '[][]'     ##  无文件参数 那么默认读取本地路径下文件 【American 替换为 美国的操作】 文本替换 每行 [src][dst] [American][美国]    \n"
                            +   Cur_Bat_Name + " #_" + rule_index + "  '[][]'  [American][美国]   ## 读取当前指定输入文件的命令 或者当前 所有文件 进行文字上 【American 替换为 美国的操作】 文本替换 每行 [src][dst] [American][美国]    \n"
                            +   Cur_Bat_Name + " #_" + rule_index + "  '[**zukgit**][*Big*]'  '[American][美国]'   ## *代表一个空格  @_@代表空''  z_z代表等号= ~_~代表双引号 读取当前指定输入文件的命令 或者当前 所有文件 进行文字上 【American 替换为 美国的操作】 文本替换 每行 [src][dst] [American][美国]    \n"
                            + Cur_Bat_Name + " #_" + rule_index + " all_file  '[][]'  '[American][美国]'     ### 解析当前目录下所有文件 包含孙文件 进行文件内容的替换     \n"

                            + Cur_Bat_Name + " #_" + rule_index + " A.txt B.txt  '[][]'  '[American][美国]'     ### 解析当前目录下所有的 A.txt B.txt  尝试按照文本替换 每行 [src][dst] 替换    \n"
                    ;
        }



        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {
                String strInput = inputParamList.get(i);

                File tempFile_relative = new File(curDirPath + File.separator + strInput);   // 相对路径
                File  tempFile_abs = new File(strInput);   // 相对路径
                if (tempFile_relative.exists() && !tempFile_relative.isDirectory()) {
                    inputFileList.add(tempFile_relative);
                } else if(tempFile_relative.exists() && tempFile_relative.isDirectory()){

                    if(tempFile_relative.listFiles() != null && tempFile_relative.listFiles().length > 0 ){
                        inputFileList.addAll(Arrays.asList(tempFile_relative.listFiles()));
                    }
                } else  if (tempFile_abs.exists() && !tempFile_abs.isDirectory()) {
                    inputFileList.add(tempFile_abs);
                } else if(tempFile_abs.exists() && tempFile_abs.isDirectory()){

                    if(tempFile_abs.listFiles() != null && tempFile_abs.listFiles().length > 0 ){
                        inputFileList.addAll(Arrays.asList(tempFile_abs.listFiles()));
                    }
                }


                String oneLine = inputParamList.get(i).trim();


                if("all_file".equals(oneLine.trim())) {

                    isSearAllLocalFile = true;
                }

                if(oneLine.startsWith("[") && oneLine.endsWith("]") && oneLine.contains("][")){

                    String clear_pre_end_str = oneLine.substring(1,oneLine.length()-1);

                    String[] splitArr = clear_pre_end_str.split("\\]\\[");
                    if(splitArr == null || splitArr.length != 2){
                        System.out.println("当前行["+(i+1)+"]输入参数内容: "+ oneLine+"  无法解析为  【原始字符串】_【替换字符串】 跳过该行  请注意!");
                        continue;
                    }

                    String srcStr = splitArr[0].trim();

                    String dstStr = splitArr[1].trim();

                    System.out.println("param["+i+"_"+""+inputParamList.size()+"] ____ value["+oneLine+"]"+ "srcStr["+srcStr+"]  dstStr["+dstStr+"]   ["+srcStr+"]["+dstStr+"]");
// *  代表空格
// z_z 代表 等号
// @_@  代表空
                    if(srcStr.contains("*")){ // *  代表空格
                        srcStr =   srcStr.replaceAll("\\*"," ");
                    }

                    if(dstStr.contains("*")){
                        dstStr =   dstStr.replaceAll("\\*"," ");
                    }

                    if(srcStr.contains("z_z")){// z_z 代表 等号
                        srcStr =   srcStr.replaceAll("z_z","=");
                    }

                    if(dstStr.contains("z_z")){
                        dstStr =   dstStr.replaceAll("z_z","=");
                    }

                    if(srcStr.contains("@_@")){// @_@  代表空
                        srcStr =   srcStr.replaceAll("@_@","");
                    }

                    if(dstStr.contains("@_@")){
                        dstStr =   dstStr.replaceAll("@_@","");
                    }

                    if(srcStr.contains("~_~")){// ~_~  代表空
                        srcStr =   srcStr.replaceAll("~_~","\"");
                    }

                    if(dstStr.contains("~_~")){
                        dstStr =   dstStr.replaceAll("~_~","\"");
                    }


                    //  如果 当前  src[] dst[]  那么 忽略 这样的文本替换  [][]   [][]   [][]   [][]   [][]
                    if("".equals(srcStr) && "".equals(dstStr)){
                        System.out.println("当前输入参数 ["+i+"_"+inputParamList.size()+"] [src][dst]!!   ["+srcStr+"]["+dstStr+"] 可能都为空 无法作为 [][] 文本替换源");

                        continue;
                    }







                    mSrcList.add(srcStr);
                    mSrc_Dst_StrMap.put(srcStr,dstStr);

                }

            }

            if(inputFileList.size() > 0 ){

                for (int i = 0; i < inputFileList.size(); i++) {
                    if(inputFileList.get(i).isFile()){
                        mOperationFileList.add(inputFileList.get(i));
                    }
                }
            }

            if (mOperationFileList.size() == 0 && mSrc_Dst_StrMap.size() == 0 ) {
                System.out.println("当前没有输入任何文件 文件夹  以及 输入文本替换为 空  [][]  请检查输入! ");
                return  false;
            }

            if(mOperationFileList.size() == 0 && mSrc_Dst_StrMap.size() > 0){

                File tempFile_relative = new File(curDirPath );   // 相对路径
                File[] localFileArr  = tempFile_relative.listFiles() ;
                if(localFileArr != null && localFileArr.length > 0 ){
                    isSearAllLocalFile = true;
                    for (File fileItem: localFileArr) {
                        if(fileItem.isFile()){
                            mOperationFileList.add(fileItem);
                        }
                    }
                }

            }

            if(isSearAllLocalFile) {
                mOperationFileList = getAllSubFile(curDirFile);
            }else {

                if(mOperationFileList.size() == 0 && mSrc_Dst_StrMap.size() > 0 ){
                    System.out.println("当前没有输入任何文件  本地文件夹也没有可操作文件  "+buildReplaceTip(mSrcList,mSrc_Dst_StrMap)+"   文本替换工作! ");
                    return  false;
                }


            }



            for (int i = 0; i < mOperationFileList.size(); i++) {
                File fileItem = mOperationFileList.get(i);
                System.out.println(" File["+i+"_"+""+mOperationFileList.size()+"]____"+fileItem.getAbsolutePath());
            }

            if(mSrc_Dst_StrMap.size() == 0){
                System.out.println("当前没有输入替换规则   [][]  请检查输入! ");

                return  false;
            }
            System.out.println("开始执行替换规则: "+ buildReplaceTip(mSrcList,mSrc_Dst_StrMap));

            return super.initParamsWithInputList(inputParamList);
        }


        String buildReplaceTip(ArrayList<String> srcList , HashMap<String,String> src_dst_map  ){
            StringBuilder  tipSB = new StringBuilder();

            for (int i = 0; i < srcList.size(); i++) {
                String src_item = srcList.get(i);
                String dst_item = src_dst_map.get(src_item);
                tipSB.append(" ["+src_item+"]["+dst_item+"]" );
            }

            return tipSB.toString();

        }



        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList, HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList, ArrayList<File> curRealFileList) {


            System.out.println("begin applySubFileListRule4 _____");

            int avaliable_product_txt_count = 0 ;
            ArrayList<String> failed_htmlparse_tiplist = new  ArrayList<String>();


            for (int i = 0; i < mOperationFileList.size() ; i++) {

                boolean isContainFlag = false;
                File operationFile = mOperationFileList.get(i);

                System.out.println("╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤ InputFile["+i+"_"+mOperationFileList.size()+"]_"+operationFile.getName()+"_"+"begin ╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤");


                ArrayList<String> rawFileContentList = ReadFileContentAsList(operationFile);


                ArrayList<String> newFileContentList = new   ArrayList<String>();

                for (int k = 0; k < rawFileContentList.size(); k++) {
                    String oneLine = rawFileContentList.get(k);
                    String  mNextStr = oneLine;

                    for (int m = 0; m < mSrcList.size(); m++) {
                        String  mMatchStrItem =     mSrcList.get(m);
                        if(mNextStr.contains(mMatchStrItem)){
                            mNextStr = mNextStr.replaceAll(mMatchStrItem,mSrc_Dst_StrMap.get(mMatchStrItem));
                            isContainFlag = true;
                            System.out.println("Raw_Line_"+k+":"+oneLine);
                            System.out.println("New_Line_"+k+":"+mNextStr);
                            System.out.println();
                        }

                    }
                    newFileContentList.add(mNextStr);

                }

                if(isContainFlag){
                    writeContentToFile(operationFile,newFileContentList);
                    System.out.println("OperationFile["+i+"_"+mOperationFileList.size()+"]_"+operationFile.getName()+""+" " + buildReplaceTip(mSrcList,mSrc_Dst_StrMap));

                }

                System.out.println();
                System.out.println();
                System.out.println();

            }


            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }




    }


    //对于 ZHide 文件夹内的所有文件 进行 md5_type 变为(unknow文件类型) 操作  md5.type 操作 (变为 type类型)
    class ZHide_MD5Type_Operation_Rule_65 extends Basic_Rule {

        // 0 -----  默认 不操作
        // 1 ---- dohide_md5name   对所有文件进行 md5_type 操作 转为 unknow类型
        // 2 ---- retype_md5name   对所有文件 md5_type 操作 转为 md5.type类型 type类型
        // 3 ---- dohide_timename  时间 hide
        // 4 ---- retype_timename  retype hide

        int mOperationType = 0 ;


        ZHide_MD5Type_Operation_Rule_65() {
            super("#", 65, 5);
            mOperationType = 0 ;
        }

        @Override
        ArrayList<File> applyDir_SubFileListRule5(ArrayList<File> allSubDirFileList,
                                                  ArrayList<File> allSubRealFileList) {


            for (int i = 0; i < allSubRealFileList.size(); i++) {
                File inputRealFile = allSubRealFileList.get(i);
                String parentPath = inputRealFile.getParent();


                System.out.println("mRealFile["+i+"_"+allSubRealFileList.size()+"] = "+ inputRealFile.getName()+"  : "+ inputRealFile.getAbsolutePath() );

                if(mOperationType == 1) {  // dohide_md5name

                    String fileType_name =	getFileTypeNoPoint(inputRealFile.getName());
                    String origin_file_nmae = inputRealFile.getName();

                    String md5name =  getMD5Three(inputRealFile.getAbsolutePath());

                    System.out.println("dohide_md5name_rule1_1 mRealFile["+i+"_"+allSubRealFileList.size()+"]  " );

                    String newName = md5name+"_"+fileType_name;


                    if( "".equals(fileType_name)){   // 已经是  unknow 文件类型的  那么 不操作 这个文件了
                        System.out.println("dohide_md5name_rule1_2 mRealFile["+i+"_"+allSubRealFileList.size()+"]  File is an Unknow Hide Hide !" );
                        continue;
                    }

                    // 当前文件 已经是 hide 过的文件了
                    if(origin_file_nmae.startsWith(md5name+"_") && "".equals(fileType_name)){
                        System.out.println("dohide_md5name_rule1_3 mRealFile["+i+"_"+allSubRealFileList.size()+"]  File is Already Hide !" );
                        continue;

                    }


                    if(new File(parentPath+File.separator+newName).exists()) { //  第二个重复的 文件 那么 重新改名

                        newName = md5name+"_"+getTimeStamp_yyyyMMddHHmmss()+"_"+fileType_name;
                    }

                    if(!new File(parentPath+File.separator+newName).exists()){
                        tryReName(inputRealFile,newName);
                        System.out.println("dohide_md5name_rule1_4 mRealFile["+i+"_"+allSubRealFileList.size()+"]  newName="+ newName );
                    } else {
                        System.out.println("dohide_md5name_rule1_5 mRealFile["+i+"_"+allSubRealFileList.size()+"]  newName="+ newName  +" Already Exist!" );
                    }





                } else if(mOperationType == 2) {  // retype_md5name

                    String origin_file_type =	getFileTypeNoPoint(inputRealFile.getName());
                    String origin_file_name = inputRealFile.getName();
                    String realFileName = inputRealFile.getName(); //  fjoafjoa_mp4
                    String md5name =  getMD5Three(inputRealFile.getAbsolutePath());




                    // 当前文件 已经是 ReType 过的文件了
                    if(origin_file_name.startsWith(md5name) && !"".equals(origin_file_type)){
                        System.out.println("retype_md5name_rule2_1  mRealFile["+i+"_"+allSubRealFileList.size()+"]  File is Already ReType File !" );
                        continue;

                    }



                    String   retype_new_name = realFileName;

                    if(realFileName.startsWith(md5name+"_") && "".equals(origin_file_type) ){   // 符合规则的文件  进行处理

                        retype_new_name = realFileName.replaceAll("_",".");


                        if(new File(parentPath+File.separator+retype_new_name).exists()) { //  第二个重复的 文件 那么 重新改名

                            retype_new_name = retype_new_name.replace(md5name,md5name+"_"+getTimeStamp_yyyyMMddHHmmss());
                            System.out.println("retype_md5name_rule2_2 mRealFile["+i+"_"+allSubRealFileList.size()+"]  newName="+ retype_new_name );
                        }

                        // 从 adafagfea_txt   转为 adafagfea.txt
//    File filetype_name = new File(inputDirFile.getAbsolutePath() + File.separator + fileType_name);

                        tryReName(inputRealFile,retype_new_name);

                        System.out.println("retype_md5name_rule2_3  mRealFile["+i+"_"+allSubRealFileList.size()+"]  newName="+ retype_new_name );


                    } else{    // 不符合规则的文件   不主动操作
                        System.out.println("retype_md5name_rule2_4 mRealFile["+i+"_"+allSubRealFileList.size()+"]  newName="+ retype_new_name +" Do not Apply ReType Rule! ");
                    }


                } else if(mOperationType == 3) {  // dohide_timename

                    String fileType_name =	getFileTypeNoPoint(inputRealFile.getName());
                    String origin_file_name = inputRealFile.getName();

                    String timeStampName  = getTimeStamp_yyyyMMddHHmmss()+"-"+ i+"-"+allSubRealFileList.size();

                    System.out.println("dohide_tinemname_rule3_1 mRealFile["+i+"_"+allSubRealFileList.size()+"]  " );

                    String newName = timeStampName+"_"+fileType_name;


                    if( "".equals(fileType_name)){   // 已经是  unknow 文件类型的  那么 不操作 这个文件了
                        System.out.println("dohide_tinemname_rule3_2 mRealFile["+i+"_"+allSubRealFileList.size()+"]  File is an Unknow Hide Hide !" );
                        continue;
                    }

                    // 当前文件 已经是 hide 过的文件了
                    if( "".equals(fileType_name)){
                        System.out.println("dohide_tinemname_rule3_3 mRealFile["+i+"_"+allSubRealFileList.size()+"]  File is Already Hide !" );
                        continue;

                    }


                    if(!new File(parentPath+File.separator+newName).exists()){
                        tryReName(inputRealFile,newName);
                        System.out.println("dohide_tinemname_rule3_4 mRealFile["+i+"_"+allSubRealFileList.size()+"]  newName="+ newName );
                    } else {
                        System.out.println("dohide_tinemname_rule3_5 mRealFile["+i+"_"+allSubRealFileList.size()+"]  newName="+ newName  +" Already Exist!" );
                    }





                } else if(mOperationType == 4) {  // retype_timename

                    String origin_file_type =	getFileTypeNoPoint(inputRealFile.getName());

                    String realFileName = inputRealFile.getName(); //  fjoafjoa_mp4





                    // 当前文件 已经是 ReType 过的文件了
                    if( !"".equals(origin_file_type)){
                        System.out.println("retype_timename_rule4_1  mRealFile["+i+"_"+allSubRealFileList.size()+"]  File is Already ReType File !" );
                        continue;

                    }



                    String   retype_new_name = realFileName;

                    if(realFileName.contains("_") && "".equals(origin_file_type) ){   // 符合规则的文件  进行处理

                        retype_new_name = realFileName.replaceAll("_",".");

                        tryReName(inputRealFile,retype_new_name);

                        System.out.println("retype_timename_rule4_2 mRealFile["+i+"_"+allSubRealFileList.size()+"]  newName="+ retype_new_name );


                    } else{    // 不符合规则的文件   不主动操作
                        System.out.println("retype_timename_rule4_3 mRealFile["+i+"_"+allSubRealFileList.size()+"]  newName="+ retype_new_name +" Do not Apply ReType Rule! ");
                    }


                }

            }



            return super.applyDir_SubFileListRule5(allSubDirFileList, allSubRealFileList);
        }



        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {
                String strInput = inputParamList.get(i);

                if(strInput.equals("dohide_md5name")){
                    mOperationType = 1 ;
                } else if(strInput.equals("retype_md5name")){
                    mOperationType = 2 ;
                }else if(strInput.equals("dohide_timename")){
                    mOperationType = 3 ;
                }else if(strInput.equals("retype_timename")){
                    mOperationType = 4 ;
                }

            }


            System.out.println("mOperationType = "+mOperationType+" CurPath:"+curDirPath);
            if(mOperationType == 1){
                System.out.println("当前  mOperationType["+mOperationType+"]  dohide 执行的逻辑:  对所有文件进行 md5_type 操作 转为 unknow类型 !");
            } else  if(mOperationType == 2){
                System.out.println("当前  mOperationType["+mOperationType+"]  retype 执行的逻辑:  对所有文件 md5_type 操作 还原转为 md5.type类型 type类型 !");
            } else  if(mOperationType == 3){
                System.out.println("当前  mOperationType["+mOperationType+"]  dohide 执行的逻辑:  对所有文件进行 timename_type 操作 转为 unknow类型 !");
            } else  if(mOperationType == 4){
                System.out.println("当前  mOperationType["+mOperationType+"]  retype 执行的逻辑:  对所有文件 timename_type 操作 还原转为 timename.type类型 type类型 !");
            }else {
                System.out.println("当前  mOperationType["+mOperationType+"]   非执行逻辑(避免大规模把 好的文件 震坏! )");
            }

            if(!curDirPath.toLowerCase().contains("zhide")) {
                System.out.println("当前 路径不是在 ZHide 文件，无法执行 dohide 隐藏类型 以及 retype 还原类型的操作");

                return false ;

            }

            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_" + rule_index
                    + "   ### 对当前  ZHide 文件夹  进行  HideType 隐藏类型 以及  ReType 还原类型 操作 \n"
                    + Cur_Bat_Name + " #_" + rule_index
                    + "    ###  ZHide 文件夹  进行  HideType 隐藏类型 以及  ReType 还原类型 操作   \n"
                    + Cur_Bat_Name + " #_" + rule_index +" dohide_md5name"
                    + "    ### 对当前ZHide 文件夹    依据  md5_type  组成新的 文件名称 (unknow)文件类型   \n"
                    + Cur_Bat_Name + " #_" + rule_index +" retype_md5name"
                    + "    ### 对当前ZHide 文件夹 符合  md5_type 类型的 unknow文件 还原为 md5.type  的 type 类型文件    \n"
                    + Cur_Bat_Name + " #_" + rule_index +" dohide_timename"
                    + "    ### 对当前ZHide 文件夹    依据  timestamp_type  组成新的 文件名称 (unknow)文件类型   \n"
                    + Cur_Bat_Name + " #_" + rule_index +" retype_timename"
                    + "    ### 对当前ZHide 文件夹 符合  timestamp_type 类型的 unknow文件 还原为 timestamp.type  的 type 类型文件    \n"
                    ;
        }


    }




    class Make_Md5Type_Hide_File_Back_To_FileType_Rule64 extends Basic_Rule {
        boolean isDirOperation; // 是否没有输入 real 文件 而是 输入了一个 目录 默认shell 目录 已经 输入的目录

        File inputDirFile;
        ArrayList<File> inputDirFileList;

        // 0 ---- hidejpg 文件夹的操作 默认 md5_type 还原操作
        // 1 ---- lin  文件夹下的文件名称重命名还原操作
        int mRenameType = 0 ;

        Make_Md5Type_Hide_File_Back_To_FileType_Rule64() {
            super("#", 64, 3); //
            inputDirFileList = new ArrayList<File>();
            inputDirFile = null;
            isDirOperation = false;
            mRenameType = 0;
        }

        @Override
        boolean allowEmptyDirFileList() {
            // TODO Auto-generated method stub
            return true;
        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {
            // TODO Auto-generated method stub


            int rename_file_count = 0 ;

            if(mRenameType == 0){
                for (int i = 0; i < inputDirFileList.size(); i++) {
                    File inputRealFile = inputDirFileList.get(i);
                    String realFileName = inputRealFile.getName();
                    String md5name =  getMD5Three(inputRealFile.getAbsolutePath());

                    String fileType_name = realFileName;
                    if(realFileName.startsWith(md5name+"_")){   // 符合规则的文件  进行处理

                        fileType_name = fileType_name.replace("_",".");

                        // 从 adafagfea_txt   转为 adafagfea.txt
//                    File filetype_name = new File(inputDirFile.getAbsolutePath() + File.separator + fileType_name);

                        tryReName(inputRealFile,fileType_name);
                        rename_file_count++;


                    } else{    // 不符合规则的文件   不主动操作

                    }



                }
                System.out.println("当前源文件总数["+inputDirFileList.size()+"] 更新文件总数["+rename_file_count+"]  不符合md5_type规则文件数["+(inputDirFileList.size() - rename_file_count)+"]");



            } else if (mRenameType == 1){

                ArrayList<File>  unKnowFileList =      fileTypeMap.get("unknow");

                if(unKnowFileList == null){

                    System.out.println("当前 目录【"+curDirFile.getAbsolutePath()+"】没有找到 无类型 unknown 的文件!");
                    return  null;
                }
                System.out.println("当前存在 unknow 文件 总共 【"+unKnowFileList.size()+"】个");
                int renameCount = 0 ;
                for (int i = 0; i < unKnowFileList.size(); i++) {

                    File unknowFile =    unKnowFileList.get(i);

                    System.out.println("unknowFile["+i+"_"+unKnowFileList.size()+"] : "+ unknowFile.getAbsolutePath());

                    String realFileName = unknowFile.getName();
//                    String md5name =  getMD5Three(unknowFile.getAbsolutePath());
                    String newName =  realFileName;

                    if(unknowFile.getAbsolutePath().contains("jpg_lin")){
                        newName = realFileName+"."+"jpg";
                        tryReName(unknowFile,newName);
                        renameCount++;
                    } else if(unknowFile.getAbsolutePath().contains("mp4_lin")){
                        newName = realFileName+"."+"mp4";
                        tryReName(unknowFile,newName);
                        renameCount++;
                    } else if(unknowFile.getAbsolutePath().contains("gif_lin")){
                        newName = realFileName+"."+"gif";
                        tryReName(unknowFile,newName);
                        renameCount++;
                    }

                }
                System.out.println("当前存在 rename_lin 操作  unknow 文件 总共 【"+unKnowFileList.size()+"】个  改名成功【"+renameCount+"】个! ");

            }

            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_" + rule_index
                    + "   ### 对当前  依据  md5_type  组成的规则的文件  还原为  md5.type 这样的 文件   \n"
                    + Cur_Bat_Name + " #_" + rule_index
                    + "    ### ( /sdcard/1/jpg_hide 操作 ) 对当前  依据  md5_type  组成的规则的文件  还原为  md5.type 这样的 文件    \n"
                    + Cur_Bat_Name + " #_" + rule_index +" rename_jpghide"
                    + "    ### ( /sdcard/1/jpg_hide 操作 ) 对当前  依据  md5_type  组成的规则的文件  还原为  md5.type 这样的 文件    \n"
                    + Cur_Bat_Name + " #_" + rule_index +" rename_lin"
                    + "    ### ( /sdcard/1/lin 操作 ) 对当前  lin 目录下的 unknow文件依据 文件夹m名称(mp4 jpg) 进行还原为对应的type    \n"
                    ;
        }



        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {
                String strInput = inputParamList.get(i);

                if(strInput.equals("rename_jpghide")){
                    mRenameType = 0 ;
                } else if(strInput.equals("rename_lin")){
                    mRenameType = 1 ;
                }

                File tempFile = new File(curDirPath + File.separator + strInput);
                if (tempFile.exists() && !tempFile.isDirectory()) {
                    String inputFileName = tempFile.getName().toLowerCase();

                    inputDirFileList.add(tempFile);


                }

                File inputDir = new File(strInput);
                if (inputDir.exists() && inputDir.isDirectory()) {
                    isDirOperation = true;
                    inputDirFile = inputDir;
                }

                System.out.println("initParamsWithInputList[" + i + "_"+inputParamList.size()+"] = " + strInput + "  inputDir.exists()="
                        + inputDir.exists() + "  inputDir.isDirectory()=" + inputDir.isDirectory());

            }

            if(inputDirFile == null || !inputDirFile.exists()){

                inputDirFile = curDirFile;
            }

            System.out.println("输入文件夹转为当前 shell  路径  :  inputDirFile = "+ inputDirFile);
            if (inputDirFile != null) {
                File[] listArr = inputDirFile.listFiles();
                if (listArr == null || listArr.length == 0) {
                    System.out.println("当前 输入的目录  " + inputDirFile.getAbsolutePath() + "没有 任何文件操作!!");

                    return false;
                }
                for (int i = 0; i < listArr.length; i++) {
                    File fileItem = listArr[i];

                    String inputFileName = fileItem.getName().toLowerCase();
                    inputDirFileList.add(fileItem);

                    System.out.println(
                            "inputDir_xlsx[" + i + "] = " + fileItem.getAbsolutePath() + "  Size=" + fileItem.length());

                }

            }

            if (inputDirFileList.size() == 0) {
                System.out.println(
                        "当前 输入的目录  inputDirFile =" + (inputDirFile == null ? "null" : inputDirFile.getAbsolutePath())
                                + "没有 任何类型文件进行操作!!");

                return false;

            }
            if (inputDirFile == null) {
                System.out.println("ZXX inputDirFile = null " + " inputDirFileList.size()=" + inputDirFileList.size()
                        + "   isDirOperation=" + isDirOperation);

            } else {
                System.out.println("ZXX inputDirFile =" + inputDirFile.getAbsolutePath() + "    inputDirFileList.size()="
                        + inputDirFileList.size() + "   isDirOperation=" + isDirOperation);

            }

            System.out.println("mRenameType = "+mRenameType);
            if(mRenameType == 0){
                System.out.println("当前  Rename 执行的逻辑:  对 jpg_hide 文件夹下的 unknow 文件进行 还原文件type 的处理 !");
            } else  if(mRenameType == 1){
                System.out.println("当前  Rename 执行的逻辑: 对 lin 文件夹下的 unknow 文件 依据文件夹名称 类型(mp4 jpg gif)还原文件type 的处理 !");
            }
            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }

    }

    class Print_Dir_FileTree_Info_Rule63 extends Basic_Rule {


        public class DefaultFileNameFileter implements FilenameFilter
        {
            @Override
            public boolean accept(File dir, String name)
            {

                if(".git".equals(name) || name.startsWith(".")){
                    return false;
                }
                return true;
            }
        }

        String RootPath = null;

        DefaultFileNameFileter defaultFileNameFileter=null;
        NumberFormat onlyone_nf = new DecimalFormat("0");


        int sum_file_count = 0 ;
        int all_real_file_count = 0;
        int all_dir_file_count = 0 ;

        Print_Dir_FileTree_Info_Rule63() {
            super("#", 63, 4);

        }


        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            ArrayList<String> dirTreeInfoList = new ArrayList<String>();


            RootPath = curDirPath;

            defaultFileNameFileter= new DefaultFileNameFileter();

            File dir = new File(RootPath);

            System.out.println();
            System.out.println();
            System.out.println();
            System.out.println();
            System.out.println();
            System.out.println();


            System.out.println("user.dir = "+ dir.getAbsolutePath());
            printTreeFileAndDir(dir, defaultFileNameFileter,dirTreeInfoList);

            dirTreeInfoList.add(0,"```\n["+sum_file_count+"_"+all_dir_file_count+"_"+all_real_file_count+"]_"+(new File(curDirPath)).getName());
            dirTreeInfoList.add("");
            dirTreeInfoList.add("```");

            for (int i = 0; i < dirTreeInfoList.size(); i++) {
                System.out.println(dirTreeInfoList.get(i));
            }

            writeContentToFile(G2_Temp_Text_File, dirTreeInfoList);
            NotePadOpenTargetFile(G2_Temp_Text_File.getAbsolutePath());
            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        public  void printTreeFileAndDir(File dir,FilenameFilter fileNameFilter, ArrayList<String> dirInfoList)
        {
            // 打印根目录
            System.out.println(dir.getAbsolutePath());
            printTreeFileAndDir(dir, fileNameFilter,dirInfoList ,"", 10);
        }


        private  void printTreeFileAndDir(File dir, FilenameFilter fileNameFilter, ArrayList<String> dirInfoList ,String prefix, int deep)
        {
            // 列出目录下的子目录
            File[] childs = dir.listFiles(fileNameFilter);
            if(childs == null){
                return;
            }

            ArrayList<File> all_real_file_list = new       ArrayList<File>();
            ArrayList<File> all_dir_file_list = new       ArrayList<File>();
            sum_file_count = sum_file_count + childs.length;
            for (int i = 0; i < childs.length; i++)
            {

                if (childs[i].isDirectory())
                {
                    all_dir_file_list.add(childs[i]);

                } else {
                    all_real_file_list.add(childs[i]);
                }

            }

            ArrayList<File>  all_sorted_file_arr  = new       ArrayList<File>();
            all_sorted_file_arr.addAll(all_real_file_list);
            all_sorted_file_arr.addAll(all_dir_file_list);


            all_real_file_count = all_real_file_count + all_real_file_list.size();

            all_dir_file_count = all_dir_file_count + all_dir_file_list.size();

            //  实体的 文件夹 靠近 前面   ， 目录 靠近 后面
            // 遍历子目录
            int real_file_index = 0 ;
            int dir_file_index = 0 ;
            for (int i = 0; i < all_sorted_file_arr.size(); i++)
            {
                // 本次递归的前缀
                String thisPrefix = "";
                // 下一个递归的前缀
                String nextPrefix = "";
                if (deep >= 0)
                {
                    // 如果不是最后一个元素
                    if ((i + 1 < all_sorted_file_arr.size()))
                    {
                        nextPrefix = prefix + "│ ";
                        thisPrefix = prefix + "├─";
                    } else
                    {
                        nextPrefix = prefix + "  ";
                        thisPrefix = prefix + "└─";
                    }
                }

                if (all_sorted_file_arr.get(i).isDirectory())
                {

                    dir_file_index++;
//                System.out.println(thisPrefix + all_sorted_file_arr.get(i).getName()+" ["+all_sorted_file_arr.get(i).getAbsolutePath()+"]");  // 文件夹  打印 全路径

//                System.out.println(thisPrefix + all_sorted_file_arr.get(i).getName()+" ["+all_sorted_file_arr.get(i).getAbsolutePath()+"]");  // 文件夹  打印 全路径
                    int childFileArr_size = 0 ;
                    if(all_sorted_file_arr.get(i).listFiles(fileNameFilter) != null){
                        childFileArr_size = all_sorted_file_arr.get(i).listFiles(fileNameFilter).length;
                    }


                    System.out.println(thisPrefix +"["+all_sorted_file_arr.size()+"_"+all_dir_file_list.size()+"_"+all_real_file_list.size()+"]["+all_dir_file_list.size()+"_"+(dir_file_index)+"]_["+childFileArr_size+"]  " + all_sorted_file_arr.get(i).getName()+" -> "+all_sorted_file_arr.get(i).getAbsolutePath().replace(RootPath,"")+"");
                    dirInfoList.add(thisPrefix +"["+all_sorted_file_arr.size()+"_"+all_dir_file_list.size()+"_"+all_real_file_list.size()+"]["+all_dir_file_list.size()+"_"+(dir_file_index)+"]_["+childFileArr_size+"]  " + all_sorted_file_arr.get(i).getName()+" -> "+all_sorted_file_arr.get(i).getAbsolutePath().replace(RootPath,"")+"");

                } else {
                    real_file_index++;

                    long file_size = all_sorted_file_arr.get(i).length();
                    String file_size_MB_str = ""+ onlyone_nf.format(file_size / (1024d * 1024  )) + "-MB";

//                System.out.println(thisPrefix + all_sorted_file_arr.get(i).getName()+"["+all_real_file_list.size()+"_"+(i+1)+"]");

                    System.out.println(thisPrefix +"["+all_sorted_file_arr.size()+"_"+all_dir_file_list.size()+"_"+(all_real_file_list.size())+"]["+all_real_file_list.size()+"_"+(real_file_index)+"]_"+file_size_MB_str+"==="+ all_sorted_file_arr.get(i).getName());
                    dirInfoList.add(thisPrefix +"["+all_sorted_file_arr.size()+"_"+all_dir_file_list.size()+"_"+(all_real_file_list.size())+"]["+all_real_file_list.size()+"_"+(real_file_index)+"]_"+file_size_MB_str+"==="+ all_sorted_file_arr.get(i).getName());


                }




                if (all_sorted_file_arr.get(i).isDirectory())
                {
                    printTreeFileAndDir(all_sorted_file_arr.get(i), fileNameFilter, dirInfoList , nextPrefix, deep + 1);
                }
            }
        }


        @Override
        String simpleDesc() {
            return "  \n"
                    + Cur_Bat_Name  + " #_"+rule_index+"  ## 执行类似 tree 的相关程序 在"+G2_Temp_Text_File.getName()+"打印出所有文件列表 [文件总数_文件夹数_实体文件数][文件夹数_文件夹索引]_[文件夹下文件总数] \n"
                    + Cur_Bat_Name  + " #_"+rule_index+"  ## 执行类似 tree 的相关程序 在"+G2_Temp_Text_File.getName()+"打印出所有文件列表 [文件总数_文件夹数_实体文件数][实体文件数_文件索引]_文件大小MB \n"

                    ;
        }

        @Override
        boolean allowEmptyDirFileList() {
            return true;
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            return super.initParamsWithInputList(inputParamList);
        }

    }


    class Wifi_Wireshark_Fliter_Calcul_Rule62 extends Basic_Rule {


        ArrayList<String> bssidList ;
        ArrayList<String> macList ;

        ArrayList<Bssid_Mac_Item>  mFliterItemList ;
        Wifi_Wireshark_Fliter_Calcul_Rule62() {
            super("#", 62, 4);
            bssidList =    new   ArrayList<String>();
            macList =    new   ArrayList<String>();
            mFliterItemList = new   ArrayList<Bssid_Mac_Item>();
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {
                String strInput = inputParamList.get(i);

                if(strInput.startsWith("bssid_")){
                    String bssid_item = strInput.replace("bssid_","");

                    if(isMacAddress(bssid_item) && !bssidList.contains(bssid_item)){
                        bssidList.add(bssid_item);
                    }



                } else if(strInput.startsWith("mac_")){
                    String mac_item = strInput.replace("mac_","");

                    if(isMacAddress(mac_item) && !macList.contains(mac_item)){
                        macList.add(mac_item);
                    }
                }


            }

            System.out.println(" 当前输入的 bssid 个数: "+ bssidList.size() );
            System.out.println(" 当前输入的 设备Mac地址 个数: "+ macList.size() );

            if(bssidList.size() == 0 || macList.size() == 0){
                System.out.println("当前 输入的 bssid  或者  mac地址 数量为0   无法生成正常的 Wireshark 过滤条件! ");
                return false;

            }

            int all_fliter_count = bssidList.size() * macList.size();

            for (int i = 0; i < bssidList.size() ; i++) {
                String bssid_item = bssidList.get(i);

                for (int j = 0; j < macList.size(); j++) {

                    String mac_item = macList.get(j);

                    int index = i* macList.size() + j ;

                    Bssid_Mac_Item  fliterItem = new Bssid_Mac_Item(index,all_fliter_count,bssid_item,mac_item);

                    mFliterItemList.add(fliterItem);

                }

            }
            System.out.println("生成需要输出的过滤条件的 组合数量为  mFliterItemList.size()="+mFliterItemList.size());
            if(mFliterItemList.size() == 0){
                System.out.println("没有生成 过滤条件 需要的  Bssid 和 Mac 地址的 匹配的 数据项  请检查! ");
                return false;
            }

            return super.initParamsWithInputList(inputParamList);
        }


        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            ArrayList<String> fliterInfoList = new      ArrayList<String>();
            for (int i = 0; i < mFliterItemList.size(); i++) {
                Bssid_Mac_Item fliterItem = mFliterItemList.get(i);


                String  headTip = "组合["+i+"_"+mFliterItemList.size()+"]: "+ getPaddingIntString(fliterItem.index, 2, "0", true)+": bssid_"+fliterItem.bssid.toUpperCase()+"    mac_"+fliterItem.mac.toUpperCase();

                fliterInfoList.add(headTip);

            }
            fliterInfoList.add("");
            fliterInfoList.add("");
            for (int i = 0; i < mFliterItemList.size(); i++) {
                Bssid_Mac_Item fliterItem = mFliterItemList.get(i);
                String  fliter_title = "════组合["+i+"_"+mFliterItemList.size()+"]: "+ getPaddingIntString(fliterItem.index, 2, "0", true)+": bssid_"+fliterItem.bssid.toUpperCase()+"    mac_"+fliterItem.mac.toUpperCase();
                fliterInfoList.add(fliter_title);
                ArrayList<String> fliterInfo = fliterItem.calWireSharkFliter();
                fliterInfoList.addAll(fliterInfo);
                fliterInfoList.add("");
                fliterInfoList.add("");

            }

            writeContentToFile(G2_Temp_Text_File, fliterInfoList);
            NotePadOpenTargetFile(G2_Temp_Text_File.getAbsolutePath());
            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }




        class Bssid_Mac_Item {
            String bssid;
            String mac;

            int index ;

            int allFliterCount ;

            int mRuleIndex;
            Bssid_Mac_Item(int mIndex , int count ,  String mBssid  , String mMac  ){
                index = mIndex;
                bssid =  mBssid.toUpperCase();
                mac = mMac.toUpperCase();
                allFliterCount = count;
                mRuleIndex = 1;
            }


            String getRuleIndexTip(){
                return "____["+index+"_"+allFliterCount+"]Rule"+(mRuleIndex++)+":";

            }

            ArrayList<String> calWireSharkFliter(){
                ArrayList<String> wireshard_fliterlist = new       ArrayList<String>();

                // bssid_1c:5f:2b:5e:d5:53  mac_a4:50:46:44:c9:77
//                (wlan.sa == 1c:5f:2b:5e:d5:53 ||  wlan.da == 1c:5f:2b:5e:d5:53 )
                wireshard_fliterlist.add("______________ 常用过滤条件 ______________");
                wireshard_fliterlist.add("802.11X eap 认证中 区分出 eap 认证中的 第 1|2|3|4 次握手包 可以用于区分  DUT  和 热点 ");
                wireshard_fliterlist.add("wlan_rsna_eapol.keydes.key_info.secure == 0 && wlan_rsna_eapol.keydes.key_info.key_ack == 1  ## DUT -> BSS (eap1)");
                wireshard_fliterlist.add("wlan_rsna_eapol.keydes.key_info.secure == 0 && wlan_rsna_eapol.keydes.key_info.key_ack == 0  ## BSS -> DUT (eap2)");
                wireshard_fliterlist.add("wlan_rsna_eapol.keydes.key_info.secure == 1 && wlan_rsna_eapol.keydes.key_info.key_ack == 1  ## DUT -> BSS (eap3)");
                wireshard_fliterlist.add("wlan_rsna_eapol.keydes.key_info.secure == 1 && wlan_rsna_eapol.keydes.key_info.key_ack == 0  ## BSS -> DUT (eap4)");
                wireshard_fliterlist.add("");
                wireshard_fliterlist.add("");

                wireshard_fliterlist.add("");
                wireshard_fliterlist.add("");
                wireshard_fliterlist.add("wlan.fc.type_subtype == 0x0000            ## Type/Subtype: Association Request (0x0000)");
                wireshard_fliterlist.add("wlan.fc.type_subtype == 0x0001            ## Type/Subtype: Association Response (0x0001)");
                wireshard_fliterlist.add("wlan.fc.type_subtype == 0x0008            ## Type/Subtype: Beacon frame (0x0008)");
                wireshard_fliterlist.add("wlan.fc.type_subtype == 0x000b            ## Type/Subtype: Authentication (0x000b)");
                wireshard_fliterlist.add("wlan.fc.type_subtype == 0x000c            ## Type/Subtype: Deauthentication (0x000c)");
                wireshard_fliterlist.add("wlan.fc.type_subtype == 0x000d            ## Type/Subtype: Action (0x000d)");
                wireshard_fliterlist.add("wlan.fc.type_subtype == 0x000e            ## Type/Subtype: Action No Ack (0x000e) ACK帧");
                wireshard_fliterlist.add("wlan.fc.type_subtype == 0x001b            ## Type/Subtype: Request-to-send (0x001b)");
                wireshard_fliterlist.add("wlan.fc.type_subtype == 0x001c            ## Type/Subtype: Clear-to-send (0x001c)");
                wireshard_fliterlist.add("wlan.fc.type_subtype == 0x001d            ## Type/Subtype: Acknowledgement (0x001d)");
                wireshard_fliterlist.add("wlan.fc.type_subtype == 0x002c            ## Type/Subtype: QoS Null function (No data) (0x002c)");
                wireshard_fliterlist.add("wlan.fc.type_subtype == 0x0024            ## Type/Subtype: Null function (No data) (0x0024)");
                wireshard_fliterlist.add("wlan.fc.type_subtype == 0x0028            ## Qos_Data");
                wireshard_fliterlist.add("wlan.fc.type_subtype == 0x0028  && eap    ## Qos_Data &  EAPOL Key (Message 1 of 4) 帧");
                wireshard_fliterlist.add("");
                wireshard_fliterlist.add("## Action code: [wlan.fc.type_subtype == 0x000d]");
                wireshard_fliterlist.add("wlan.fixed.action_code == 0x00   ## Action code: Add Block Ack Request (0x00)");
                wireshard_fliterlist.add("wlan.fixed.action_code == 0x01   ## Action code: Add Block Ack Response (0x01)");
                wireshard_fliterlist.add("wlan.fixed.action_code == 0x02   ## Action code: Delete Block Ack (0x02) (当次DUT发送 Qos Data 传输完成标识)");
                wireshard_fliterlist.add("wlan.fixed.action_code == 5      ## Action code: Neighbor Report Response (5)");
                wireshard_fliterlist.add("");
                wireshard_fliterlist.add("wlan.fixed.baparams.policy == 1  ##  Block Ack Policy: Immediate Block Ack   immediate BA 立即应答：适用于高带宽，低时延业务；");
                wireshard_fliterlist.add("wlan.fixed.baparams.policy == 0  ##  Block Ack Policy: delayed Block Ack   delayed   BA 延迟应答：适用于时延可容忍业务。");
                wireshard_fliterlist.add("");


                wireshard_fliterlist.add("__________________________________");



                wireshard_fliterlist.add(getRuleIndexTip()+" 查询所有wifi eap 认证帧:");
                //  (wlan.sa == 1c:5f:2b:5e:d5:53 ||  wlan.da == 1c:5f:2b:5e:d5:53 ) && eapol
                wireshard_fliterlist.add("(wlan.sa == "+bssid+" ||  wlan.da == "+bssid+" ) && eapol");
                wireshard_fliterlist.add("");


                wireshard_fliterlist.add(getRuleIndexTip()+" 查询wifi 与 mac eap认证帧:");
                //  ((wlan.sa == 1c:5f:2b:5e:d5:53 &&  wlan.da == a4:50:46:44:c9:77 ) ||  (wlan.sa == a4:50:46:44:c9:77  &&  wlan.da ==  1c:5f:2b:5e:d5:53 )) && eapol
                wireshard_fliterlist.add("((wlan.sa == "+bssid+" &&  wlan.da == "+mac+" ) || (wlan.sa == "+mac+" &&  wlan.da == "+bssid+")) && eapol");
                wireshard_fliterlist.add("");


                wireshard_fliterlist.add(getRuleIndexTip()+" 查询wifi 与 mac  关联交互帧 认证 关联 断关联 断认证 eap:");
                //    ((wlan.sa == 1c:5f:2b:5e:d5:53 &&  wlan.da == a4:50:46:44:c9:77 ) ||  (wlan.sa == a4:50:46:44:c9:77  &&  wlan.da ==  1c:5f:2b:5e:d5:53 )) && (wlan.fc == 0xc000 || eapol ||  wlan.fc.subtype == 0x000B  ||  wlan.fc.subtype == 0x0000  ||	 wlan.fc.type_subtype == 0x0001 )
                wireshard_fliterlist.add("((wlan.sa == "+bssid+" &&  wlan.da == "+mac+" ) || (wlan.sa == "+mac+" &&  wlan.da == "+bssid+"))  && (wlan.fc == 0xc000 || eapol ||  wlan.fc.subtype == 0x000B  ||  wlan.fc.subtype == 0x0000  || wlan.fc.type_subtype == 0x0001 )");
                wireshard_fliterlist.add("");

                wireshard_fliterlist.add(getRuleIndexTip()+" Mac 和 Bssid 所有交互帧     da=ra   ta=sa  或者 da不存在 sa不存在 只包含 ta和ra");
                //  wlan.addr == 96:8d:a8:12:fc:ea && wlan.addr == D0:4D:C6:CB:55:25
                wireshard_fliterlist.add("( wlan.addr == "+bssid+" && wlan.addr == "+mac+" ) ");
                wireshard_fliterlist.add("");


                wireshard_fliterlist.add(getRuleIndexTip()+" Mac 和 Bssid 所有交互帧   ");
                //  wlan.addr == 96:8d:a8:12:fc:ea && wlan.addr == D0:4D:C6:CB:55:25
                wireshard_fliterlist.add("( wlan.addr == "+bssid+" && wlan.addr == "+mac+" )  && ( wlan.fixed.action_code == 0x00 || wlan.fixed.action_code == 0x01 || wlan.fc.type_subtype == 0x000e || wlan.fc == 0xc000 || eapol ||  wlan.fc.subtype == 0x000B  ||  wlan.fc.subtype == 0x0000  || wlan.fc.type_subtype == 0x0001 )");
                wireshard_fliterlist.add("");


                wireshard_fliterlist.add(getRuleIndexTip()+" Mac 和 Bssid 所有交互帧  da=ra 必须存在  ta=sa 必须存在  不包含广播  da  ");
                //  (wlan.sa == 1c:5f:2b:5e:d5:53 &&  wlan.da == a4:50:46:44:c9:77 ) ||  (wlan.sa == a4:50:46:44:c9:77  &&  wlan.da ==  1c:5f:2b:5e:d5:53 )
                wireshard_fliterlist.add("((wlan.sa == "+bssid+" &&  wlan.da == "+mac+" ) || (wlan.sa == "+mac+" &&  wlan.da == "+bssid+" )) ");
                wireshard_fliterlist.add("");


                wireshard_fliterlist.add(getRuleIndexTip()+" Mac 和 Bssid 所有交互帧   包含广播 da=ra 必须存在    ta=sa 必须存在");
                //  (wlan.sa == 1c:5f:2b:5e:d5:53 &&  wlan.da == a4:50:46:44:c9:77 ) ||  (wlan.sa == a4:50:46:44:c9:77  &&  wlan.da ==  1c:5f:2b:5e:d5:53 ) || (wlan.sa == 1c:5f:2b:5e:d5:53 && wlan.da == ff:ff:ff:ff:ff:ff) || (wlan.sa == a4:50:46:44:c9:77 && wlan.da == ff:ff:ff:ff:ff:ff)
                wireshard_fliterlist.add("((wlan.sa == "+bssid+" &&  wlan.da == "+mac+" ) || (wlan.sa == "+mac+" &&  wlan.da == "+bssid+")) || (wlan.sa == "+bssid+" && wlan.da == ff:ff:ff:ff:ff:ff) || (wlan.sa == "+mac+" && wlan.da == ff:ff:ff:ff:ff:ff)\n");
                wireshard_fliterlist.add("");


                wireshard_fliterlist.add(getRuleIndexTip()+" Mac 和 Bssid  Block_Ack 交互过程");
                wireshard_fliterlist.add("((wlan.sa == "+bssid+" &&  wlan.da == "+mac+" ) || (wlan.sa == "+mac+" &&  wlan.da == "+bssid+"))  && ( wlan.fixed.action_code == 0x00 || wlan.fixed.action_code == 0x01 || wlan.fc.type_subtype == 0x000e || wlan.fc == 0xc000 || eapol ||  wlan.fc.subtype == 0x000B  ||  wlan.fc.subtype == 0x0000  || wlan.fc.type_subtype == 0x0001 )");
                wireshard_fliterlist.add("");


                return wireshard_fliterlist;


            }
        }


        // 11:22:33:44:55 这样的格式 才是 Mac 地址
        boolean isMacAddress(String  inputMacAddress ){
            boolean isMac = false ;

            if(inputMacAddress == null){
                return  false;
            }

            int  length_no_spilit = inputMacAddress.replace(":","").trim().length();

            if(length_no_spilit != 12){
                System.out.println("当前 输入的 Mac 地址 inputMacAddress="+inputMacAddress+" 去除:号后长度不是12位!  无效地址! ");
                return false;
            }


            String[] macSplitArr = inputMacAddress.split(":");

            if(macSplitArr.length == 6){
                for (int i = 0; i < macSplitArr.length; i++) {
                    if(macSplitArr[i].length() != 2){
                        System.out.println("当前 输入的 Mac 地址 inputMacAddress="+inputMacAddress+" 分割后 长度不为2  不是规范的Mac地址!  无效地址! ");
                        return  false;
                    }
                }
                return true;
            }

            System.out.println("当前 输入的 Mac 地址 inputMacAddress="+inputMacAddress+" 长度 规范的Mac地址!  无效地址! ");

            return isMac;

        }

        @Override
        String simpleDesc() {
            return "  \n"
                    + Cur_Bat_Name  + " #_"+rule_index+" bssid_1c:5f:2b:5e:d5:53  mac_a4:50:46:44:c9:77   ###输入 bssid_1c:5f:2b:5e:d5:53【CMCC】  mac_a4:50:46:44:c9:77【Mix3】  来统计所有的 wireshark 过滤条件  可多输入   一比一匹配 \n"

                    ;
        }

        @Override
        boolean allowEmptyDirFileList() {
            return true;
        }


    }

    static String Rule61_showWirelessDialog_Method ="";  // 动态从 Zmain-Life 读取 showWirelessDialog 函数


    //  把在 zmain-Life 中实现的  Wireless 相关 逻辑 通过  这个规则 移植到  AOSP的 Settings 中 使得 能在系统层级调用以及对应设备 调用一些相关代码逻辑
    class Add_Zmain_Life_Wireless_Embedded_AOSP_Settings_Rule61 extends Basic_Rule {

        File aosp_settings_wifienabler_file;


        // 作为  在 Zmain-Life 实现的逻辑 用于在 Settings 修改时  获取到 对应的修改的逻辑
        File G2_Zmain_Life_Source_Dir;



        //   当前  定义函数 showWirelessDialog() 的 来自 Zmain-Life 的定义的来源  来自Txt_TxtEdit_Fragment.java 定义的 showWirelessDialog() 函数
        File G2_Zmain_Life_Txt_TxtEdit_Fragment_showWirelessDialog_JavaFile;



        File G2_Zmain_Life_Source_Res_LayoutDir;   // 当前 需要 拷贝的  res/layout 下的文件和目录
        // 当前 需要 拷贝的  res/layout 下的 以 wireless 开头的 xml 文件的集合
        ArrayList<File> G2_Zmain_Life_Source_Res_WiressXml_FileList;
        File AOSP_Settings_Res_LayoutDir;   // 在 AOSP_Settings 中对应的 放置 res/layout/wireless_xxxx.xml 文件的目录



        ArrayList<File> G2_Zmain_Life_Source_Res_Drable_FileList;
        ArrayList<File> G2_Zmain_Life_Source_Res_DrableV24_FileList;
        File G2_Zmain_Life_Source_Res_DrableDir;   // 当前 需要 拷贝的  res/drable 下的文件和目录
        File G2_Zmain_Life_Source_Res_DrableV24Dir;   // 当前 需要 拷贝的  res/drable-v24 下的文件和目录
        File AOSP_Settings_Res_DrableDir;   // 在 AOSP_Settings 中对应的 放置 res/drable/wireless_xxxx 文件的目录
        File AOSP_Settings_Res_DrableV24Dir;   // 在 AOSP_Settings 中对应的 放置 res/drable-v24/wireless_xxxx 文件的目录


        // 以 wireless_ 开头  activity.java 为结尾的文件
        ArrayList<File> G2_Zmain_Life_Source_Wireless_Activity_FileList;


        File AOSP_Settings_AndroidManifest_XMLFile ;   // Settings 的   AndroidManifest.xml 文件



        ArrayList<File> G2_Zmain_Life_Source_Wireless_Java_FileList ; // // 在 G2_Zmain-Life 资源文件中需要拷贝的  wireless 包名的Java 代码  需要 统一修改里面的 包名
        File G2_Zmain_Life_Source_Wireless_Java_Dir; // 在 G2_Zmain-Life 资源文件中需要拷贝的  wireless 包名的目录
        File AOSP_Settings_Target_Wireless_Java_Dir ;   // Settings 的  放置 Wireless 包名 的 那个目录




        // 判断当前路径是否是 AOSP 路径   直接检测 WifiEnable 是否存在
        boolean isCurPath_AOSP = false;  // 当前的目录是否是

        String timestamp_yyyymmdd_hhmmss;  // 时间戳   统一 使用


        boolean isAOSPSettings_Already_Embedded;   // 当前 AOSP_Settings 是否 已经 完成 过 嵌入 ?

        Add_Zmain_Life_Wireless_Embedded_AOSP_Settings_Rule61() {
            super("#", 61, 4);

            timestamp_yyyymmdd_hhmmss = getTimeStamp_yyyyMMdd_HHmmss();
            G2_Zmain_Life_Source_Wireless_Java_FileList = new ArrayList<File>();
            G2_Zmain_Life_Source_Res_WiressXml_FileList  = new ArrayList<File>();
            G2_Zmain_Life_Source_Wireless_Activity_FileList = new ArrayList<File>();
            G2_Zmain_Life_Source_Res_Drable_FileList   = new ArrayList<File>();
            G2_Zmain_Life_Source_Res_DrableV24_FileList   = new ArrayList<File>();


            isAOSPSettings_Already_Embedded = false;
        }


        boolean isCurPathAOSP () {

            String shellpath = curDirPath ;

            File shellFile = new File(shellpath);

            aosp_settings_wifienabler_file = new File(shellFile.getAbsolutePath()+File.separator+"packages/apps/Settings/src/com/android/settings/wifi/WifiEnabler.java");

            return  aosp_settings_wifienabler_file.exists() && aosp_settings_wifienabler_file.length() > 100;
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            boolean Flag = true;
            isCurPath_AOSP = isCurPathAOSP();

            if(!isCurPath_AOSP){
                System.out.println("当前路径不是 AOSP 的 根 路径 无法执行 嵌入 Settings 对应 zmain-Life-Wireless 的相关逻辑!  aosp_settings_wifienabler_file="+aosp_settings_wifienabler_file.getAbsolutePath());
                return false;
            }

            G2_Zmain_Life_Source_Dir = new File(zbinPath+File.separator+"G2_rule61_zmain-Life");

            if(!G2_Zmain_Life_Source_Dir.exists()){
                System.out.println("当前 修改Settings 逻辑来源 文件夹  ~/Desktop/zbin/G2_rule61_zmain-Life/ 该目录不存在 请检查! ");
                return false;
            }

            AOSP_Settings_AndroidManifest_XMLFile  = new File(curDirPath+File.separator+"/packages/apps/Settings/AndroidManifest.xml");

            // 需要 嵌入的 相关的 目标文件夹
            AOSP_Settings_Target_Wireless_Java_Dir  = new File(curDirPath+File.separator+"/packages/apps/Settings/src/com/android/settings/wifi/wireless/");

            AOSP_Settings_Res_LayoutDir  = new File(curDirPath+File.separator+"/packages/apps/Settings/res/layout/");

            AOSP_Settings_Res_DrableDir  = new File(curDirPath+File.separator+"/packages/apps/Settings/res/drawable/");
            AOSP_Settings_Res_DrableV24Dir = new File(curDirPath+File.separator+"/packages/apps/Settings/res/drawable-v24/");



            G2_Zmain_Life_Txt_TxtEdit_Fragment_showWirelessDialog_JavaFile = new File(G2_Zmain_Life_Source_Dir.getAbsoluteFile()+File.separator+"/app/src/main/java/com/and/zmain_life/fragment/Txt_TxtEdit_Fragment.java");

            if(G2_Zmain_Life_Txt_TxtEdit_Fragment_showWirelessDialog_JavaFile.exists()){

                ArrayList<String> txtFragmentCodeList =    ReadFileContentAsList(G2_Zmain_Life_Txt_TxtEdit_Fragment_showWirelessDialog_JavaFile);

                ArrayList<String> showWirelessDialogCodeList = getSubArrayWithBeginTag_EndTag(txtFragmentCodeList,"showWirelessDialog_Begin","showWirelessDialog_End");

                System.out.println("txtFragmentCodeList.size() = "+ txtFragmentCodeList.size());
                System.out.println("showWirelessDialogCodeList.size() = "+ showWirelessDialogCodeList.size());


                if(showWirelessDialogCodeList.size() != 0){

                    Rule61_showWirelessDialog_Method =   ArrToStr(showWirelessDialogCodeList);
                    System.out.println("读取到的 showWirelessDialog 定义如下:\n"+Rule61_showWirelessDialog_Method);

                    if("".equals(Rule61_showWirelessDialog_Method)){

                        System.out.println("无法从 "+G2_Zmain_Life_Txt_TxtEdit_Fragment_showWirelessDialog_JavaFile.getAbsolutePath()+" 获取 showWirelessDialog() 定义函数 请检查! Rule61_showWirelessDialog_Method= "+Rule61_showWirelessDialog_Method);
                    }

                }else {
                    System.out.println("无法从 "+G2_Zmain_Life_Txt_TxtEdit_Fragment_showWirelessDialog_JavaFile.getAbsolutePath()+" 获取 showWirelessDialog() 定义函数 请检查! ");
                    return false;
                }

            } else {
                System.out.println("当前 修改Settings 逻辑来源 文件夹 G2_Zmain_Life_Source_Wireless_Java_Dir ="+ G2_Zmain_Life_Source_Wireless_Java_Dir.getAbsolutePath()+" 不存在! 请检查!");

                return false;
            }




            G2_Zmain_Life_Source_Wireless_Java_Dir = new File(G2_Zmain_Life_Source_Dir.getAbsoluteFile()+File.separator+"/app/src/main/java/com/and/zmain_life/wireless/");

            if(G2_Zmain_Life_Source_Wireless_Java_Dir.exists()){

                File[] mWirelessJavaFileArr = G2_Zmain_Life_Source_Wireless_Java_Dir.listFiles();

                if(mWirelessJavaFileArr == null || mWirelessJavaFileArr.length == 0){
                    System.out.println("当前 修改Settings 逻辑来源 文件夹 G2_Zmain_Life_Source_Wireless_Java_Dir ="+ G2_Zmain_Life_Source_Wireless_Java_Dir.getAbsolutePath()+" 不存在原始Java 文件!");
                    return false;
                }
                G2_Zmain_Life_Source_Wireless_Java_FileList.addAll(Arrays.asList(mWirelessJavaFileArr));
            } else {
                System.out.println("当前 修改Settings 逻辑来源 文件夹 G2_Zmain_Life_Source_Wireless_Java_Dir ="+ G2_Zmain_Life_Source_Wireless_Java_Dir.getAbsolutePath()+" 不存在! 请检查!");

                return false;
            }

            G2_Zmain_Life_Source_Res_DrableDir = new File(G2_Zmain_Life_Source_Dir.getAbsoluteFile()+File.separator+"/app/src/main/res/drawable/");
            G2_Zmain_Life_Source_Res_DrableV24Dir = new File(G2_Zmain_Life_Source_Dir.getAbsoluteFile()+File.separator+"/app/src/main/res/drawable-v24/");

            if(G2_Zmain_Life_Source_Res_DrableDir.exists() || G2_Zmain_Life_Source_Res_DrableV24Dir.exists() ){

                File[] mWirelessDrableFileArr = G2_Zmain_Life_Source_Res_DrableDir.listFiles();

                if(mWirelessDrableFileArr == null || mWirelessDrableFileArr.length == 0){
                    System.out.println("当前 修改Settings 逻辑来源 文件夹 G2_Zmain_Life_Source_Res_DrableDir ="+ G2_Zmain_Life_Source_Res_LayoutDir.getAbsolutePath()+" 不存在原始 Wireless_*.xml 配置 文件!");

                } else {

                    for (int i = 0; i < mWirelessDrableFileArr.length; i++) {
                        File source_res_lauout_file = mWirelessDrableFileArr[i];
                        String layout_file_name = source_res_lauout_file.getName();
                        if(layout_file_name.toLowerCase().startsWith("wireless") ){
                            G2_Zmain_Life_Source_Res_Drable_FileList.add(source_res_lauout_file);
                        }
                    }


                }


                File[] mWirelessDrableV24FileArr = G2_Zmain_Life_Source_Res_DrableV24Dir.listFiles();

                if(mWirelessDrableV24FileArr == null || mWirelessDrableV24FileArr.length == 0){
                    System.out.println("当前 修改Settings 逻辑来源 文件夹 G2_Zmain_Life_Source_Res_DrableV24Dir ="+ G2_Zmain_Life_Source_Res_DrableV24Dir.getAbsolutePath()+" 不存在原始 Wireless_*.xml 配置 文件!");

                } else {

                    for (int i = 0; i < mWirelessDrableV24FileArr.length; i++) {
                        File source_res_lauout_file = mWirelessDrableV24FileArr[i];
                        String layout_file_name = source_res_lauout_file.getName();
                        if(layout_file_name.toLowerCase().startsWith("wireless") ){
                            G2_Zmain_Life_Source_Res_DrableV24_FileList.add(source_res_lauout_file);
                        }
                    }


                }




            }







            G2_Zmain_Life_Source_Res_LayoutDir = new File(G2_Zmain_Life_Source_Dir.getAbsoluteFile()+File.separator+"/app/src/main/res/layout/");


            if(G2_Zmain_Life_Source_Res_LayoutDir.exists()){

                File[] mWirelessLayoutXmlFileArr = G2_Zmain_Life_Source_Res_LayoutDir.listFiles();

                if(mWirelessLayoutXmlFileArr == null || mWirelessLayoutXmlFileArr.length == 0){
                    System.out.println("当前 修改Settings 逻辑来源 文件夹 G2_Zmain_Life_Source_Res_LayoutDir ="+ G2_Zmain_Life_Source_Res_LayoutDir.getAbsolutePath()+" 不存在原始 Wireless_*.xml 配置 文件!");
                    return false;
                }

                for (int i = 0; i < mWirelessLayoutXmlFileArr.length; i++) {
                    File source_res_lauout_file = mWirelessLayoutXmlFileArr[i];
                    String layout_file_name = source_res_lauout_file.getName();
                    if(layout_file_name.toLowerCase().startsWith("wireless") && layout_file_name.toLowerCase().endsWith("xml")){
                        G2_Zmain_Life_Source_Res_WiressXml_FileList.add(source_res_lauout_file);
                    }
                }

            } else {
                System.out.println("当前 修改Settings 逻辑来源 文件夹 G2_Zmain_Life_Source_Wireless_Java_Dir ="+ G2_Zmain_Life_Source_Res_LayoutDir.getAbsolutePath()+" 不存在! 请检查!");

                return false;
            }



            System.out.println("G2_Zmain_Life_Source_Wireless_Java_FileList.size() = "+ G2_Zmain_Life_Source_Wireless_Java_FileList.size());

            System.out.println("G2_Zmain_Life_Source_Res_WiressXml_FileList.size() = "+ G2_Zmain_Life_Source_Res_WiressXml_FileList.size());

            if(G2_Zmain_Life_Source_Res_WiressXml_FileList.size() == 0 || G2_Zmain_Life_Source_Wireless_Java_FileList.size() == 0){

                System.out.println("当前 从 G2_Zmain-Life 目录 "+G2_Zmain_Life_Source_Res_LayoutDir.getAbsolutePath()+"读取以 wireless 开头的xml   和  "+G2_Zmain_Life_Source_Wireless_Java_Dir.getAbsolutePath()+" 以 wireless 开头 的 Java 文件为空 ! ç∂ 请检查! ");

                return false;
            }



            String wifiEnable_CodeStr = readStringFromFile(aosp_settings_wifienabler_file);

            if(wifiEnable_CodeStr.contains("showWirelessDialog")){

                isAOSPSettings_Already_Embedded  = true;

            }


            if(isAOSPSettings_Already_Embedded){
                System.out.println("当前 WifiEnable.java 中 已经存在 之前导入的 关键函数 !  showWirelessDialog   请注意! ");
            }else{
                System.out.println("当前 WifiEnable.java 中 是完全新的函数 !   没有 关键函数字符串 showWirelessDialog    可以操作!! ");
            }

            return super.initParamsWithInputList(inputParamList) && Flag;
        }
        @Override
        String simpleDesc() {
            return "  \n"
                    + Cur_Bat_Name  + " #_"+rule_index+"  ### 把在 zmain-Life 中实现的  Wireless 相关 逻辑 通过  这个规则 移植到  AOSP的 Settings 中 使得 能在系统层级调用以及对应设备 调用一些相关代码逻辑 \n"

                    ;
        }

        @Override
        boolean allowEmptyDirFileList() {
            return true;
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            // 从 原始 Zmain-Life 来 读取 关键 showWirelessDialog()   不写死


            // 插装
            if(!aosp_wifi_enable_cha_zhuang()){

                System.out.println("往 WifiEnable.java 插装失败 请检查! ");
            }

            //  复制 res_wireless
            for (int i = 0; i < G2_Zmain_Life_Source_Res_WiressXml_FileList.size() ; i++) {
                File src_res_layout_file = G2_Zmain_Life_Source_Res_WiressXml_FileList.get(i);
                File dst_res_layout_file = new File(AOSP_Settings_Res_LayoutDir.getAbsolutePath()+File.separator+src_res_layout_file.getName());
                fileCopy(src_res_layout_file,dst_res_layout_file);
                System.out.println("res_layout["+i+"_"+G2_Zmain_Life_Source_Res_WiressXml_FileList.size() +"]:"+dst_res_layout_file.getAbsolutePath()+"复制完成!");
            }

            //  复制 res_drable
            for (int i = 0; i < G2_Zmain_Life_Source_Res_Drable_FileList.size() ; i++) {
                File src_res_layout_file = G2_Zmain_Life_Source_Res_Drable_FileList.get(i);
                File dst_res_layout_file = new File(AOSP_Settings_Res_DrableDir.getAbsolutePath()+File.separator+src_res_layout_file.getName());
                fileCopy(src_res_layout_file,dst_res_layout_file);
                System.out.println("res_drable["+i+"_"+G2_Zmain_Life_Source_Res_Drable_FileList.size() +"]:"+dst_res_layout_file.getAbsolutePath()+"复制完成!");
            }

            //  复制 res_drable-V24
            for (int i = 0; i < G2_Zmain_Life_Source_Res_DrableV24_FileList.size() ; i++) {
                File src_res_layout_file = G2_Zmain_Life_Source_Res_DrableV24_FileList.get(i);
                File dst_res_layout_file = new File(AOSP_Settings_Res_DrableV24Dir.getAbsolutePath()+File.separator+src_res_layout_file.getName());
                fileCopy(src_res_layout_file,dst_res_layout_file);
                System.out.println("res_drable-V24["+i+"_"+G2_Zmain_Life_Source_Res_DrableV24_FileList.size() +"]:"+dst_res_layout_file.getAbsolutePath()+"复制完成!");
            }




            // Wireless_
            //  复制 java_wireless
            int wireless_activity_count = 1;
            for (int i = 0; i < G2_Zmain_Life_Source_Wireless_Java_FileList.size() ; i++) {
                File src_wireless_java_file = G2_Zmain_Life_Source_Wireless_Java_FileList.get(i);
                File dst_wireless_java_file = new File(AOSP_Settings_Target_Wireless_Java_Dir.getAbsolutePath()+File.separator+src_wireless_java_file.getName());
                // 对 源文件进行 解析  去掉一些 package 之类的 再写入到  dst 目标中
                ArrayList<String> raw_java_codelist = ReadFileContentAsList(src_wireless_java_file);
                ArrayList<String> raw_java_codelist_fixed_1 = replaceInList(raw_java_codelist,"package com.and.zmain_life.wireless;","package com.android.settings.wifi.wireless;");
                ArrayList<String> raw_java_codelist_fixed_2 = replaceInList(raw_java_codelist_fixed_1,"import com.and.zmain_life.R;","import com.android.settings.R;");

                writeContentToFile(dst_wireless_java_file,raw_java_codelist_fixed_2);

                System.out.println("java["+i+"_"+G2_Zmain_Life_Source_Wireless_Java_FileList.size() +"]:"+dst_wireless_java_file.getAbsolutePath()+"复制完成!");

                String activity_java_file_name = src_wireless_java_file.getName();



                if(activity_java_file_name.toLowerCase().startsWith("wireless_") && activity_java_file_name.toLowerCase().endsWith("activity.java") ){
                    G2_Zmain_Life_Source_Wireless_Activity_FileList.add(src_wireless_java_file);
                    System.out.println("Wireless_XXXX_Activity["+wireless_activity_count+"] = "+ activity_java_file_name);
                    wireless_activity_count++;
                }

            }

            System.out.println("嵌入的Activity的数量: G2_Zmain_Life_Source_Wireless_Activity_FileList.size() = "+ G2_Zmain_Life_Source_Wireless_Activity_FileList.size());

            if(G2_Zmain_Life_Source_Wireless_Activity_FileList.size() == 0){
                System.out.println("嵌入的Activity的数量 为0  执行操作失败!  请检查! ");
                return  null;

            }
            StringBuilder activitySB = new StringBuilder();
            for (int i = 0; i < G2_Zmain_Life_Source_Wireless_Activity_FileList.size() ; i++) {
                File src_wireless_activity_file = G2_Zmain_Life_Source_Wireless_Activity_FileList.get(i);

                String fileName_NoPoint = getFileNameNoPoint(src_wireless_activity_file);

                String line_1 = "<!-- zukgit -->  <activity android:name=\".wifi.wireless."+fileName_NoPoint+"\"";
                String line_2 = "android:configChanges=\"orientation|screenSize|keyboardHidden\"/> <!--  zukgit -->";

                activitySB.append(line_1+"\n"+line_2+"\n");

            }


            ArrayList<String>  AOSP_Settings_Manifest_StrList = ReadFileContentAsListWithClearTag(AOSP_Settings_AndroidManifest_XMLFile,"zukgit");

            ArrayList<String> new_AOSP_Settings_Manifest_StrList = replaceInList(AOSP_Settings_Manifest_StrList,"</application>","\n"+activitySB.toString()+"\n"+"</application>");

//            </application>  替换为 指定的 Activity的列表
            writeContentToFile(AOSP_Settings_AndroidManifest_XMLFile,new_AOSP_Settings_Manifest_StrList);
            System.out.println("完成  AndroidManifest.xml文件的修改操作!  "+AOSP_Settings_AndroidManifest_XMLFile.getAbsolutePath()+"  activitySB="+activitySB.toString());




            return null;
        }


        boolean aosp_wifi_enable_cha_zhuang() {

//            ArrayList<String> wpasupplicant_file_contentlist = ReadFileContentAsList(aosp_settings_wifienabler_file);

            boolean is_wifi_enable_cha_zhuang_success = false;

            //  包含 这 两行 的 内容  不读取进来
            ArrayList<String> wpasupplicant_file_contentlist = ReadFileJavaContentAsList_Begin_End(aosp_settings_wifienabler_file,"showWirelessDialog_Begin","showWirelessDialog_End");

            if(wpasupplicant_file_contentlist == null || wpasupplicant_file_contentlist.size() == 0 ){

                System.out.println("读取出来的 WifiEnable 文件 内容为空 !  无法执行嵌入Settings 操作  请检查! ");
                return is_wifi_enable_cha_zhuang_success;
            }
            ArrayList<String> newCodeList = new ArrayList<String> ();


            for (int i = 0; i < wpasupplicant_file_contentlist.size(); i++) {

                String oneLine = wpasupplicant_file_contentlist.get(i);

                if(oneLine.contains("zukgit")) {
                    continue;
                }

                if(oneLine.contains("com.android.settings.wifi.wireless")) {
                    continue;
                }

                if(oneLine.contains("showWirelessDialog();")) {
                    continue;
                }


                if(oneLine.contains("onSwitchToggled(boolean isChecked)") ) {
//					 android.util.Log.i("zoggled", "this_i2");


                    newCodeList.add(oneLine);
                    newCodeList.add("android.util.Log.i(\"wifienabler_zukgit\", \""+aosp_settings_wifienabler_file.getAbsolutePath()+"_"+timestamp_yyyymmdd_hhmmss+"_【 WifiEnabler_onSwitchToggled isChecked=\"+isChecked+\"】\");");
                    newCodeList.add("showWirelessDialog();");

                    continue;
                }

                newCodeList.add(oneLine);

            }

            String lastCode = newCodeList.get(newCodeList.size()-1);

            lastCode =  lastCode.trim();

            if(lastCode.endsWith("}")){

                String last_code_no_block = lastCode.substring(0,lastCode.length()-1);


                String new_last_Code = last_code_no_block +"\n" + Rule61_showWirelessDialog_Method +"\n"+"}";

                new_last_Code =  new_last_Code.replace("ztimestamp",timestamp_yyyymmdd_hhmmss);
                new_last_Code =  new_last_Code.replace("zabspath",aosp_settings_wifienabler_file.getAbsolutePath());

                newCodeList.remove(newCodeList.size()-1);
                newCodeList.add(new_last_Code);



            } else {

                System.out.println("当前读取到的 WifiEnabler.java 的最后一行不是 以 } 为 结尾  读取操作失败 请检查!   lastCode="+lastCode);
                return  false;
            }



            ArrayList<String> newCode_list1 = replaceInList(newCodeList,"package com.android.settings.wifi;","package com.android.settings.wifi;\nimport com.android.settings.wifi.wireless.*;");

            writeContentToFile(aosp_settings_wifienabler_file, newCode_list1);
            System.out.println(""+aosp_settings_wifienabler_file.getAbsolutePath()+" 插桩成功!");

            return true;

        }



    }



    //  读取 releasenote.html  解析出来数据 然后 产生 tip 文件
    class ReleaseNoteHtml_Revert_TipTxt_Rule_60 extends Basic_Rule {

        ArrayList<File> mInputRelesaeNoteHtmlFileList; // 当前 cmd 参数给出的 的 html 文件  ,  如果 没有  html 文件 那么 检索当前目录 所有的 html 产生 tip 文件
        boolean isSearAllLocalHtml ;  //  是否搜索 本地的所有的 html 文件

        File resultTipTxtDir; //  当前 生成的 txt文件 放置的位置   如果 直接输出到本地 可能 引起混乱 而且 存在覆盖的可能

        String timestamp_yyyyMMddHHmmss;


        ReleaseNoteHtml_Revert_TipTxt_Rule_60() {
            super("#", 60, 4); //
            mInputRelesaeNoteHtmlFileList = new ArrayList<File>();
            isSearAllLocalHtml = false;
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            timestamp_yyyyMMddHHmmss =getTimeStamp_yyyyMMdd_HHmmss();
            resultTipTxtDir = new File(curDirPath + File.separator+"Product_Tip_"+timestamp_yyyyMMddHHmmss);
            for (int i = 0; i < inputParamList.size(); i++) {
                String strInput = inputParamList.get(i);

                File tempFile = new File(curDirPath + File.separator + strInput);
                if (tempFile.exists() && !tempFile.isDirectory()) {
                    String inputFileName = tempFile.getName().toLowerCase();
                    if (inputFileName.endsWith(".html")) {
                        mInputRelesaeNoteHtmlFileList.add(tempFile);
                    }
                }
            }

            if (mInputRelesaeNoteHtmlFileList.size() == 0) {
                isSearAllLocalHtml = true;
                System.out.println("当前 命令行输入的 .html 文件个数 为0   将执行 搜索全 Html 文件操作!");
            }
            System.out.println("1.输入Html参数个数mInputRelesaeNoteHtmlFileList.size()=【"+mInputRelesaeNoteHtmlFileList.size()+"】  ");
            System.out.println("2.本地全搜索Html标识 isSearAllLocalHtml=【"+isSearAllLocalHtml+"】");
            System.out.println("3.本地Tip_Txt保存文件夹 resultTipTxtDir=【"+resultTipTxtDir.getAbsolutePath()+"】");
            return super.initParamsWithInputList(inputParamList);
        }


        void MapFilePrint(Map<String, ArrayList<File>> sameFileTypeArrMap) {
            Map.Entry<String, ArrayList<File>> entry;
            if (sameFileTypeArrMap != null) {
                System.out.println("sameFileTypeArrMap != null &&  size = "+sameFileTypeArrMap.size());
                Iterator iterator = sameFileTypeArrMap.entrySet().iterator();
                while (iterator.hasNext()) {
                    entry = (Map.Entry<String, ArrayList<File>>) iterator.next();
                    String key = entry.getKey();  //Map的Value
                    ArrayList<File> sameNodeList = entry.getValue();  //Map的Value
                    System.out.println("════════Same FileType["+key+"]["+sameNodeList.size()+"] Begin════════");
                    for (int i = 0; i < sameNodeList.size(); i++) {

                        File sameNodeitem = sameNodeList.get(i);
                        String fileName = sameNodeitem.getName();
                        System.out.println(" File_Map<"+key+","+i+"_"+sameNodeList.size()+">:" + fileName);

                    }
                    System.out.println("════════Same FileType["+key+"]["+sameNodeList.size()+"] End════════");
                }
            } else {

                System.out.println("sameFileTypeArrMap == null &&  size = 0");
            }


        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList, HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList, ArrayList<File> curRealFileList) {

            MapFilePrint(subFileTypeMap);
            System.out.println("begin applySubFileListRule4 _____");

            if(isSearAllLocalHtml){
                ArrayList<File> localHtmlList =    subFileTypeMap.get(".html");
                if(localHtmlList != null && localHtmlList.size() > 0 ){
                    mInputRelesaeNoteHtmlFileList.addAll(localHtmlList);
                }
            }


            if (mInputRelesaeNoteHtmlFileList.size() == 0 ) {
                System.out.println("当前 没有 可供 输入的 ReleaseNote Html 文件可供输入 产生 Product_Tip.txt 文件! 执行程序失败! ");
                return null;
            }

            try {
                int avaliable_product_txt_count = 0 ;
                ArrayList<String> failed_htmlparse_tiplist = new  ArrayList<String>();


                for (int i = 0; i < mInputRelesaeNoteHtmlFileList.size() ; i++) {

                    File releaseHtmlFile = mInputRelesaeNoteHtmlFileList.get(i);

                    System.out.println("╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤ HtmlFile["+i+"_"+mInputRelesaeNoteHtmlFileList.size()+"]_"+releaseHtmlFile.getName()+"_"+"begin ╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤╤");

                    ReleaseNoteHtmlItem releaseNoteHtmlItem = new ReleaseNoteHtmlItem(releaseHtmlFile);

                    if(releaseNoteHtmlItem.is_inputHtml_Avaliable){

                        failed_htmlparse_tiplist.add("Html["+i+"_"+mInputRelesaeNoteHtmlFileList.size()+"] "+"  isRealeaseNote【 "+true+"  】【1.product_name="+releaseNoteHtmlItem.product_name_1 +"】【"+(releaseNoteHtmlItem.isVendor_2?"2.Vendor":"2.Msi")+"】"+"【"+(releaseNoteHtmlItem.isMainLineBranch_3?"3.MainLine":"3.StableLine")+"】"+"【4.identy="+releaseNoteHtmlItem.version_identify_4+"】");
                        avaliable_product_txt_count++;
                    } else{
                        failed_htmlparse_tiplist.add("Html["+i+"_"+mInputRelesaeNoteHtmlFileList.size()+"] "+"  isRealeaseNote【 "+false+" 】"+releaseHtmlFile.getName());

                    }
                    System.out.println();
                    System.out.println();
                    System.out.println();

                }

                System.out.println("═══════════════════"+"打印解析结果 begin"+"═══════════════════"  );
                for (int i = 0; i < failed_htmlparse_tiplist.size(); i++) {
                    System.out.println(failed_htmlparse_tiplist.get(i));
                }

                System.out.println("OK!  已经解析出  【"+avaliable_product_txt_count+"】 个 Product_Tip文件  在当前目录: "+resultTipTxtDir.getName()  );

            } catch (Exception e) {
                e.printStackTrace();
                System.out.println("当前 解析 ReleaseNote.html 报错 " + e);
                System.out.println(e);

            }


            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }


        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_" + rule_index
                    + "  <指定 releaseA.html 文件>   <指定 releaseA.html 文件>  ### 解析当前输入的releaseNote文件用于输出 product_tip.txt文件   \n"
                    + Cur_Bat_Name + " #_" + rule_index + "  A.html B.html C.html   ### 解析当前输入的releaseNote文件用于输出 product_tip.txt文件    \n"
                    + Cur_Bat_Name + " #_" + rule_index + "        ### 解析当前目录下所有的html文件 尝试按照 releaseNote.html文件用于输入 产生 product_tip.txt文件    \n";
        }

        class ReleaseNoteHtmlItem {
            String product_name_1;


            // true---vendor   false----msi
            boolean isVendor_2;  //  html 是否包含 Vendor  Build
            
         // 当前文档是否包含  -M <path to MSI workspace> -V <path to VENDOR workspace>
         // 包含的话 说明当前文件 是一个新出现的 融合 msi  和 Vendor 的仓库 需要新建 这个文件 Merge_1 区别于Msi_1 Vendor_1
            boolean isMerge_2 ;   
            
            
            
            
            boolean  isMainLineBranch_3;   // MANIFEST BRANCH	mt-r1-stable12   , branch 名称是否包含 stable 字样
            String version_identify_4 ;  //  SOFTWARE BUILD ID ( + REV) 后面的数据
            String timeStamp_5;   //  时间戳

            boolean  isQcomProduct_6;   // true 高通平台    false__  mtk 平台   对比两个关键字 谁多就是谁

            File mrawReleaseNoteHtmlFile ;   // 原始文件
            File mResultProductTipTxtFile ;  //  结果文件
            String mResultProductTipTxtFileName;   // 结果文件名称



            String mRawHtmlContent  ;   // 从 mrawReleaseNoteHtmlFile 读取到的 原始的 文件的内容
            ArrayList<String> mHtmlContentList ;    // 从  Html 中读取到的字符串的列表

            ArrayList<String> product_txt_List ;

            boolean is_manifestinfo_exist ;   //
            boolean is_buildinstruct_exist ;
            boolean is_inputHtml_Avaliable;


            ReleaseNoteHtmlItem(File rawHtmlFile){

                mrawReleaseNoteHtmlFile = rawHtmlFile;
                mRawHtmlContent = ReadFileContent(rawHtmlFile);
                mHtmlContentList = ReadFileContentAsList(rawHtmlFile);
                product_txt_List = new   ArrayList<String>();

                is_buildinstruct_exist =  isStringContainInList("Build Instructions",mHtmlContentList)  || isStringContainInList("BUILD INSTRUCTIONS",mHtmlContentList);


                is_manifestinfo_exist =  isStringContainInList("Manifest Info",mHtmlContentList)  || isStringContainInList("MANIFEST INFO",mHtmlContentList);
                isVendor_2 =   isStringContainInList("Vendor Build",mHtmlContentList)  || isStringContainInList("VENDOR BUILD",mHtmlContentList) || isStringContainInList("Vendor Side",mHtmlContentList) || isStringContainInList("VENDOR SIDE",mHtmlContentList) || isStringContainInList("VENDOR RELEASE VERSION",mHtmlContentList) ; 

                isMerge_2 =   isStringContainInList("path to MSI workspace",mHtmlContentList) && isStringContainInList("path to VENDOR workspace",mHtmlContentList)   ; 

                System.out.println("isMerge_1  <path to MSI workspace>    flag = "+ isStringContainInList("<path to MSI workspace>",mHtmlContentList));
                System.out.println("isMerge_2  <path to VENDOR workspace> flag = "+ isStringContainInList("<path to VENDOR workspace>",mHtmlContentList));

                

                is_inputHtml_Avaliable = is_buildinstruct_exist && is_manifestinfo_exist;

                if(!is_inputHtml_Avaliable){
                    return;
                }

                if (!init_ReleateNoteData(rawHtmlFile , mRawHtmlContent ,  mHtmlContentList , this)) {
                    System.out.println("解析当前 【"+rawHtmlFile.getName()+"】ReleaseNote.html 文件 解析不到完整数据 导致异常 ,请检查,并重新执行!");
                    is_inputHtml_Avaliable = false;
                    return;
                }

//                if(!calculDynamicData()){
//                    System.out.println("解析当前 【"+rawHtmlFile.getName()+"】eleaseNote.html 的数据 失败 请检查,并重新执行! ");
//                    is_inputHtml_Avaliable = false;
//                    return;
//                }

//                init_product_tip_result(this );





            }

            String buildSettingsApk(HashMap<String,String> valueMap) {
                String result = "";

                String str1_1 = " export PATH=/apps/android/python-2.7.6-x64/bin:$PATH  && export PATH=/apps/android/perl-5.1aclmsx8.4-x64/bin:$PATH && ";
                String str2_1 = " source build/envsetup.sh && source /opt/android.conf  &&   source /opt/conf/moto.conf  && ";
                String str3_1 = " lunch " +  valueMap.get("productname")  + "-userdebug && ";
                String str4_1 = " mmm  /packages/apps/Settings ";
                result = str1_1 + str2_1 + str3_1 + str4_1;
                return result;
            }

            String buildSettingsApk_make(HashMap<String,String> valueMap) {
                String result = "";

                String str1_1 = " export PATH=/apps/android/python-2.7.6-x64/bin:$PATH  && export PATH=/apps/android/perl-5.1aclmsx8.4-x64/bin:$PATH && ";
                String str2_1 = " source build/envsetup.sh && source /opt/android.conf  &&   source /opt/conf/moto.conf  && ";
                String str3_1 = " lunch " +  valueMap.get("productname")  + "-userdebug && ";
                String str4_1 = " make Settings ";
                result = str1_1 + str2_1 + str3_1 + str4_1;
                return result;
            }




            String buildFrameworkJar(HashMap<String,String> valueMap) {
                String result = "";
                String str1_1 = " export PATH=/apps/android/python-2.7.6-x64/bin:$PATH  && export PATH=/apps/android/perl-5.1aclmsx8.4-x64/bin:$PATH && ";
                String str2_1 = " source build/envsetup.sh && source /opt/android.conf  &&   source /opt/conf/moto.conf  && ";
                String str3_1 = " lunch " + valueMap.get("productname")  + "-userdebug && ";
                String str4_1 = " mmm frameworks/base/ ";
                result = str1_1 + str2_1 + str3_1 + str4_1;
                return result;
            }

            String buildFrameworkJar_make(HashMap<String,String> valueMap) {
                String result = "";
                String str1_1 = " export PATH=/apps/android/python-2.7.6-x64/bin:$PATH  && export PATH=/apps/android/perl-5.1aclmsx8.4-x64/bin:$PATH && ";
                String str2_1 = " source build/envsetup.sh && source /opt/android.conf  &&   source /opt/conf/moto.conf  && ";
                String str3_1 = " lunch " + valueMap.get("productname")  + "-userdebug && ";
                String str4_1 = " make framework ";
                result = str1_1 + str2_1 + str3_1 + str4_1;
                return result;
            }


            String buildFrameworkRes_make(HashMap<String,String> valueMap) {
                String result = "";
                String str1_1 = " export PATH=/apps/android/python-2.7.6-x64/bin:$PATH  && export PATH=/apps/android/perl-5.1aclmsx8.4-x64/bin:$PATH && ";
                String str2_1 = " source build/envsetup.sh && source /opt/android.conf  &&   source /opt/conf/moto.conf  && ";
                String str3_1 = " lunch " + valueMap.get("productname")  + "-userdebug && ";
                String str4_1 = " make framework-res ";
                result = str1_1 + str2_1 + str3_1 + str4_1;
                return result;
            }

            String buildFrameworkService_make(HashMap<String,String> valueMap) {
                String result = "";
                String str1_1 = " export PATH=/apps/android/python-2.7.6-x64/bin:$PATH  && export PATH=/apps/android/perl-5.1aclmsx8.4-x64/bin:$PATH && ";
                String str2_1 = " source build/envsetup.sh && source /opt/android.conf  &&   source /opt/conf/moto.conf  && ";
                String str3_1 = " lunch " + valueMap.get("productname")  + "-userdebug && ";
                String str4_1 = " make services ";
                result = str1_1 + str2_1 + str3_1 + str4_1;
                return result;
            }





            String buildWifiServiceJar(HashMap<String,String> valueMap) {
                String result = "";
                String str1_1 = " export PATH=/apps/android/python-2.7.6-x64/bin:$PATH  && export PATH=/apps/android/perl-5.1aclmsx8.4-x64/bin:$PATH && ";
                String str2_1 = " source build/envsetup.sh && source /opt/android.conf  &&   source /opt/conf/moto.conf  && ";
                String str3_1 = " lunch " + valueMap.get("productname") + "-userdebug && ";
                String str4_1 = " mmm frameworks/opt/net/wifi/service ";
                result = str1_1 + str2_1 + str3_1 + str4_1;
                return result;
            }

            String buildWpaSupplicant(HashMap<String,String> valueMap) {
                String result = "";
                String str1_1 = " export PATH=/apps/android/python-2.7.6-x64/bin:$PATH  && export PATH=/apps/android/perl-5.1aclmsx8.4-x64/bin:$PATH && ";
                String str2_1 = " source build/envsetup.sh && source /opt/android.conf  &&   source /opt/conf/moto.conf  && ";
                String str3_1 = " lunch " + valueMap.get("productname") + "-userdebug && ";
                String str4_1 = " mmm external/wpa_supplicant_8 ";
                result = str1_1 + str2_1 + str3_1 + str4_1;
                return result;
            }



            void printSchema(String title) {
                if("".equals(title)){
                    System.out.println();
                    return;
                }
                System.out.println("════════════════════════════════════════════" + title + "════════════════════════════════════════════");
            }


            String getSchema(String title) {
                String mtitle = title;
                if("".equals(title)){
                    mtitle = "════════════════════════════════════════════" + title + "════════════════════════════════════════════";

                    return mtitle;
                }
                return "════════════════════════════════════════════" + title + "════════════════════════════════════════════" ;
            }




            public  String getTextFromTHML(String htmlStr) {
                org.jsoup.nodes.Document doc = Jsoup.parse(htmlStr);
                String text = doc.text();
                // remove extra white space
                StringBuilder builder = new StringBuilder(text);
                int index = 0;
                while(builder.length()>index){
                    char tmp = builder.charAt(index);
                    if(Character.isSpaceChar(tmp) || Character.isWhitespace(tmp)){
                        builder.setCharAt(index, ' ');
                    }
                    index++;
                }
                text = builder.toString().replaceAll(" +", " ").trim();
                return text;
            }

            
            
        

            String getSpltAStrAndEndWithBStr(String keyStr , String indexOfKeyStr , String rawStr   ){
                String matchFistStr = null ;
                if(keyStr == null  ){

                    System.out.println("getSpltAStrAndEndWithBStr 当前 从 Html解析的 getFirstStringAfterKey  参数 keyStr == null ! 请检查");
                    return matchFistStr;
                }
                
                if( indexOfKeyStr == null ){

                    System.out.println("indexOfKeyStr 为空 getSpltAStrAndEndWithBStr 当前 从 Html解析的 getFirstStringAfterKey  参数 keyStr == null ! 请检查");
                    return matchFistStr;
                }
                
                if(rawStr == null ){

                    System.out.println("getSpltAStrAndEndWithBStr 当前 从 rawStr 解析的 getFirstStringAfterKey  参数 rawStr == null ! 请检查");
                    return matchFistStr;
                }



                if(!rawStr.contains(keyStr) && !keyStr.contains(".") ){
                    if(rawStr.length() > 100){
                        System.out.println("当前参数  keyStr 不包含正则表达式的点. 同时  keyStr="+keyStr+" 并不包含在 rawStr  请检查! rawStr.length="+ rawStr.length()+" ");
                    } else{
                        System.out.println("当前参数  keyStr 不包含正则表达式的点. 同时  keyStr="+keyStr+" 并不包含在 rawStr  请检查! rawStr="+rawStr+"");

                    }

                    return matchFistStr;
                }


                String[] splitStrArr = rawStr.split(keyStr);

                if(splitStrArr.length > 2){
                    System.out.println();
                    System.out.println("当前 关键字 keyStr="+keyStr+" 在 rawStr 中存在 "+(splitStrArr.length -1) +"个 请注意唯一性!");
                   for (int i = 0; i < splitStrArr.length; i++) { 
                    System.out.println(" 关键字 "+keyStr+"["+i+"_"+splitStrArr.length+"] = "+splitStrArr[i]+"   注意唯一性!");
		   
				   }
                 
                }

                if(splitStrArr != null && splitStrArr.length < 2){
                    if(splitStrArr.length == 1){
                        System.out.println("当前解析 keyStr=【"+keyStr+"】 splitStrArr.length="+splitStrArr.length +" Arr[0].length="+splitStrArr[0].length());
                    }

                }

                if(splitStrArr.length >= 2){
                    String lastindex_1_str = null;
                    lastindex_1_str = splitStrArr[splitStrArr.length -1].trim();

                    
                    if(lastindex_1_str.contains(indexOfKeyStr)) {
                    	
                    	matchFistStr =    lastindex_1_str.substring(0,lastindex_1_str.indexOf(indexOfKeyStr)+ indexOfKeyStr.length());
                        System.out.println("matchFistStr  = 当前解析 keyStr=【"+keyStr+"】  indexofKeyStr【"+indexOfKeyStr+"】"+" 有包含在 lastindex_1_str 中   matchFistStr="+matchFistStr);

                    } else {
                    	matchFistStr = "null";// 无法 搜索到 当前的
                        System.out.println("matchFistStr = 当前解析 keyStr=【"+keyStr+"】  indexofKeyStr【"+indexOfKeyStr+"】"+" 没有包含在 lastindex_1_str 中   lastindex_1_str="+lastindex_1_str);

                    }

                }



                System.out.println(" getSpltAStrAndEndWithBStr = 【"+matchFistStr+"】");

                return matchFistStr;



            }

            

            String getDirectXStringAfterKey(String keyStr , String rawStr , boolean beginflag , int blockCount  ){
                String matchFistStr = null ;
                if(keyStr == null ){

                    System.out.println("getDirectXStringAfterKey 当前 从 Html解析的 getFirstStringAfterKey  参数 keyStr == null ! 请检查");
                    return matchFistStr;
                }
                if(rawStr == null ){

                    System.out.println("getDirectXStringAfterKey 当前 从 rawStr 解析的 getFirstStringAfterKey  参数 rawStr == null ! 请检查");
                    return matchFistStr;
                }



                if(!rawStr.contains(keyStr) && !keyStr.contains(".") ){
                    if(rawStr.length() > 100){
                        System.out.println("当前参数  keyStr 不包含正则表达式的点. 同时  keyStr="+keyStr+" 并不包含在 rawStr  请检查! rawStr.length="+ rawStr.length()+" ");
                    } else{
                        System.out.println("当前参数  keyStr 不包含正则表达式的点. 同时  keyStr="+keyStr+" 并不包含在 rawStr  请检查! rawStr="+rawStr+"");

                    }

                    return matchFistStr;
                }


                String[] splitStrArr = rawStr.split(keyStr);

                if(splitStrArr.length > 2){
                    System.out.println();
                    System.out.println("当前 关键字 keyStr="+keyStr+" 在 rawStr 中存在 "+(splitStrArr.length -1) +"个 请注意唯一性!");
                   for (int i = 0; i < splitStrArr.length; i++) { 
                    System.out.println(" 关键字 "+keyStr+"["+i+"_"+splitStrArr.length+"] = "+splitStrArr[i]+"   注意唯一性!");
		   
				   }
                 
                }

                if(splitStrArr != null && splitStrArr.length < 2){
                    if(splitStrArr.length == 1){
                        System.out.println("当前解析 keyStr=【"+keyStr+"】 splitStrArr.length="+splitStrArr.length +" Arr[0]="+splitStrArr[0]);
                    }

                }

                if(splitStrArr.length >= 2){
                    String index_1_str = null;
                    if(beginflag){
//                        index_1_str = splitStrArr[1].trim();
                    	
                        index_1_str = splitStrArr[splitStrArr.length -1].trim();

                    } else {
                        index_1_str = splitStrArr[splitStrArr.length -1].trim();


                    }


                    String[] indedx_1_BlockSplit_Arr = index_1_str.split(" ");
                    StringBuilder mSB = new StringBuilder();
                    if(indedx_1_BlockSplit_Arr != null && indedx_1_BlockSplit_Arr.length > 1){

                        if(indedx_1_BlockSplit_Arr.length >= blockCount){
                            for (int i = 0; i < blockCount ; i++) {
                                mSB.append(indedx_1_BlockSplit_Arr[i]+" ");
                            }


                        }else{
                            System.out.println("只返回当前第SplitArr长度【"+indedx_1_BlockSplit_Arr.length+"】 字符串!!  当前 Split字符串【"+keyStr+"】选中"+(beginflag?"【第一个】":"【最后一个】")
                                    +"后以【 】空格再次分割后的字符串需要 拼接的字符串长度 blockCount="+blockCount+" 大于分割的BlockSplit_Arr.length="+indedx_1_BlockSplit_Arr.length);
                            matchFistStr =  indedx_1_BlockSplit_Arr[0].trim();

                            for (int i = 0; i < indedx_1_BlockSplit_Arr.length ; i++) {
                                mSB.append(indedx_1_BlockSplit_Arr[i]+" ");
                            }

                        }

                        if(!mSB.toString().trim().equals("")){
                            matchFistStr =mSB.toString().trim();
                        }


                    }
                }




                return matchFistStr;



            }



            String getFirstStringAfterKey(String keyStr , String rawStr ){
                String matchFistStr = null ;
                if(keyStr == null ){

                    System.out.println("当前 从 Html解析的 getFirstStringAfterKey  参数 keyStr == null ! 请检查");
                    return matchFistStr;
                }
                if(rawStr == null ){

                    System.out.println("当前 从 rawStr 解析的 getFirstStringAfterKey  参数 rawStr == null ! 请检查");
                    return matchFistStr;
                }



                if(!rawStr.contains(keyStr) && !keyStr.contains(".") ){

                    if(rawStr.length() > 100){
                        System.out.println("getFirstStringAfterKey 当前参数  keyStr 不包含正则表达式的点. 同时  keyStr="+keyStr+" 并不包含在 rawStr  请检查! rawStr.length="+ rawStr.length()+" ");
                    } else{
                        System.out.println("getFirstStringAfterKey 当前参数  keyStr 不包含正则表达式的点. 同时  keyStr="+keyStr+" 并不包含在 rawStr  请检查! rawStr="+rawStr+"");

                    }

                    return matchFistStr;
                }


                String[] splitStrArr = rawStr.split(keyStr);

                if(splitStrArr.length >= 2){
                    System.out.println();
                    System.out.println("当前 关键字 keyStr="+keyStr+" 在 rawStr 中存在 "+(splitStrArr.length -1) +"个 请注意唯一性!");
               
                    for (int i = 0; i < splitStrArr.length; i++) { 
                        System.out.println(" 关键字 "+keyStr+"["+i+"_"+splitStrArr.length+"] = "+splitStrArr[i]+"   注意唯一性!");
    		   
    				   }
                }

                if(splitStrArr != null && splitStrArr.length < 2){
                    if(splitStrArr.length == 1){
                        System.out.println("当前解析 keyStr=【"+keyStr+"】 splitStrArr.length="+splitStrArr.length +" Arr[0]="+splitStrArr[0]);
                    }

                }

                if(splitStrArr.length >= 2){
                    String index_1_str = splitStrArr[1].trim();

                    String[] indedx_1_BlockSplit_Arr = index_1_str.split(" ");

                    if(indedx_1_BlockSplit_Arr != null && indedx_1_BlockSplit_Arr.length > 1){

                        matchFistStr =  indedx_1_BlockSplit_Arr[0].trim();
                    }
                }


                return matchFistStr;



            }


            //  获取 匹配字符串 前面的那个字符串
            String getLastStringBeforeKey(String keyStr , String rawStr ){
            	
                String matchFistStr = null ;
                if(keyStr == null ){

                    System.out.println("当前 从 Html解析的 getLastStringBeforeKey  往前取得字符串  参数 keyStr == null ! 请检查");
                    return matchFistStr;
                }
                if(rawStr == null ){

                    System.out.println("当前 从 rawStr 解析的 getLastStringBeforeKey 往前取得字符串  参数 rawStr == null ! 请检查");
                    return matchFistStr;
                }



                if(!rawStr.contains(keyStr) && !keyStr.contains(".") ){

                    if(rawStr.length() > 100){
                        System.out.println("getLastStringBeforeKey 当前参数  keyStr 不包含正则表达式的点. 同时  keyStr="+keyStr+" 并不包含在 rawStr  请检查! rawStr.length="+ rawStr.length()+" ");
                    } else{
                        System.out.println("getLastStringBeforeKey 当前参数  keyStr 不包含正则表达式的点. 同时  keyStr="+keyStr+" 并不包含在 rawStr  请检查! rawStr="+rawStr+"");

                    }

                    return matchFistStr;
                }


                String[] splitStrArr = rawStr.split(keyStr);

             

                if(splitStrArr != null && splitStrArr.length < 2){
                    if(splitStrArr.length == 1){
                        System.out.println("当前解析 keyStr=【"+keyStr+"】 splitStrArr.length="+splitStrArr.length +" Arr[0]="+splitStrArr[0]);
                    }

                }

                if(splitStrArr.length >= 2){
                    String index_1_str = splitStrArr[splitStrArr.length-2].trim();  // 前面的数字是存在倒数第二个item中

                    String[] indedx_1_BlockSplit_Arr = index_1_str.split(" ");

                    if(indedx_1_BlockSplit_Arr != null && indedx_1_BlockSplit_Arr.length > 1){

                        matchFistStr =  indedx_1_BlockSplit_Arr[indedx_1_BlockSplit_Arr.length-1].trim();
                    }
                }


                return matchFistStr;


            	
            	
            }
            
            // 获取匹配字符串 后面的那个字符
            String getLastStringAfterKey(String keyStr , String rawStr ){
                String matchFistStr = null ;
                if(keyStr == null ){

                    System.out.println("当前 从 Html解析的 getFirstStringAfterKey  参数 keyStr == null ! 请检查");
                    return matchFistStr;
                }
                if(rawStr == null ){

                    System.out.println("当前 从 rawStr 解析的 getFirstStringAfterKey  参数 rawStr == null ! 请检查");
                    return matchFistStr;
                }



                if(!rawStr.contains(keyStr) && !keyStr.contains(".") ){

                    if(rawStr.length() > 100){
                        System.out.println("getFirstStringAfterKey 当前参数  keyStr 不包含正则表达式的点. 同时  keyStr="+keyStr+" 并不包含在 rawStr  请检查! rawStr.length="+ rawStr.length()+" ");
                    } else{
                        System.out.println("getFirstStringAfterKey 当前参数  keyStr 不包含正则表达式的点. 同时  keyStr="+keyStr+" 并不包含在 rawStr  请检查! rawStr="+rawStr+"");

                    }

                    return matchFistStr;
                }


                String[] splitStrArr = rawStr.split(keyStr);

                if(splitStrArr.length >= 2){
                    System.out.println();
                    System.out.println("当前 关键字 keyStr="+keyStr+" 在 rawStr 中存在 "+(splitStrArr.length -1) +"个 请注意唯一性!");
               
                    for (int i = 0; i < splitStrArr.length; i++) { 
                        System.out.println(" 关键字 "+keyStr+"["+i+"_"+splitStrArr.length+"] = "+splitStrArr[i]+"   注意唯一性!");
    		   
    				   }
                }

                if(splitStrArr != null && splitStrArr.length < 2){
                    if(splitStrArr.length == 1){
                        System.out.println("当前解析 keyStr=【"+keyStr+"】 splitStrArr.length="+splitStrArr.length +" Arr[0]="+splitStrArr[0]);
                    }

                }

                if(splitStrArr.length >= 2){
                    String index_1_str = splitStrArr[splitStrArr.length-1].trim();

                    String[] indedx_1_BlockSplit_Arr = index_1_str.split(" ");

                    if(indedx_1_BlockSplit_Arr != null && indedx_1_BlockSplit_Arr.length > 1){

                        matchFistStr =  indedx_1_BlockSplit_Arr[0].trim();
                    }
                }


                return matchFistStr;



            }
            
            boolean init_ReleateNoteData(File htmlFile, String htmlContent  , ArrayList<String> mHtmlContentList , ReleaseNoteHtmlItem  metaData) {

                String rawText_Html = getTextFromTHML(htmlContent);

/*                System.out.println("=============Html===========");
                System.out.println();
                System.out.println(htmlContent);
                System.out.println();
                System.out.println();
                System.out.println("=============rawText_Html===========");
                System.out.println();
               System.out.println(rawText_Html);
                System.out.println();
                System.out.println();*/

                //  ================================= 检测开头关键字  Begin =======================================================
                System.out.println("═════════Log1════════════ 起始 KeyStr[1] 关键字 搜索匹配 Log Begin ═════════Log1════════════");
                int mBegin_Key_Index = 1 ;
                //  获取  在  指定 关键字 后面的 那个字符串值 非空格
                String mTag_JOB_NAME = "JOB NAME";
                String mValue_JOB_NAME =   getFirstStringAfterKey(mTag_JOB_NAME,rawText_Html);
                System.out.println((mBegin_Key_Index++)+"_getFirstStringAfterKey_【"+mTag_JOB_NAME+"】_"+mValue_JOB_NAME);


                String mTag_BUILD_TARGET = "BUILD TARGET";
                String mValue_BUILD_TARGET =   getFirstStringAfterKey(mTag_BUILD_TARGET,rawText_Html);
                System.out.println((mBegin_Key_Index++)+"_getFirstStringAfterKey_【"+mTag_BUILD_TARGET+"】_"+mValue_BUILD_TARGET);


                String mTag_MANIFEST_BRANCH = "MANIFEST BRANCH";
                String mValue_MANIFEST_BRANCH  =   getLastStringAfterKey(mTag_MANIFEST_BRANCH,rawText_Html);
                System.out.println((mBegin_Key_Index++)+"_getFirstStringAfterKey_【"+mTag_MANIFEST_BRANCH+"】_"+mValue_MANIFEST_BRANCH);


                String mTag_MANIFEST_FILE = "MANIFEST FILE";
                String mValue_MANIFEST_FILE  =   getLastStringAfterKey(mTag_MANIFEST_FILE,rawText_Html);
                System.out.println((mBegin_Key_Index++)+"_getFirstStringAfterKey_【"+mTag_MANIFEST_FILE+"】_"+mValue_MANIFEST_FILE);




                String mTag_MANIFEST_URL = "MANIFEST URL";
                String mValue_MANIFEST_URL  =   getLastStringAfterKey(mTag_MANIFEST_URL,rawText_Html);
                System.out.println((mBegin_Key_Index++)+"_getFirstStringAfterKey_【"+mTag_MANIFEST_URL+"】_"+mValue_MANIFEST_URL);
                String mValue_MANIFEST_URL_Android_Version = "null";
                if(mValue_MANIFEST_URL.contains("/")){
                    mValue_MANIFEST_URL_Android_Version =   mValue_MANIFEST_URL.substring(mValue_MANIFEST_URL.lastIndexOf("/")+1 , mValue_MANIFEST_URL.length());
                    mValue_MANIFEST_URL_Android_Version = mValue_MANIFEST_URL_Android_Version.replace(".git","").toUpperCase();
                }




                String mTag_SOFTWARE_BUILD_ID = "SOFTWARE BUILD ID . . REV."; //""SOFTWARE BUILD ID ( + REV)"; 使用.来代替 小括号 大括号 + 加号
                String mValue_SOFTWARE_BUILD_ID  =   getFirstStringAfterKey(mTag_SOFTWARE_BUILD_ID,rawText_Html);
                System.out.println((mBegin_Key_Index++)+"_getFirstStringAfterKey_【"+mTag_SOFTWARE_BUILD_ID+"】_"+mValue_SOFTWARE_BUILD_ID);


                String mTag_Modem_Release_Notes= "Modem Release Notes"; //""Modem Release Notes 查询芯片型号"; 使用.来代替 小括号 大括号 + 加号
                String mValue_Modem_Release_Notes  =   getFirstStringAfterKey(mTag_Modem_Release_Notes,rawText_Html);
                System.out.println((mBegin_Key_Index++)+"_getFirstStringAfterKey_【"+mTag_Modem_Release_Notes+"】_"+mValue_Modem_Release_Notes);


                //  ======================================== 指定长度  检测   Begin ========================================

                System.out.println("═════════Log2════════════ 起始 KeyStr[1] 匹配 空格Count[2] Log Begin  ═════════Log2════════════");


                //___1____ repo init -u【1】ssh://gerrit.mot.com:29418/home/repo/dev/platform/android/platform/manifest/s.git【2】-b【3】refs/tags/T1TGN33.60-59-GENEVN-SHA1【4】-m【5】sha1_embedded_manifest.xml【6】--repo-url=ssh://gerrit.mot.com/home/repo/dev/platform/android/repo.git【7】--repo-branch=mot【8】
                int mEnd_Key_Index = 1 ;
                String mTag_End_repo_init = "repo init ";
                String mValue_End_repo_init  =   getDirectXStringAfterKey(mTag_End_repo_init,rawText_Html,false,8);
                if(mValue_End_repo_init != null){
                    mValue_End_repo_init = mTag_End_repo_init+mValue_End_repo_init;
                }
                System.out.println((mEnd_Key_Index++)+"_getDirectXStringAfterKey_【"+mTag_End_repo_init+"】_"+mValue_End_repo_init);
                String mValue_End_repo_init_fixed = fixed_repo_url(mValue_End_repo_init,  mValue_MANIFEST_BRANCH, mValue_MANIFEST_FILE ); // 替换 -b  和 -m 的 参数
                System.out.println((mEnd_Key_Index)+"_1"+"_fixed_repo_url="+mValue_End_repo_init_fixed);

                //  motorola/build/bin/build_device.bash   // 截取
                //___2____ 
                //Vendor  motorola/build/bin/build_device.bash -b【1】]nightly【2】-p【3】xxxx【4】-g【5】-jX【6】-M【7】<path【8】to【9】MSI【10】workspace>【11】-D【12】mt-r1【13】
                //Msi  motorola/build/bin/build_device.bash -b[1]nightly[2]-p[3]aion_g[4]-g[5]-jX[6]

                //  motorola/build/bin/build_device.bash -b   // 截取
                //___2____ 
                // Vendor  motorola/build/bin/build_device.bash -b nightly【1】-p【2】xxxx【3】-g【4】-jX【5】-M【6】<path【7】to【8】MSI【9】workspace>【10】-D【11】mt-r1【12】
                //Msi motorola/build/bin/build_device.bash -b nightly[1]-p[2]aion_g[3]-g[4]-jX[5]

                
                //  motorola/build/bin/build_device.bash -b   // 截取
                //___2___  motorola/build/bin/build_device.bash[1]-b[2]nightly[3]-p[4]mona[5]-g[6]-j48[7]
                
                
                String mTag_End_build_device= "motorola/build/bin/build_device.bash -b";
                String mValue_End_build_device  = "";
                if(isVendor_2){
                    mValue_End_build_device  =   getDirectXStringAfterKey(mTag_End_build_device,rawText_Html,false,12);
                    if(mValue_End_build_device != null && mValue_End_build_device.contains(" NOTE:")) {
                	// -b nightly -p xxxa -g -j48 NOTE: If any gsync issues, please review 
                    	mValue_End_build_device = mValue_End_build_device.substring(0,mValue_End_build_device.indexOf(" NOTE:"));
                    }
                
                } else {
                    mValue_End_build_device  =   getDirectXStringAfterKey(mTag_End_build_device,rawText_Html,false,5);
                }

                if(mValue_End_build_device != null){
                    mValue_End_build_device = mTag_End_build_device+" "+mValue_End_build_device;
                }
                System.out.println((mEnd_Key_Index++)+"_getDirectXStringAfterKey_【"+mTag_End_build_device+"】_"+mValue_End_build_device);




                //___3____ RELEASE DATE	Wed[1]Ap[2]19[3]07:01:09[4]UTC[5]2023[6]
                String mTag_End_Release_Date= "RELEASE DATE";
                String mValue_End_Release_Date  =   getDirectXStringAfterKey(mTag_End_Release_Date,rawText_Html,false,6);
                System.out.println((mEnd_Key_Index++)+"_getDirectXStringAfterKey_【"+mTag_End_Release_Date+"】_"+mValue_End_Release_Date);

                //  ========================================  参数计算    Begin ========================================

                System.out.println("═════════Log3════════════ 动态计算参数  Log Begin  ═════════Log3════════════");

                product_name_1 = mValue_BUILD_TARGET ;
                String device_shell_name = product_name_1;
                if(product_name_1.contains("_")){
                    device_shell_name = product_name_1.substring(0,product_name_1.indexOf("_"));
                }


                isVendor_2 =   isStringContainInList("Vendor Build",mHtmlContentList)  || isStringContainInList("VENDOR BUILD",mHtmlContentList) || isStringContainInList("Vendor Side",mHtmlContentList) || isStringContainInList("VENDOR SIDE",mHtmlContentList) || isStringContainInList("VENDOR RELEASE VERSION",mHtmlContentList) ;

                isMerge_2 =   isStringContainInList("path to MSI workspace",mHtmlContentList) && isStringContainInList("path to VENDOR workspace",mHtmlContentList)   ; 

                System.out.println("isMerge_A1  <path to MSI workspace>    flag = "+ isStringContainInList("<path to MSI workspace>",mHtmlContentList));
                System.out.println("isMerge_A2  <path to VENDOR workspace> flag = "+ isStringContainInList("<path to VENDOR workspace>",mHtmlContentList));

                

                isMainLineBranch_3 = !mValue_MANIFEST_BRANCH.contains("stable");  // 不包含 stable 字样 那么 就是 main线

                version_identify_4 =  mValue_SOFTWARE_BUILD_ID;

                timeStamp_5 = timestamp_yyyyMMddHHmmss;

                isQcomProduct_6 = isQcomProduct(rawText_Html);



                int mDynic_Key_Index = 1 ;
                
                System.out.println((mDynic_Key_Index++)+"_produce_name_1_【"+ product_name_1 +"】");
                System.out.println((mDynic_Key_Index++)+"_isVendor_2_【"+isVendor_2+"】 ");
                System.out.println((mDynic_Key_Index++)+"_isMergeCode_2_【"+isMerge_2+"】 ");

                System.out.println((mDynic_Key_Index++)+"_isMainLineBranch_3_【"+isMainLineBranch_3+"】");
                System.out.println((mDynic_Key_Index++)+"_version_identify_4_【"+version_identify_4+"】");
                System.out.println((mDynic_Key_Index++)+"_timeStamp_5_【"+timeStamp_5+"】");
                System.out.println((mDynic_Key_Index++)+"_SocVendor_6_【"+(isQcomProduct_6?"Qcom":"Mtk")+"】");
                System.out.println((mDynic_Key_Index++)+"_Soc_7_【"+mValue_Modem_Release_Notes+"】");


                System.out.println("═════════Log4════════════ 动态专配Result Log Begin  ═════════Log4════════════");

                if(product_name_1 == null ||  version_identify_4 == null){
                    System.out.println("当前文件" +mrawReleaseNoteHtmlFile.getName()+" 无法读取到指定的输入数据! 解析失败请检查!");
                    is_inputHtml_Avaliable = false;
                    return  false;
                }

                String productName = product_name_1;

                HashMap<String,String> valueMap = new   HashMap<String,String>();
                valueMap.put("productname" , productName);



                // 写入文件 zukgit
                int mResultValue_Index = 1;
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_product_name       =  " +mValue_BUILD_TARGET);
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_device_shell_name  =  " +device_shell_name);
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_android_version    =  " +getAndroidVersionTip(mValue_MANIFEST_URL_Android_Version));
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_msi_vendor_merge_code =  " +mValue_BUILD_TARGET+"_"+(isVendor_2?(isMerge_2?"Merge_Code":"Vendor_Code"):"Msi_Code"));
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_soc_vendor_name    =  " +(isQcomProduct_6?"Qcom":"Mtk"));
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_code_line_type     =  " +(isMainLineBranch_3?"MainLine":"StableLine"));



                product_txt_List.add((getPadding2(mResultValue_Index++))+"_soc_name           =  " + mValue_Modem_Release_Notes);
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_job_name           =  " +mValue_JOB_NAME);
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_identify           =  " +mValue_SOFTWARE_BUILD_ID);
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_ReleaseDate        =  " +getChineseDateTip(mValue_End_Release_Date));
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_manifest_branch    =  " +mValue_MANIFEST_BRANCH);
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_manifest_xmlfile   =  " +mValue_MANIFEST_FILE);
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_manifest_url       =  " +mValue_MANIFEST_URL);

                if(isVendor_2){
                    product_txt_List.add((getPadding2(mResultValue_Index++))+"_vendor_init        =  " +mValue_End_repo_init);
                    product_txt_List.add((getPadding2(mResultValue_Index++))+"_vendor_init_fixed  =  " +mValue_End_repo_init_fixed);
                    product_txt_List.add((getPadding2(mResultValue_Index++))+"_vendor_build       =  " +mValue_End_build_device);

                }else{
                    product_txt_List.add((getPadding2(mResultValue_Index++))+"_msi_init           =  " +mValue_End_repo_init);
                    product_txt_List.add((getPadding2(mResultValue_Index++))+"_msi_init_fixed     =  " +mValue_End_repo_init_fixed);
                    product_txt_List.add((getPadding2(mResultValue_Index++))+"_msi_build          =  " +mValue_End_build_device);
                }



                // -------------------------------   【 Modem Release Info 信息】-----------------------------
//                product_txt_List.add("");
//
//                product_txt_List.add(getSchema("【"+productName+"】  Modem Release Info 信息"));
//                product_txt_List.add(metaData.ModemRelease_MoveHtml_Content );
//                product_txt_List.add("");


                // -------------------------------   【 Manifest    Info 信息】-----------------------------
//                product_txt_List.add("");
//
//                product_txt_List.add(getSchema("【"+productName+"】  Manifest  Info 信息"));
//                product_txt_List.add(metaData.ManifestInfo_MoveHtml_Content  );
//                product_txt_List.add("");



                // -------------------------------   【 BUILD INSTRUCTIONS  Info 信息】-----------------------------
//                product_txt_List.add("");
//
//                product_txt_List.add(getSchema("【"+productName+"】  Build Instructions Info 信息"));
//                product_txt_List.add(metaData.BuildInstruction_MoveHtml_Content  );
//                product_txt_List.add("");






                if(isVendor_2){  // Vendor ---Tip

                    // -------------------------------   【  Vendor Init Info 信息】-----------------------------
                    product_txt_List.add("");
                    product_txt_List.add("");

                    product_txt_List.add(getSchema("【"+productName+" Vendor Init && zshrule_Bankup 】  Vendor Repo Init 初始化 Vendor 命令"));
                    product_txt_List.add("");
                    product_txt_List.add("source /opt/conf/moto.conf "+" && "+ mValue_End_repo_init_fixed+" && " +" repo sync -j2 " +" && "+" repo start --all TEMP " +"&&" +"  zshrule_I9.sh _901_ " +" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");

                    product_txt_List.add("");
                    product_txt_List.add(getSchema("【"+productName+" Vendor Init && Zrule && zshrule_Bankup 】  Vendor Repo Init 初始化 Vendor 命令 && zrule修改命令"));
                    product_txt_List.add("");
                    product_txt_List.add( mValue_End_repo_init_fixed+" && " +" repo sync -j2 " +" && "+" repo start --all TEMP "+" && "+ " zshrule_I9.sh _901_"+" && "+"zrule_apply_G2"+Cur_Batch_End+" @_57 1  2  tip_qcom_mtk"  +" && "+"source /opt/conf/moto.conf "+" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");



                    product_txt_List.add("");
                    product_txt_List.add(getSchema("【"+productName+" Vendor Track Init 】 Vendor Repo Trace Init  初始化 Vendor 命令"));
                    product_txt_List.add("");
                    product_txt_List.add("source /opt/conf/moto.conf "+" && "+ mValue_End_repo_init_fixed+" && " +" repo --trace sync  -cdf  -j2 " +" && "+" repo start --all TEMP " +" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");


                    product_txt_List.add("");
                    product_txt_List.add(getSchema("【"+productName+" Vendor Track Init && Zrule  】 Vendor Repo Trace Init  初始化 Vendor 命令 && Zrule修改命令 "));
                    product_txt_List.add("");
                    product_txt_List.add( mValue_End_repo_init_fixed+" && " +" repo --trace sync  -cdf  -j2 " +" && "+" repo start --all TEMP "+" && "+"zrule_apply_G2"+Cur_Batch_End+" @_57 1  2  tip_qcom_mtk"  +" && "+"source /opt/conf/moto.conf "+" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");


                    product_txt_List.add("");

                    product_txt_List.add(getSchema("【"+productName+" Vendor Rebuild 】 "));
                    product_txt_List.add("");
                    product_txt_List.add("source /opt/conf/moto.conf "+"  && "+mValue_End_repo_init_fixed+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");

                    product_txt_List.add("");


                    product_txt_List.add(getSchema("【"+productName+" Vendor Rebuild  && Zrule 】  && Zrule修改命令"));
                    product_txt_List.add("");
                    product_txt_List.add("zrule_apply_G2"+Cur_Batch_End+" @_57 1  2  tip_qcom_mtk"+" && "+"source /opt/conf/moto.conf "+"  && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");

                    product_txt_List.add("");

                } else {   // MSI ---Tip

                    // -------------------------------   【  MSI Init Info 信息】-----------------------------
                    product_txt_List.add("");
                    product_txt_List.add("");

                    product_txt_List.add(getSchema("【"+productName+" MSI Init 】 MSI Repo Init 初始化 MSI 命令"));
                    product_txt_List.add("");
                    product_txt_List.add(mValue_End_repo_init_fixed+" && "+ " repo sync -j2 " +" && "+" repo start --all TEMP " +" && "+" zshrule_I9.sh _901_ "+" && "+"source /opt/conf/moto.conf "+" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");
                    product_txt_List.add("");

                    product_txt_List.add(getSchema("【"+productName+" MSI Init && Zrule 】 MSI Repo Init 初始化 MSI 命令  && Zrule修改命令 "));
                    product_txt_List.add("");
                    product_txt_List.add(mValue_End_repo_init_fixed+" && "+ " repo sync -j2 " +" && "+" repo start --all TEMP " +" && "+"  zshrule_I9.sh _901_ " +" && "+"zrule_apply_G2"+Cur_Batch_End+" @_57 1  2  tip_qcom_mtk"+" && "+"source /opt/conf/moto.conf "+" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");



                    product_txt_List.add("");
                    product_txt_List.add(getSchema("【"+productName+" MSI-Track Init 】  MSI Repo Trace Init 初始化 MSI 命令"));
                    product_txt_List.add("");
                    product_txt_List.add("source /opt/conf/moto.conf "+" && "+ mValue_End_repo_init_fixed+" && "+ " repo --trace sync  -cdf  -j2 " +" && "+" repo start --all TEMP " +" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");
                    product_txt_List.add("");

                    product_txt_List.add(getSchema("【"+productName+" MSI-Track Init && Zrule  】  MSI Repo Trace Init 初始化 MSI 命令  && Zrule修改命令 "));
                    product_txt_List.add("");
                    product_txt_List.add(mValue_End_repo_init_fixed+" && "+ " repo --trace sync  -cdf  -j2  " +" && "+" repo start --all TEMP " +" && "+"zrule_apply_G2"+Cur_Batch_End+" @_57 1  2  tip_qcom_mtk"+" && "+"source /opt/conf/moto.conf "+" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");

                    product_txt_List.add("");


                    product_txt_List.add(getSchema("【"+productName+" MSI Rebuild 】 "));
                    product_txt_List.add("");
                    product_txt_List.add("source /opt/conf/moto.conf "+" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");

                    product_txt_List.add("");
                    product_txt_List.add(getSchema("【"+productName+" MSI Rebuild && Zrule  】 &&  Zrule修改命令 "));
                    product_txt_List.add("");
                    product_txt_List.add("zrule_apply_G2"+Cur_Batch_End+" @_57 1  2  tip_qcom_mtk"+" && "+"source /opt/conf/moto.conf "+" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");



                    product_txt_List.add("");
                    product_txt_List.add("");
                    product_txt_List.add("");
                    product_txt_List.add("");

                }



                // -------------------------------   【 编译 apk jar so bin 命令】-----------------------------
                product_txt_List.add("");
                product_txt_List.add(getSchema("【"+productName+"】 【 编译 apk jar so bin 命令】"));

                product_txt_List.add("【 Settings.apk   mmm Vednor_Code/packages/apps/Settings " + productName + "" + "】");
                product_txt_List.add(buildSettingsApk(valueMap));
                product_txt_List.add("");

                product_txt_List.add("【 Settings.apk   make Settings  [/packages/apps/Settings] " + productName + "" + "】");
                product_txt_List.add(buildSettingsApk_make(valueMap));
                product_txt_List.add("");

                product_txt_List.add("【 framework.jar  frameworks/base " + productName + "-userdebug" + "】");
                product_txt_List.add(buildFrameworkJar(valueMap));
                product_txt_List.add("");
                product_txt_List.add(buildFrameworkJar_make(valueMap));
                product_txt_List.add("");
                product_txt_List.add("【 framework-res   frameworks/base/core/res  " + productName + "-userdebug" + "】");
                product_txt_List.add(buildFrameworkRes_make(valueMap));
                product_txt_List.add("");
                product_txt_List.add("【 framework-services [system_server] services.art  mmma frameworks/base/services  " + productName + "-userdebug" + "】");
                product_txt_List.add(buildFrameworkService_make(valueMap));


                product_txt_List.add("");
                product_txt_List.add("【 wifi-services.jar " + productName + "-userdebug" + "】");
                product_txt_List.add(buildWifiServiceJar(valueMap));

                product_txt_List.add("");
                product_txt_List.add("【 bin/wpa_supplicant " + productName + "-userdebug" + "】");
                product_txt_List.add(buildWpaSupplicant(valueMap));
                product_txt_List.add("push命令:  adb root && adb remount && adb push ./wpa_supplicant  /vendor/bin/hw/ && adb reboot ");
                product_txt_List.add("");



                product_txt_List.add("【 mtk/SarControlService " + productName + "-userdebug" + "】");
                product_txt_List.add("");
                product_txt_List.add(" export PATH=/apps/android/python-2.7.6-x64/bin:$PATH  && export PATH=/apps/android/perl-5.1aclmsx8.4-x64/bin:$PATH &&  source build/envsetup.sh &&  source /opt/conf/moto.conf  && lunch "+productName+"-userdebug  && cd ./motorola/modem/mtk/SarControl/SarControlService &&  mm ");
                product_txt_List.add("");
                product_txt_List.add("zzfile_3.sh   ./out/target/product/"+device_shell_name+"/system/priv-app/MtkSarControlService.apk");
                product_txt_List.add("");
                product_txt_List.add("");

                product_txt_List.add("【 mtk/SarStatusDisplay.apk " + productName + "-userdebug" + "】");
                product_txt_List.add("");
                product_txt_List.add("cd AOSP_Root &&  export PATH=/apps/android/python-2.7.6-x64/bin:$PATH  && export PATH=/apps/android/perl-5.1aclmsx8.4-x64/bin:$PATH &&  source build/envsetup.sh &&  source /opt/conf/moto.conf  && lunch "+productName+"-userdebug && cd  ./motorola/modem/mtk/SarControl/SarStatusDisplay &&  mm ");
                product_txt_List.add("");
                product_txt_List.add("zzfile_3.sh   out/target/product/"+device_shell_name+"/system/priv-app/MtkSarControlService/MtkSarControlService.apk");
                product_txt_List.add("");
                product_txt_List.add("");


                product_txt_List.add("【 MotoWifiMetrics "+productName+"-userdebug】");
                product_txt_List.add("cd AOSP_Root &&  export PATH=/apps/android/python-2.7.6-x64/bin:$PATH  && export PATH=/apps/android/perl-5.1aclmsx8.4-x64/bin:$PATH &&  source build/envsetup.sh &&  source /opt/conf/moto.conf  && lunch "+productName+"-userdebug && cd ./motorola/packages/apps/MotoWifiMetrics &&  mm ");
                product_txt_List.add("");
                product_txt_List.add("zzfile_3.sh   ./out/target/product/"+device_shell_name+"/system_ext/priv-app/MotoWifiMetrics");

                product_txt_List.add("");
                product_txt_List.add("【 mtk/sarwifi " + productName + "-userdebug" + "】");
                product_txt_List.add(" export PATH=/apps/android/python-2.7.6-x64/bin:$PATH  && export PATH=/apps/android/perl-5.1aclmsx8.4-x64/bin:$PATH &&  source build/envsetup.sh &&  source /opt/conf/moto.conf  && lunch "+productName+"-userdebug  &&   cd ./vendor/mediatek/proprietary/hardware/connectivity/wlan/sarwifi/service &&  mm   ");


                product_txt_List.add("");
                product_txt_List.add("【 qcom/libmdmcutback " + productName + "-userdebug" + "】");
                product_txt_List.add(" export PATH=/apps/android/python-2.7.6-x64/bin:$PATH  && export PATH=/apps/android/perl-5.1aclmsx8.4-x64/bin:$PATH &&  source build/envsetup.sh &&  source /opt/conf/moto.conf  && lunch "+productName+"-userdebug  &&   make libmdmcutback | tee build_libmdmcutback.log     ");
                product_txt_List.add("");
                product_txt_List.add("zzfile_3.sh   ./out/target/product/"+device_shell_name+"/vendor/lib64/libmdmcutback.so");
                product_txt_List.add("zzfile_3.sh   ./out/target/product/"+device_shell_name+"/vendor/lib/libmdmcutback.so");
                product_txt_List.add("cd     ./out/target/product/"+device_shell_name+"/vendor/lib64/ && fex -u  libmdmcutback.so");
                product_txt_List.add("cd     ./out/target/product/"+device_shell_name+"/vendor/lib/   && fex -u  libmdmcutback.so");



                product_txt_List.add("");
                product_txt_List.add("【单独拉取 "+productName+" Qcom_nonhlos获取 about.html】");
                product_txt_List.add("cd ./vendor/qcom/nonhlos/ && find . -name \"*Ver_Info*\" && find . -name \"*about.html*\"      ## 搜索 about.html 正确分支的命令");
                product_txt_List.add("./AAA/common/build/Ver_Info.txt");
                product_txt_List.add("./111/common/build/about.html");
                product_txt_List.add("./AAA/common/build/about.html     ##与 Ver_Info同目录 是正确的 about.html   repo sync 此目录 ");
                product_txt_List.add("./222/common/build/about.html");
                product_txt_List.add("");
                product_txt_List.add("source /opt/conf/moto.conf  &&  "+ mValue_End_repo_init+" && "+" repo sync vendor/qcom/nonhlos/AAA/common ");



                // -------------------------------   【  Git Command Tip 命令提示】-----------------------------


                product_txt_List.add("");
                product_txt_List.add(getSchema("【"+productName+"】  Git Command Tip 命令提示"));
                product_txt_List.add("git am **.patch                          【打patch】 ");
                product_txt_List.add("git am *.patch  --whitespace=fix         【修复有空格错误的patch提交】");
                product_txt_List.add("git fetch origin mr-2021-q3/br:TEMP_A    【拉取远程分支到本地 TEMP_A分支】");
                product_txt_List.add("git pull --rebase origin mq-2020-q4/bq   【拉取远程分支 rebase 】");
                product_txt_List.add("repo forall -c  git reset --hard HEAD~3  【所有git 回退到上三个版本】");
                product_txt_List.add("repo forall -c git clean -nfdx           【清理项目 删除 untracked files&dir 以及gitignore标记的文件目录】  ");
                product_txt_List.add("repo forall -c git clean -nfd            【清理项目 删除 untracked files&dir 】  ");

                product_txt_List.add("mkdir msi && cd msi                      【创建目录并进入】 ");
                product_txt_List.add("cp -fr ../zukgit.txt  ./                 【复制上一目录的文件到当前文件夹】 ");
                product_txt_List.add("chmod 777 -R ./F0_repo_init.sh           【对当前 sh 文件赋权】 ");
                product_txt_List.add("grep -rins \"zukgit\" .                  【全局搜索文件内容中包含 zukgit 的文件】 ");
                product_txt_List.add("find . -name \"*zukgit*\" .              【全局查找文件名称包含 zukgit 的文件】 ");
                product_txt_List.add("df -h                                    【查看磁盘文件大小】 ");
                product_txt_List.add("cd /home && ls -l                        【查看当前工作站用户】");

                product_txt_List.add("");



                product_txt_List.add(getSchema("【 特殊文件 Path 提示"));
                product_txt_List.add("【1. framework/overlay/value/value.xml 资源覆盖版本路径】");
                product_txt_List.add("zzfile_3"+Cur_Batch_End+" " +" ./vendor/moto/"+device_shell_name+"/mssi/overlay/frameworks/base/core/res/res/values");
                product_txt_List.add("【2. prop覆盖宏配置文件 】");
                product_txt_List.add("zzfile_3"+Cur_Batch_End+" " +" ./vendor/moto/"+device_shell_name+"/"+device_shell_name+"_retail/oem_reteu_"+device_shell_name+"/contents/oem.prop");
                product_txt_List.add("【3. out/framework.jar 文件 】");
                product_txt_List.add("zzfile_3"+Cur_Batch_End+" " +" ./out/target/product/"+device_shell_name+"/system/framework/framework.jar");
                product_txt_List.add("【4. out/wifi-service.jar  】");
                product_txt_List.add("zzfile_3"+Cur_Batch_End+" " +" ./out/target/product/"+device_shell_name+"/system/framework/wifi-service.jar");
                product_txt_List.add("【5. Settings.apk(Q及以上) 文件 】");
                product_txt_List.add("zzfile_3"+Cur_Batch_End+" " +" ./out/target/product/"+device_shell_name+"/product/priv-app/Settings/Settings.apk");
                product_txt_List.add("【6. framework/base/wifi/java/android/net/wifi 路径  wifimanager 】");
                product_txt_List.add("zzfile_3"+Cur_Batch_End+" " +" ./frameworks/base/wifi/java/android/net/wifi");
                product_txt_List.add("【7. framework/opt/wifi/service/wifi 路径 wifiservice 】");
                product_txt_List.add("zzfile_3"+Cur_Batch_End+" " +" ./frameworks/opt/net/wifi/service/java/com/android/server/wifi");
                product_txt_List.add("");
                product_txt_List.add("");
                product_txt_List.add(getSchema("【 AOSP 根目录 快速查询命令提示】"));
                product_txt_List.add("【1. 查看当前AOSP对应的硬件产品名称 vhw.xml 中配置的 device_name 以及sar对应的 radioid区域码 】 以及搜索关键字 radio/.range 能查看到 产品所有的出货地区码(NA PRC LATAM DCM KDDI LATAM EMEA BR INDIA EUAPEM ALL JAPAN VZW ROW) 等");
               
                product_txt_List.add("cd ./device && grep -rins \"device name=\" . | grep vhw");
                product_txt_List.add("gedit vhw.xml  && 搜索 关键字 radio/.range");
                product_txt_List.add("");
                product_txt_List.add("");
                product_txt_List.add("【2. 查看查看高通 Build_ID ,在高通项目的 AOSP/vendor/qcom/nonhlos编译会审生成 Non-HLOS  在改目录编译完成时会产出 Ver_Info.txt , 该 Ver_Info.txt  标注了 高通项目的 Build_ID  ");

                product_txt_List.add("cd ./vendor/qcom/nonhlos  && find -name \"*Ver_Info*\"  ");
                product_txt_List.add("gedit Ver_Info.txt");
                product_txt_List.add("");
                product_txt_List.add("");
                
                product_txt_List.add("");
                product_txt_List.add(getSchema("【"+productName+"】  Git Sync Error  命令提示"));
                product_txt_List.add("一.unable to read sha1 file of xx 问题的处理");
                product_txt_List.add("  1.【  repo --trace sync  -cdf  -j2  】  ___ 查看repo的动作 看哪一个 git 分支报错");
                product_txt_List.add("   如:cd /Code1/Vendor2/kernel/prebuilts/5.4/arm64 : git read-tree --reset -u -v HEAD 1>| 2>|  报错");
                product_txt_List.add("   说明 路径/kernel/prebuilts/5.4/arm64 报错");
                product_txt_List.add("  2.【  rm -fr .repo/projects/kernel/prebuilts/5.4/arm64.git   】  ___ 删除.repo 下文件");
                product_txt_List.add("  3.【  rm -fr .repo/project-objects/home/repo/dev/platform/android/kernel/prebuilts/5.4/arm64.git   】  ___ 删除.repo 下文件");
                product_txt_List.add("  4.【  repo init xxx  &&  repo --trace sync  -cdf  -j2   】 重新更新代码  ");
                product_txt_List.add("");
                product_txt_List.add("二. error: Exited sync due to fetch errors && would clobber existing tag 拉取失败问题处理 ");
                product_txt_List.add("  1.【   repo forall -c git fetch --tags -f  && repo --trace sync  -cdf  -j2  】  ___ 更新远程代码");
                product_txt_List.add("");
                product_txt_List.add("三. 拉取远程分支到本地 到本地新分支的操作 ");
                product_txt_List.add("  1.【 git branch -a > a.txt   】  【查看当前的远程分支】");
                product_txt_List.add("  1.【 git fetch origin mr-2021-q3/br:TEMP_A  】  【拉取远程分支到本地 TEMP_A分支】");



                product_txt_List.add("");
                product_txt_List.add("");
                product_txt_List.add(getSchema("【 拉取新分支 提示】"));
                product_txt_List.add("");
                product_txt_List.add("git branch -a > a.txt");
                product_txt_List.add("存在分支  remotes/origin/ms-r2-stable9/prods-mtk");
                product_txt_List.add("git fetch origin ms-r2-stable9/prods-mtk:Temp_s9             ## 拉取远程分支 ms-r2-stable9  到本地分支 Temp_s9 分支branch");
                product_txt_List.add("git push origin Temp_s9:refs/for/ms-r2-stable9/prods-mtk     ## Temp_s9 上传到远程分支  remotes/origin/ms-r2-stable9/prods-mtk");
                product_txt_List.add("");
                product_txt_List.add("");
                product_txt_List.add("");
                product_txt_List.add("存在分支  remotes/origin/bt");
                product_txt_List.add("git fetch origin bt:TEMP_bt            ## 拉取远程分支 remotes/origin/bt 到本地新建分支 TEMP_bt");
                product_txt_List.add("git push origin TEMP_bt:refs/for/bt    ## TEMP_bt 上传到远程分支 remotes/origin/bt");
                product_txt_List.add("");
                product_txt_List.add("");
                product_txt_List.add("");
                product_txt_List.add("1.AOSP根目录执行 2.批量重新拉取Vendor ||  Msi 代码 ");
                product_txt_List.add("repo forall -c git clean -dxf  && repo forall -c git checkout .  ; git cherry-pick --abort ; repo forall -c git branch TEMP ;  repo forall -c git checkout TEMP  && source /opt/conf/moto.conf && gsync --no-tag\r\n"	+ "");
                product_txt_List.add("");


                if(isVendor_2){ 
                    product_txt_List.add("1.AOSP根目录执行 2.批量重新拉取Vendor代码 3.【编译填充Msi绝对地址】 4.启动编译(Vendor)!");
                    product_txt_List.add("repo forall -c git clean -dxf  && repo forall -c git checkout .  ; git cherry-pick --abort  ; repo forall -c git branch TEMP ; repo forall -c git checkout TEMP  && source /opt/conf/moto.conf && gsync --no-tag "	+ " && source /opt/conf/moto.conf "+" && "+ mValue_End_repo_init_fixed +" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");
                    product_txt_List.add("");
                    product_txt_List.add("【1.cherry_pick预留】 【2.编译填充Msi绝对地址】 3.批量拉取  4.启动编译(Vendor)!"); 
                    product_txt_List.add("repo forall -c git clean -dxf  && repo forall -c git checkout .  ; git cherry-pick --abort ; repo forall -c git branch TEMP ; repo forall -c git checkout TEMP  && source /opt/conf/moto.conf && gsync --no-tag "	+ " && cd 【cherry_pick预留】  && source /opt/conf/moto.conf "+" && "+ mValue_End_repo_init_fixed +" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");
                    product_txt_List.add("");
                    product_txt_List.add("1.重名命名out kernel_platorm\\out 目录 2.【编译填充Msi绝对地址】3.批量拉取 4.启动编译(Vendor)!"); 
                    product_txt_List.add("mv out  out_"+getTimeStamp()+" ; "+" mv kernel_platform\\out  kernel_platform\\out_"+getTimeStamp()+" ; "+ "repo forall -c git clean -dxf  && repo forall -c git checkout .   ; git cherry-pick --abort ; repo forall -c git branch TEMP ; repo forall -c git checkout TEMP  && source /opt/conf/moto.conf && gsync --no-tag "	+ "  && source /opt/conf/moto.conf "+" && "+ mValue_End_repo_init_fixed +" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");

                    
                } else {
                    product_txt_List.add("1.AOSP根目录执行 2.批量重新拉取Msi代码  3.并启动编译(Msi)!");

                    product_txt_List.add("repo forall -c git clean -dxf  && repo forall -c git checkout . ; git cherry-pick --abort ; repo forall -c git branch TEMP ; repo forall -c git checkout TEMP  && source /opt/conf/moto.conf && gsync --no-tag "	+ " && source /opt/conf/moto.conf "+" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");
                    product_txt_List.add("");
                    product_txt_List.add("1.【cherry_pick预留】 2.批量拉取  3.启动编译(Msi)!"); 
                    product_txt_List.add("repo forall -c git clean -dxf  && repo forall -c git checkout . ; git cherry-pick --abort ; repo forall -c git branch TEMP ; repo forall -c git checkout TEMP  && source /opt/conf/moto.conf && gsync --no-tag "	+ " &&  cd 【cherry_pick预留】 && source /opt/conf/moto.conf "+" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");
                    product_txt_List.add("");
                    product_txt_List.add("1.重名命名out目录 kernel_platform\\out目录  2.批量拉取 3.启动编译(Msi)!"); 
                    product_txt_List.add("mv out  out_"+getTimeStamp()+" ; "+" mv kernel_platform\\out  kernel_platform\\out_"+getTimeStamp()+" ; "+" repo forall -c git clean -dxf  && repo forall -c git checkout .  ; git cherry-pick --abort ; repo forall -c git branch TEMP ; repo forall -c git checkout TEMP  && source /opt/conf/moto.conf && gsync --no-tag "	+ " && source /opt/conf/moto.conf "+" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_"+mValue_BUILD_TARGET+".log");

                }

                
                
                product_txt_List.add("");
                product_txt_List.add("");
                product_txt_List.add(getSchema("【 提交commit命令 提示】"));
                product_txt_List.add("git push origin TEMP:refs/for/【当前分支| 通过 git gui ，gitk  , git branch -vv 查看提交分支】");
                product_txt_List.add("示例01:  git push origin TEMP:refs/for/bp");
                product_txt_List.add("示例02:  git push origin TEMP:refs/for/bp-mtk");
                product_txt_List.add("示例03:  git push origin TEMP:refs/for/bq");
                product_txt_List.add("示例04:  git push origin TEMP:refs/for/br");
                product_txt_List.add("示例05:  git push origin TEMP:refs/for/br-mtk");
                product_txt_List.add("示例06:  git push origin TEMP:refs/for/bs");
                product_txt_List.add("示例07:  git push origin TEMP:refs/for/bs-mtk");
                product_txt_List.add("示例08:  git push origin TEMP:refs/for/prods-mtk");
                product_txt_List.add("示例09:  git push origin TEMP:refs/for/bt");
                product_txt_List.add("示例10:  git push origin TEMP:refs/for/bt-mtk");
                product_txt_List.add("示例11:  git push origin TEMP:refs/for/mt-r1/bt");
                product_txt_List.add("示例12:  git push origin TEMP:refs/for/bs-6450");
                product_txt_List.add("示例13:  git push origin TEMP:refs/for/bs-8450");
                product_txt_List.add("示例14:  git push origin TEMP:refs/for/bs-qc");
                product_txt_List.add("示例15:  git push origin TEMP:refs/for/bu");
                product_txt_List.add("示例16:  git push origin TEMP:refs/for/bu-mtk");
                product_txt_List.add("示例17:  git push origin TEMP:refs/for/prodt-mtk");
                product_txt_List.add("示例18:  git push origin TEMP:refs/for/produ-mtk");
                product_txt_List.add("示例19:  git push origin TEMP:refs/for/prods-mtktc2sp2");
                product_txt_List.add("示例20:  git push origin TEMP:refs/for/bv-mtk");
                product_txt_List.add("示例21:  git push origin TEMP:refs/for/prodv-mtk");
                product_txt_List.add("示例22:  git push origin TEMP:refs/for/bv");
                product_txt_List.add("示例23:  git push origin TEMP:refs/for/prodv-mtktc2sp2");
                product_txt_List.add("示例24:  git push origin TEMP:refs/for/bv-qc");
                product_txt_List.add("示例25:  git push origin TEMP:refs/for/bv-6450");
                product_txt_List.add("示例26:  git push origin TEMP:refs/for/bv-8450");
                product_txt_List.add("示例27:  git push origin TEMP:refs/for/bw-mtk");
                product_txt_List.add("示例28:  git push origin TEMP:refs/for/prodw-mtk");
                product_txt_List.add("示例29:  git push origin TEMP:refs/for/bw");
                product_txt_List.add("示例30:  git push origin TEMP:refs/for/prodw-mtktc2sp2");
                product_txt_List.add("示例31:  git push origin TEMP:refs/for/bw-qc");
                product_txt_List.add("示例32:  git push origin TEMP:refs/for/bw-6450");
                product_txt_List.add("示例33:  git push origin TEMP:refs/for/bw-8450");
                
                product_txt_List.add("");
                product_txt_List.add("");

                System.out.println("═════════════════════════ 已保存当前解析的 ReleaseNote.html produce_name【"+mValue_BUILD_TARGET+"  】  详情调用如下: ═════════════════════════ ");

                String product_tip_file_name = product_name_1 +"_"+(isVendor_2?(isMerge_2?"Merge":"Vendor"):"Msi")+"_"+(isMainLineBranch_3?"Main":"Stable")+"_"+version_identify_4+"_"+timestamp_yyyyMMddHHmmss ;
                product_tip_file_name = product_tip_file_name.replace(" ","");
                mResultProductTipTxtFileName = product_tip_file_name;

                resultTipTxtDir = new File(curDirFile.getAbsoluteFile()+File.separator+"ReleaseNote_ResultTip_"+timestamp_yyyyMMddHHmmss);
                mResultProductTipTxtFile = new File(resultTipTxtDir.getAbsoluteFile()+File.separator+product_tip_file_name+".txt");
              
                if(isMerge_2) {   // 当前是融合仓库 
                	product_txt_List.clear();   // 重新计算融合仓库的参数
                	ArrayList<String> mMergeRepoTxtList = calculMergeRepo( mValue_BUILD_TARGET , device_shell_name ,  mValue_MANIFEST_URL_Android_Version ,
                    		  isVendor_2 ,  isMerge_2 ,  isQcomProduct_6 , isMainLineBranch_3  ,
                    		 mValue_Modem_Release_Notes , mValue_JOB_NAME ,  mValue_SOFTWARE_BUILD_ID   ,  mValue_End_Release_Date ,  mValue_MANIFEST_BRANCH ,
                    		 mValue_MANIFEST_FILE ,  mValue_MANIFEST_URL ,  mValue_End_repo_init ,  mValue_End_repo_init_fixed ,  mValue_End_build_device  , rawText_Html  );
                	
                	product_txt_List.addAll(mMergeRepoTxtList);
                	  resultTipTxtDir = new File(curDirFile.getAbsoluteFile()+File.separator+"ReleaseNote_ResultTip_"+timestamp_yyyyMMddHHmmss);
                      mResultProductTipTxtFile = new File(resultTipTxtDir.getAbsoluteFile()+File.separator+product_tip_file_name+".txt");
                    
                }
                
                
                writeContentToFile(mResultProductTipTxtFile,product_txt_List);



                System.out.println();
                System.out.println();
                System.out.println();
                System.out.println();
                System.out.println();


                return true;
            }

            
            ArrayList<String> calculMergeRepo(String  mValue_BUILD_TARGET ,String device_shell_name , String mValue_MANIFEST_URL_Android_Version ,
            		boolean  isVendor_2 , boolean isMerge_2 , boolean isQcomProduct_6 ,boolean isMainLineBranch_3  ,
            		String mValue_Modem_Release_Notes ,String mValue_JOB_NAME , String mValue_SOFTWARE_BUILD_ID   ,String  mValue_End_Release_Date , String xValue_MANIFEST_BRANCH ,
            		String xValue_MANIFEST_FILE , String xValue_MANIFEST_URL , String mValue_End_repo_init , String xValue_End_repo_init_fixed , String xValue_End_build_device  ,String  rawText_Html  ){
            	ArrayList<String> product_txt_List = new 	ArrayList<String>();
            	
            	
            	
            	int mBegin_Key_Index = 1; 
                String mTag_MANIFEST_BRANCH = "MANIFEST FILE";  //  当前关键字 前面的那个字符串 是我们需要的
                String mValue_MANIFEST_BRANCH  =   getLastStringBeforeKey(mTag_MANIFEST_BRANCH,rawText_Html);
                System.out.println((mBegin_Key_Index++)+"_getLastStringBeforeKey_【"+mTag_MANIFEST_BRANCH+"】_mTemp_Value_MANIFEST_BRANCH = "+mValue_MANIFEST_BRANCH);


                String mTag_MANIFEST_FILE = "MANIFEST GROUP";  // mTag_MANIFEST_FILEMANIFEST GROUP  的取值的前面是  当前关键字 前面的那个字符串 是我们需要的
                String mValue_MANIFEST_FILE  =   getLastStringBeforeKey(mTag_MANIFEST_FILE,rawText_Html);
                System.out.println((mBegin_Key_Index++)+"_getLastStringBeforeKey_【"+mTag_MANIFEST_FILE+"】_mTemp_mValue_MANIFEST_FILE="+mValue_MANIFEST_FILE);




                String mTag_MANIFEST_URL = "MANIFEST BRANCH";
                String mValue_MANIFEST_URL  =   getLastStringBeforeKey(mTag_MANIFEST_URL,rawText_Html);
                System.out.println((mBegin_Key_Index++)+"_getLastStringBeforeKey_【"+mTag_MANIFEST_URL+"】_mTemp_mValue_MANIFEST_URL="+mValue_MANIFEST_URL);
          
                // mValue_End_repo_init_fixed
                //___1____ repo init -u【1】ssh://gerrit.xx.com:29418/home/repo/dev/platform/android/platform/manifest/s.git【2】-b【3】refs/tags/T1TGN33.60-59-GENEVN-SHA1【4】-m【5】sha1_embedded_manifest.xml【6】--repo-url=ssh://gerrit.mot.com/home/repo/dev/platform/android/repo.git【7】--repo-branch=mot【8】
                //___2____ repo init -u【1】ssh://gerrit.xx.com:29418/home/repo/dev/platform/android/platform/manifest/v.git【2】-b【3】refs/tags/VVA35.1-MONA-MONA-G-SHA1【4】-m【5】sha1_embedded_manifest.xml【6】--repo-url=ssh://gerrit.mot.com/home/repo/dev/platform/android/repo.git【7】--repo-branch=mot【8】
                int mEnd_Key_Index = 1 ;
                String mTag_End_repo_init = "repo init ";
                String mTemp_mValue_End_repo_init  =   getDirectXStringAfterKey(mTag_End_repo_init,rawText_Html,false,8);
                if(mTemp_mValue_End_repo_init != null){
                	mTemp_mValue_End_repo_init = mTag_End_repo_init+mTemp_mValue_End_repo_init;
                }
                System.out.println((mEnd_Key_Index++)+"_getDirectXStringAfterKey_【"+mTag_End_repo_init+"】_mTemp_mValue_End_repo_init_fixed="+mValue_End_repo_init);
                String mTemp_mValue_End_repo_init_fixed = fixed_repo_url(mValue_End_repo_init,  mValue_MANIFEST_BRANCH, mValue_MANIFEST_FILE ); // 替换 -b  和 -m 的 参数
                System.out.println((mEnd_Key_Index)+"_1"+"_fixed_repo_url  mTemp_mValue_End_repo_init_fixed ="+mTemp_mValue_End_repo_init_fixed);

                
                // mValue_End_build_device
                String mTag_End_build_device= "motorola/build/bin/build_device.bash -b";
                String mTemp_mValue_End_build_device  = "";
                if(isMerge_2){
                	
                	// motorola/build/bin/build_device.bash -b nightly -p xxx_g -g -j48 -M <path to MSI workspace> -V <path to VENDOR workspace>
                	mTemp_mValue_End_build_device  =   getSpltAStrAndEndWithBStr(mTag_End_build_device,"<path to VENDOR workspace>",rawText_Html);
                
                    System.out.println((mEnd_Key_Index++)+"_getSpltAStrAndEndWithBStr_【"+mTag_End_build_device+"】_ mTemp_mValue_End_build_device = "+mTemp_mValue_End_build_device);

                } 

                if(mTemp_mValue_End_build_device != null){
                	mTemp_mValue_End_build_device = mTag_End_build_device+" "+mTemp_mValue_End_build_device;
                }
                System.out.println((mEnd_Key_Index++)+"_getDirectXStringAfterKey_【"+mTag_End_build_device+"】_"+mTemp_mValue_End_build_device);

                
                


                
            	
                // 写入文件 zukgit
                int mResultValue_Index = 1;
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_product_name       =  " +mValue_BUILD_TARGET);
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_device_shell_name  =  " +device_shell_name);
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_android_version    =  " +getAndroidVersionTip(mValue_MANIFEST_URL_Android_Version));
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_msi_vendor_merge_code =  " +mValue_BUILD_TARGET+"_"+(isVendor_2?(isMerge_2?"Merge_Code":"Vendor_Code"):"Msi_Code"));
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_soc_vendor_name    =  " +(isQcomProduct_6?"Qcom":"Mtk"));
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_code_line_type     =  " +(isMainLineBranch_3?"MainLine":"StableLine"));



                product_txt_List.add((getPadding2(mResultValue_Index++))+"_soc_name           =  " + mValue_Modem_Release_Notes);
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_job_name           =  " +mValue_JOB_NAME);
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_identify           =  " +mValue_SOFTWARE_BUILD_ID);
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_ReleaseDate        =  " +getChineseDateTip(mValue_End_Release_Date));
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_manifest_branch    =  " +mValue_MANIFEST_BRANCH);
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_manifest_xmlfile   =  " +mValue_MANIFEST_FILE);
                product_txt_List.add((getPadding2(mResultValue_Index++))+"_manifest_url       =  " +mValue_MANIFEST_URL);

                if(isMerge_2){
                    product_txt_List.add((getPadding2(mResultValue_Index++))+"_merge_init        =  " +mValue_End_repo_init);
                    product_txt_List.add((getPadding2(mResultValue_Index++))+"_merge_init_fixed  =  " +mTemp_mValue_End_repo_init_fixed);
                    product_txt_List.add((getPadding2(mResultValue_Index++))+"_merge_build       =  " +mTemp_mValue_End_build_device);

                }

                
            	// 【xxx_g Merge Init 】 Merge Repo Init 初始化 Merge 命令
                
                // 【xxx_g Merge Rebuild 】
                
                product_txt_List.add("");
                product_txt_List.add("");

                String productName = product_name_1;
                String mValue_End_repo_init_fixed = mTemp_mValue_End_repo_init_fixed;
                String mValue_End_build_device = mTemp_mValue_End_build_device;
                
                product_txt_List.add(getSchema("【"+productName+" Merge Init  】  Vendor Repo Init 初始化 Vendor 命令"));
                product_txt_List.add("");
                product_txt_List.add("source /opt/conf/moto.conf "+" && "+ mValue_End_repo_init_fixed+" && " +" repo sync -j2 " +" && "+" repo start --all TEMP "  +" && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_merge_"+mValue_BUILD_TARGET+".log");


                product_txt_List.add("");
                product_txt_List.add("");

                product_txt_List.add(getSchema("【"+productName+" Merge Rebuild 】 "));
                product_txt_List.add("");
                product_txt_List.add("source /opt/conf/moto.conf "+"  && "+mValue_End_build_device+ " 2>&1 | tee "+getTimeStamp()+"_merge_"+mValue_BUILD_TARGET+".log");

                
                
                product_txt_List.add("");
                product_txt_List.add("");
                product_txt_List.add(getSchema("【 提交commit命令 提示】"));
                product_txt_List.add("git push origin TEMP:refs/for/【当前分支| 通过 git gui ，gitk  , git branch -vv 查看提交分支】");
                product_txt_List.add("示例01:  git push origin TEMP:refs/for/bp");
                product_txt_List.add("示例02:  git push origin TEMP:refs/for/bp-mtk");
                product_txt_List.add("示例03:  git push origin TEMP:refs/for/bq");
                product_txt_List.add("示例04:  git push origin TEMP:refs/for/br");
                product_txt_List.add("示例05:  git push origin TEMP:refs/for/br-mtk");
                product_txt_List.add("示例06:  git push origin TEMP:refs/for/bs");
                product_txt_List.add("示例07:  git push origin TEMP:refs/for/bs-mtk");
                product_txt_List.add("示例08:  git push origin TEMP:refs/for/prods-mtk");
                product_txt_List.add("示例09:  git push origin TEMP:refs/for/bt");
                product_txt_List.add("示例10:  git push origin TEMP:refs/for/bt-mtk");
                product_txt_List.add("示例11:  git push origin TEMP:refs/for/mt-r1/bt");
                product_txt_List.add("示例12:  git push origin TEMP:refs/for/bs-6450");
                product_txt_List.add("示例13:  git push origin TEMP:refs/for/bs-8450");
                product_txt_List.add("示例14:  git push origin TEMP:refs/for/bs-qc");
                product_txt_List.add("示例15:  git push origin TEMP:refs/for/bu");
                product_txt_List.add("示例16:  git push origin TEMP:refs/for/bu-mtk");
                product_txt_List.add("示例17:  git push origin TEMP:refs/for/prodt-mtk");
                product_txt_List.add("示例18:  git push origin TEMP:refs/for/produ-mtk");
                product_txt_List.add("示例19:  git push origin TEMP:refs/for/prods-mtktc2sp2");
                product_txt_List.add("示例20:  git push origin TEMP:refs/for/bv-mtk");
                product_txt_List.add("示例21:  git push origin TEMP:refs/for/prodv-mtk");
                product_txt_List.add("示例22:  git push origin TEMP:refs/for/bv");
                product_txt_List.add("示例23:  git push origin TEMP:refs/for/prodv-mtktc2sp2");
                product_txt_List.add("示例24:  git push origin TEMP:refs/for/bv-qc");
                product_txt_List.add("示例25:  git push origin TEMP:refs/for/bv-6450");
                product_txt_List.add("示例26:  git push origin TEMP:refs/for/bv-8450");
                product_txt_List.add("示例27:  git push origin TEMP:refs/for/bw-mtk");
                product_txt_List.add("示例28:  git push origin TEMP:refs/for/prodw-mtk");
                product_txt_List.add("示例29:  git push origin TEMP:refs/for/bw");
                product_txt_List.add("示例30:  git push origin TEMP:refs/for/prodw-mtktc2sp2");
                product_txt_List.add("示例31:  git push origin TEMP:refs/for/bw-qc");
                product_txt_List.add("示例32:  git push origin TEMP:refs/for/bw-6450");
                product_txt_List.add("示例33:  git push origin TEMP:refs/for/bw-8450");
                
                product_txt_List.add("");
                product_txt_List.add("");
                
            	
            	return product_txt_List;
            	
            }
            
            
            
            boolean isQcomProduct(String rawHtml){
                boolean isQcom = true;

                String all_lower_text = rawHtml.toLowerCase();

                String[] qcom_split_arr = all_lower_text.split("qcom");

                String[] mtk_split_arr = all_lower_text.split("mtk");


                if(qcom_split_arr.length == mtk_split_arr.length ){
                    return isQcom;
                }

                if(qcom_split_arr.length > mtk_split_arr.length ){
                    return true;
                }

                if(qcom_split_arr.length < mtk_split_arr.length ){
                    return false;
                }



                return isQcom;


            }

            String getPadding2(int value){
                String int_str = "" +value;
                if(value >= 0 && value <= 9 ){
                    return "0"+int_str;
                }
                return  int_str;

            }

            String  getAndroidVersionTip(String charVersion){
                String detailVersionTip = charVersion;

                switch (charVersion){

                    case "Z":
                        return charVersion+"_(Android_19)";

                    case "Y":
                        return charVersion+"_(Android_18)";

                    case "X":
                        return charVersion+"_(Android_17)";

                    case "W":
                        return charVersion+"_(Android_16)";

                    case "V":
                        return charVersion+"_(Android_15)";

                    case "U":
                        return charVersion+"_(Android_14)";

                    case "T":
                        return charVersion+"_(Android_13)";

                    case "S":
                        return charVersion+"_(Android_12)";

                    case "R":
                        return charVersion+"_(Android_11)";

                    case "Q":
                        return charVersion+"_(Android_10)";

                    case "P":
                        return charVersion+"_(Android_9)";

                    case "O":
                        return charVersion+"_(Android_8)";

                    case "N":
                        return charVersion+"_(Android_7)";


                    case "M":

                        return charVersion+"_(Android_6)";


                    case "L":
                        return charVersion+"_(Android_5)";



                    case "K":
                    case "J":
                        return charVersion+"_(Android_4)";


                    case "I":
                        return "J_(Android_3)";

                    case "H":
                        return charVersion+"_(Android_3)";


                    case "D":
                    case "C":
                    case "B":
                        return charVersion+"_(Android_1)";





                    default:

                }


                return detailVersionTip;
            }

            String getChineseDateTip(String englishDate){
                String mChineseDateTip = englishDate;

                mChineseDateTip =  mChineseDateTip.replace("Mon","周一")
                        .replace("Tue","周二")
                        .replace("Wed","周三")
                        .replace("Thu","周四")
                        .replace("Fri","周五")
                        .replace("Sat","周六")
                        .replace("Sun","周天");


                mChineseDateTip =  mChineseDateTip.replace("Jan","一月")
                        .replace("Feb","二月")
                        .replace("Mar","三月")
                        .replace("Apr","四月")
                        .replace("May","五月")
                        .replace("Jun","六月")
                        .replace("Jul","七月")
                        .replace("Aug","八月")
                        .replace("Sep","九月")
                        .replace("Oct","十月")
                        .replace("Nov","十一月")
                        .replace("Dec","十二月");

                return mChineseDateTip;


            }


            String fixed_repo_url(String rawInitCommand , String mBranch , String mManifestXmlFile) {
                StringBuilder fixedCommand  = new StringBuilder();
                String[] repoInitArr = rawInitCommand.split(" ");

//        	refs/tags/TTGN33.19-GENEVNA-SHA1 -m sha1_embedded_manifest.xml

                for (int i = 0; i < repoInitArr.length; i++) {
                    String itemStr = repoInitArr[i];

                    if(itemStr.startsWith("refs/tags")) {

                        fixedCommand.append(mBranch+" ");
                        continue;
                    }


                    if(itemStr.endsWith(".xml")) {

                        fixedCommand.append(mManifestXmlFile+" ");
                        continue;
                    }

                    fixedCommand.append(itemStr+" ");

                }

                return  ""+fixedCommand.toString();
            }


        }
    }

    static String ModemRelease_MoveHtml(String htmlContent ) {
        String modem_release_content = new String(htmlContent);

        modem_release_content = 	modem_release_content.replace("\"close\">", "").replace("</h3>", "").replace("<div>", "")
                .replace("<pre>", "").replace("</pre>", "").replace("</div>", "").replace("<br />", "").replace("<hr />", "")
                .replace("</h4>", "").replace("<table>", "").replace("<tbody>", "").replace("<tr>", "").replace("<th>", "")
                .replace("</th>", "").replace("</tr>", "").replace("</td>", "").replace("</tbody>", "").replace("</table>", "")
                .replace("<td>", "").replace("<h4>", "")
                .replace("&lt;", "【").replace("&gt;", "】")


                .replace("<div class=\"content\" data-collapse>", "").trim();
        ;

        return modem_release_content;

    }


    public static  ArrayList<String>  Str2StrList(String str ) {

        ArrayList<String>  allStrList = new 	ArrayList<String> ();

        String[] strArr = str.split("\\n");


        allStrList.addAll(Arrays.asList(strArr));

        return allStrList;

    }

    public static boolean isStringContainInList(String str , ArrayList<String> strList) {
        boolean  existFlag = false;

        for (int i = 0; i < strList.size(); i++) {
            String strItem = strList.get(i);
            //	System.out.println("line["+i+"] = "+strItem  +" falg="+strItem.contains(str));
            if(strItem.contains(str)) {

                return true;
            }

        }
        return existFlag;

    }

    // 把图片分类到 对应的分辨率目录  1980x1280 文件夹

    class Picture_Classify_To_WidthHeighDir_Rule_59 extends Basic_Rule {

        Picture_Classify_To_WidthHeighDir_Rule_59() {
            super("#", 59, 4); //

        }



        @Override
        String simpleDesc() {
            return "\n" +
                    Cur_Bat_Name + "  #_"+rule_index+ "        ##把图片分类到 对应的分辨率目录  1980x1280 文件夹   1.jpg -> 1980x1280/1_230221_1148.jpg "+"\n" +
                    Cur_Bat_Name + "  #_"+rule_index+ "        ##把图片分类到 对应的分辨率目录  1600x900 文件夹    1.jpg -> 1600x900/1_230221_1148.jpg "+"\n" +
                    "";

        }



        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            // TODO Auto-generated method stub

            for (int i = 0; i < curRealFileList.size(); i++) {
                File sonFile = curRealFileList.get(i);
                String sonFileName = sonFile.getName();
                if(!sonFileName.toLowerCase().endsWith(".jpg") &&
                        !sonFileName.toLowerCase().endsWith(".png")	&&
                        !sonFileName.toLowerCase().endsWith(".jpeg")
                ) {

                    continue;
                }

                String fileType = getFileTypeNoPoint(sonFileName.toLowerCase());




                BufferedImage bi;
                try {
                    bi = ImageIO.read(sonFile);
                } catch (IOException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                    continue;
                }
                if(bi ==null){
                    continue;
                }
                int height = bi.getHeight();
                int width = bi.getWidth();

                int jpg_width = width;
                int jpg_hight = height;


                File middle_dir = new File(sonFile.getParentFile().getAbsoluteFile() + File.separator + jpg_width+"x"+jpg_hight);
                if (!middle_dir.exists()) {
                    middle_dir.mkdirs();
                    System.out.println(" 创建  分辨率_dir = " + middle_dir.getAbsolutePath());
                }

                String md5Name = 	getMD5Three(sonFile.getAbsolutePath());

                File sunFile = new File(middle_dir.getAbsolutePath() + File.separator +jpg_width+"x"+jpg_hight+"_"+ md5Name+".jpg");


                fileCopy(sonFile, sunFile);
                sonFile.delete();


            }

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

    }
    class InputDirSearch_To_JsonSummary_Rule_58 extends Basic_Rule {
        boolean isDirInput; //   是否有指定的 目录进行输入

        ArrayList<File> inputDirFileList;   // 输入的目录的集合

        //		ArrayList<RootDirFile> rootDirList ;  // 构建 json-file-Summary 的 Bean类
        FileSummary  mFileSummary;
        File targetJsonDir;   // 指定当前 json 的 输出路径    //  如果为空 那么就在shell输出 json
        File targetJsonFile ;  // 当前输出的Json 的文件的位置   // 名称固定  filesummary_rule58.json
        String jsonFileName ;  // filesummary_rule58.json  固定死
        InputDirSearch_To_JsonSummary_Rule_58() {
            super("#", 58, 5); //
            inputDirFileList = new ArrayList<File>();
//			rootDirList = new  ArrayList<RootDirFile>();
            isDirInput = false;
            jsonFileName = "filesummary_rule"+rule_index+".json";
            mFileSummary = new FileSummary("3333332");
        }

        @Override
        boolean allowEmptyDirFileList() {
            // TODO Auto-generated method stub
            return true;
        }


        @Override
        String simpleDesc() {
            return "  \n"
                    + Cur_Bat_Name  + " #_"+rule_index+"    ### 指定当前目录 输出当前目录的文件情况的 json 数据统计 \n"
                    + Cur_Bat_Name  + " #_"+rule_index+"   C:\\Users\\zhuzj5\\Desktop\\ScreenShot\\1\\testA   C:\\Users\\zhuzj5\\Desktop\\ScreenShot\\1\\testB  outjsondir_C:\\Users\\zhuzj5\\Desktop\\ScreenShot\\1  ### 指定目录输出该目录的文件情况的 json 数据统计 \n"

                    ;
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // mdname_true // kaoyan_true gaokao_true

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem_trim = inputParamList.get(i);

                File input_dir_file = new File(paramItem_trim);

                if(input_dir_file.exists() && input_dir_file.isDirectory()) {

                    inputDirFileList.add(input_dir_file);
                }


                if(paramItem_trim.toLowerCase().trim().startsWith("outjsondir_")) {

                    String outDirPath = paramItem_trim.replace("outjsondir_", "");

                    File outDirFile = new File(outDirPath);
                    if(outDirFile.exists() && outDirFile.isDirectory()) {
                        targetJsonDir = outDirFile;

                    }

                }



            }


            if(targetJsonDir == null) {
                System.out.println("当前 没有指定 "+ jsonFileName+" json文件的输出目录 目前输出到当前shell目录:"+curDirPath);

                targetJsonDir  = new File(curDirPath);
            } else {

                System.out.println("当前指定的"+jsonFileName+" 文件输出目录:"+ targetJsonDir.getAbsolutePath());
            }


            targetJsonFile = new File(targetJsonDir.getAbsolutePath()+File.separator+jsonFileName);

            System.out.println("输出Json文件路径: "+ targetJsonFile.getAbsolutePath() );


            if(inputDirFileList.size() != 0) {
                isDirInput = true;

                for (int i = 0; i < inputDirFileList.size(); i++) {
                    File dirFile = inputDirFileList.get(i);
                    System.out.println("SearchDir统计文件夹列表["+i+"]["+inputDirFileList.size()+"] = "+  dirFile.getAbsolutePath());
                }
            } else {

                System.out.println("当前没有 指定输入文件夹! 将把Shell目录 "+curDirPath+" 作为输入参数 统计文件情况 并输出json文件!");
            }

            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }



        void filesummary_operation(ArrayList<File> inputDirFileList) {


            for (int i = 0; i < inputDirFileList.size(); i++) {
                File dirFile = inputDirFileList.get(i);
                System.out.println("_____SearchDir统计文件夹列表["+i+"]["+inputDirFileList.size()+"] _____"  );



                ArrayList<File> allSubDir = 	getAllSubDirFile(dirFile);

//			System.out.println("SearchDir["+i+"]["+inputDirFileList.size()+"] _____allSubDir.size()="+allSubDir.size()+" dirPath:"+dirFile.getAbsolutePath()  );

                RootDirFile rootDirFile_Item = new RootDirFile(dirFile.getName());
                System.out.println("RootDirFile["+i+"]["+inputDirFileList.size()+"] _____allSubDir.size()="+allSubDir.size()+" dirPath:"+dirFile.getAbsolutePath()  +"  rootDirFile_ItemName="+dirFile.getName());


                for (int j = 0; j < allSubDir.size(); j++) {
                    ArrayList<File> subRealFileList = new ArrayList<File>();
                    ArrayList<String> subRealFileNameList = new ArrayList<String>();


                    File subDirFle = allSubDir.get(j);


                    // 当前子目录的路径 应该是相对于 根目录后剩下的目录

                    // subDirRelativeFileName 为空的话 标识 是 自身root目录
                    String subDirRelativeFileName = getRelativeSubDirName(subDirFle.getAbsolutePath() , dirFile.getAbsolutePath() );

                    SubDirFile subDirFile  = new SubDirFile(subDirRelativeFileName);
//				System.out.println("SearchDir["+i+"]["+inputDirFileList.size()+"] _____allSubDir["+j+"]["+allSubDir.size()+"] = "+ subDirFle.getAbsolutePath()  );
//				System.out.println("SubDirFile subDirRelativeFileName="+subDirRelativeFileName);
                    System.out.println("SubDirFile["+i+"]["+inputDirFileList.size()+"] _____allSubDir["+j+"]["+allSubDir.size()+"] = "+ subDirFle.getAbsolutePath()  +" subDirRelativeFileName="+subDirRelativeFileName );

                    File[] subFileArr = subDirFle.listFiles();

                    if(subFileArr == null || subFileArr.length == 0) {
                        continue;
                    }

                    for(File fileitem_in_subFileArr:subFileArr ) {
                        if(fileitem_in_subFileArr.isFile()) {
                            subRealFileList.add(fileitem_in_subFileArr);
                            subRealFileNameList.add(fileitem_in_subFileArr.getName());
                            subDirFile.realfilenamelist.add(fileitem_in_subFileArr.getName());
                        }
                    }

                    System.out.println("SubDirFile["+i+"]["+inputDirFileList.size()+"] ____realfilenamelist.size()="+subDirFile.realfilenamelist.size());

                    rootDirFile_Item.allsubdir.add(subDirFile);


                }

                mFileSummary.rootdirlist.add(rootDirFile_Item);

            }

            System.out.println("_____"+"rootDirList.size()="+mFileSummary.rootdirlist.size()+"_____");

            if(mFileSummary.rootdirlist.size() == 0) {
                System.out.println("当前没有检测到 文件夹  请检出 输入的文件夹!");
                return ;
            }

            String dir_json_summary = build_dir_json_summary(mFileSummary);

            System.out.println();
            System.out.println("_____________________ json summary _____________________");
            System.out.println();
            System.out.println();

            System.out.println(dir_json_summary);

            if(dir_json_summary != null) {

                writeContentToFile(targetJsonFile, dir_json_summary);

                System.out.println("输出json文件名称:  "+jsonFileName);
                System.out.println("输出json文件路径:  "+targetJsonFile.getAbsolutePath());

            }
            System.out.println();

        }


        @Override
        ArrayList<File> applyDir_SubFileListRule5(ArrayList<File> allSubDirFileList,
                                                  ArrayList<File> allSubRealFileList) {



            if(isDirInput) {   // 对输入的 目录 进行统计

                filesummary_operation(inputDirFileList);

            } else {  //  对自身Shell 路径进行统计

                System.out.println("当前没有 指定遍历的目录 对当前shell路径进行遍历:"+ curDirPath);

                ArrayList<File> searchDirFileList = new ArrayList<File> ();

                searchDirFileList.add(new File(curDirPath));

                filesummary_operation(searchDirFileList);
                System.out.println("当前没有 指定遍历的目录 对当前shell路径进行遍历:"+ curDirPath);

            }



            return super.applyDir_SubFileListRule5(allSubDirFileList, allSubRealFileList);
        }


        String getRelativeSubDirName(String subDirAbsPath , String rootDirAbsPath) {
            String relative_name = subDirAbsPath.replace(rootDirAbsPath, "");

            return relative_name;
        }

        String build_dir_json_summary(FileSummary fileSummary) {


            String jsonString = JSONUtil.toJsonStr(fileSummary);

            if(jsonString != null) {
                jsonString = 	 JSONUtil.formatJsonStr(jsonString);
            }



            return jsonString;

        }

        class FileSummary {
            String password;
//			ArrayList<String> allowidlist;   // 设备id

            ArrayList<RootDirFile> rootdirlist;

            FileSummary(){
            }

            FileSummary(String pwd){
                password = pwd;
                rootdirlist = new ArrayList<RootDirFile>();
            }

            public String getPassword() {
                return password;
            }

            public void setPassword(String password) {
                this.password = password;
            }

            public ArrayList<RootDirFile> getRootdirlist() {
                return rootdirlist;
            }

            public void setRootdirlist(ArrayList<RootDirFile> rootdirlist) {
                this.rootdirlist = rootdirlist;
            }




        }


        class RootDirFile{         //  当前的 一个指定的 输入的目录
            String rootdirname ;   //  根目录的文件夹名称
            ArrayList<SubDirFile> allsubdir;

            RootDirFile(){
            }

            RootDirFile(String rootname ){
                rootdirname = rootname;
                allsubdir = new ArrayList<SubDirFile> ();
            }

            public String getRootdirname() {
                return rootdirname;
            }

            public void setRootdirname(String rootdirname) {
                this.rootdirname = rootdirname;
            }

            public ArrayList<SubDirFile> getAllsubdir() {
                return allsubdir;
            }

            public void setAllsubdir(ArrayList<SubDirFile> allsubdir) {
                this.allsubdir = allsubdir;
            }

        }


        class SubDirFile{
            String subdirname;    // 当前的目录的名称
            ArrayList<String> realfilenamelist;  //  当前目录下的实体文件名称的集合

            SubDirFile(){
            }

            SubDirFile(String subname ){
                subdirname = subname;
                realfilenamelist = new ArrayList<String> ();

            }

            public String getSubdirname() {
                return subdirname;
            }

            public void setSubdirname(String subdirname) {
                this.subdirname = subdirname;
            }

            public ArrayList<String> getRealfilenamelist() {
                return realfilenamelist;
            }

            public void setRealfilenamelist(ArrayList<String> realfilenamelist) {
                this.realfilenamelist = realfilenamelist;
            }


        }

    }


    static String Rule_57_TAG = "zukgit_"+getTimeStampyyyyMMdd_HHmmss();
    static String Rule_57_LogTypeStr = "log";   // log   slog   syso  三种类型的打印
    static ArrayList<ZClass> Rule_57_ZClassList = new ArrayList<ZClass>();
    static String curProjectPath = System.getProperty("user.dir");

    class AddLog_CompileCheck_For_File_Rule_57 extends Basic_Rule {





        File aosp_wpa_supplicant_c_file;
        File aosp_settings_wifienabler_file;
        File aosp_build_device_bash_file ;
        File aosp_build_msi_device_sh_file ;
        File aosp_vendor_qcom_build_nonhlos_sh_file ;

        File aosp_kernel_platform_build_kernel_sh_file ;
        File aosp_vendor_qcom_nonhlos_dir;    //  当前AOSP的 Qcom 的 编译目录 需要查找它下面的 文件夹 是否存在 common/build.sh  文件  , 有就添加 echo
        // 如果 没有操作逻辑  以及类型处理  是java的话  添加Log  默认android.util.Log  可以通过 java_systemout_style 改为 system.out 输出
        ArrayList<File> inputFileList ;   // 输入文件的集合


        // 判断当前路径是否是 AOSP 路径   直接检测 WifiEnable 是否存在
        boolean isCurPath_AOSP = false;  // 当前的目录是否是

        String timestamp_yyyymmdd_hhmmss;  // 时间戳   统一 使用

        //  addlog_aosp_wifienable_java 检测是否是AOSP 如果是就把对应的 WifiEnable 文件 添加echo
        boolean isAddLog_AOSP_WifiEnable_Operation; //  addlog_aosp_wifienable_java
        String AOSP_WifiEnable_Version_Tip ;   // 当前的版本的 描述

        boolean isAddLog_SystemOut_Style; //  java_systemout_style

        //  addecho_aosp_devicebuild_bash   检测是否是AOSP 如果是就把对应的 devicebuild_bash 添加echo
        boolean isAddLog_AOSP_Bash_Operation;       //  addecho_aosp_devicebuild_bash     .bash  .sh  添加 埋点

        // 【 compile_check_java    xxxx.java 对指定文件检测编译错误】
        //  【compile_check_java      对当前的目录下的 java 文件进行 检测测试】
        boolean isJava_Compile_Check_Operation;

        boolean isBashEchoBatch;  // sh_echo_batch         // 搜局搜索 当前目录下的 bash sh 生成全局的   sh_echo_batch_时间戳 文件夹


        AddLog_CompileCheck_For_File_Rule_57() {
            super("#", 57, 4);

            inputFileList = new ArrayList<File>();
            AOSP_WifiEnable_Version_Tip ="";

            timestamp_yyyymmdd_hhmmss = getTimeStamp_yyyyMMdd_HHmmss();
        }


        boolean isCurPathAOSP () {

            String shellpath = curDirPath ;

            File shellFile = new File(shellpath);

            aosp_settings_wifienabler_file = new File(shellFile.getAbsolutePath()+File.separator+"packages/apps/Settings/src/com/android/settings/wifi/WifiEnabler.java");

            aosp_build_device_bash_file = new File(shellFile.getAbsolutePath()+File.separator+"motorola/build/bin/build_device.bash");

            aosp_build_msi_device_sh_file = new File(shellFile.getAbsolutePath()+File.separator+"device/moto/msi/build_msi_device.sh");

            aosp_vendor_qcom_build_nonhlos_sh_file = new File(shellFile.getAbsolutePath()+File.separator+"vendor/qcom/nonhlos/build_support/bin/build_nonhlos.sh");

            aosp_vendor_qcom_nonhlos_dir = new File(shellFile.getAbsolutePath()+File.separator+"vendor/qcom/nonhlos/");

            aosp_kernel_platform_build_kernel_sh_file = new File(shellFile.getAbsolutePath()+File.separator+"kernel_platform/build/build_kernel.sh");

            aosp_wpa_supplicant_c_file = new File(shellFile.getAbsolutePath()+File.separator+"external/wpa_supplicant_8/wpa_supplicant/wpa_supplicant.c");








            return  aosp_settings_wifienabler_file.exists() && aosp_settings_wifienabler_file.length() > 100;
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            boolean Flag = true;
            isCurPath_AOSP = isCurPathAOSP();
            for (int i = 0; i < inputParamList.size(); i++) {


                String strInput = inputParamList.get(i);

                File tempFile = new File(curDirPath + File.separator + strInput);
                if (tempFile.exists() && !tempFile.isDirectory()) {
                    String inputFileName = tempFile.getName().toLowerCase();
                    inputFileList.add(tempFile);
                    continue;
                }

                File inputDir = new File(strInput);
                if (inputDir.exists() && !inputDir.isDirectory()) {
                    inputFileList.add(inputDir);
                    continue;
                }


                String paramItem = inputParamList.get(i);
                String paramItem_lower_trim = paramItem.toLowerCase().trim();


                if (paramItem_lower_trim.startsWith("java_systemout_style")) {
                    isAddLog_SystemOut_Style = true;
                    continue;
                }


                if (paramItem_lower_trim.startsWith("sh_echo_batch")) {
                    isBashEchoBatch = true;
                    continue;
                }

                if (paramItem_lower_trim.startsWith("wifitip_")) {
                    AOSP_WifiEnable_Version_Tip = paramItem_lower_trim.replace("wifitip_", "");
                    Rule_57_TAG = Rule_57_TAG +"_"+AOSP_WifiEnable_Version_Tip;
                    continue;
                }


                // ----------------------  简洁的 执行命令 Begin --------------------
                if (paramItem_lower_trim.startsWith("tip_")) {   //  简洁的 执行 命令参数
                    AOSP_WifiEnable_Version_Tip = paramItem_lower_trim.replace("tip_", "");
                    Rule_57_TAG = Rule_57_TAG +"_"+AOSP_WifiEnable_Version_Tip;
                    continue;
                }

                if (paramItem_lower_trim.equals("1")) {
                    isAddLog_AOSP_Bash_Operation = true;
                    continue;
                }
                if (paramItem_lower_trim.startsWith("2")) {
                    isAddLog_AOSP_WifiEnable_Operation = true;
                    continue;
                }
                // ----------------------  简洁的 执行命令 End --------------------




                if (paramItem_lower_trim.startsWith("compile_check_java")) {
                    isJava_Compile_Check_Operation = true;
                    continue;
                }

                if (paramItem_lower_trim.startsWith("addecho_aosp_devicebuild_bash")) {
                    isAddLog_AOSP_Bash_Operation = true;
                    continue;
                }


                if (paramItem_lower_trim.startsWith("addlog_aosp_wifienable_java")) {
                    isAddLog_AOSP_WifiEnable_Operation = true;
                    continue;
                }



            }
            System.out.println("");
            System.out.println("非非非 Operation_Type 操作");
            System.out.println("isCurPath_AOSP___________: "+ isCurPath_AOSP + "  【true: 当前根目录是AOSP目录】 【fasle: 当前不是AOSP 工程的根目录】 ");
            System.out.println("WifiEnabler______________:"+aosp_settings_wifienabler_file);
            System.out.println("build_device.bash________:"+aosp_build_device_bash_file);
            System.out.println("build_msi_device.sh______:"+aosp_build_msi_device_sh_file);
            System.out.println("isAddLog_SystemOut_Style_: "+ isAddLog_SystemOut_Style+"  【true: Java 使用 System.out.println()打印】  【false : 标识 Java 文件使用 android.util.Log 】");
            System.out.println("WifiEnable_Version_Tip___: "+AOSP_WifiEnable_Version_Tip+"  【true: WifiEnable的提示信息 一般用来说明版本的目的】  【false :】");




            System.out.println("");
            System.out.println("Operation_Type 操作");
            System.out.println("1.isBashEchoBatch____________________:"+ isBashEchoBatch                +"  【true: 当前操作是批量生成对bash sh的修改操作 输出文件夹 sh_echo_batch_"+getTimeStampyyyyMMdd_HHmmss()+"文件夹】 【false:不操作类型】");
            System.out.println("2.compile_check_java_________________:"+ isJava_Compile_Check_Operation +"  【true:  对当前输入的文件 或者 当前子目录(非递归)所有的java文件查看是否有 编译错误(无法检查运行错误)】 【false: 无Opeartion_Type时 进行 添加Log的操作】");
            System.out.println("3.addecho_aosp_devicebuild_bash______:"+ isAddLog_AOSP_Bash_Operation   +"  【true:  指定AOSP目录的 build_msi_device.sh 和 build_device.bash 添加埋点 】 【false:不操作类型】");
            System.out.println("4.addlog_aosp_wifienable_java________:"+ isAddLog_AOSP_WifiEnable_Operation +"  【true:  指定AOSP目录的 WifiEnabler.java 添加Log 埋点 】 【false:不操作类型】");
            System.out.println("5.没有指定操作类型 那么将按照 文件类型 进行 处理 sh_bash(默认添加埋点) Java(默认添加Log)");

            System.out.println("");
            for (int i = 0; i < inputFileList.size(); i++) {
                System.out.println("输入文件["+i+"]____"+inputFileList.get(i).getAbsolutePath());
            }


            if(isAddLog_AOSP_WifiEnable_Operation || isAddLog_AOSP_Bash_Operation) {
                if(!isCurPath_AOSP) {
                    System.out.println("当前目录 不是 AOSP 根 目录 无法进行 AOSP的 先关 固定路径  如 WifiEnaabler 的 操作!  请在 AOSP目录执行 aosp操作!");
                    return false;
                }

            }

            if(isAddLog_SystemOut_Style) {
                Rule_57_LogTypeStr = "syso";
            }

            if(inputFileList.size() == 0 &&
                    isBashEchoBatch == false &&
                    isJava_Compile_Check_Operation == false &&
                    isAddLog_AOSP_Bash_Operation == false &&
                    isAddLog_AOSP_WifiEnable_Operation == false
            ) {

                System.out.println("当前 输入的操作类型为空 并且 也没有输入参数文件  执行规则未知 无法执行 请检查!");
                return false;
            }

            return super.initParamsWithInputList(inputParamList) && Flag;
        }
        @Override
        String simpleDesc() {
            return "  \n"
                    + Cur_Bat_Name  + " #_"+rule_index+"  addecho_aosp_devicebuild_bash  ### 在AOSP工程根目录的 build_device.bash  和 build_msi_device.sh  两个 编译文件 添加 修改 埋点 \n"
                    + Cur_Bat_Name  + " #_"+rule_index+"  1    (同 addecho_aosp_devicebuild_bash)  ### 在AOSP工程根目录的 build_device.bash  和 build_msi_device.sh  两个 编译文件 添加 修改 埋点 \n"

                    + Cur_Bat_Name + " #_"+rule_index+ " addlog_aosp_wifienable_java ### AOSP目录的 WifiEnabler.java 添加Log 埋点 \n"
                    + Cur_Bat_Name  + " #_"+rule_index+"  2    (同 addlog_aosp_wifienable_java)  ### 在AOSP工程根目录的 build_device.bash  和 build_msi_device.sh  两个 编译文件 添加 修改 埋点 \n"

                    + Cur_Bat_Name  + " #_"+rule_index+"  2  tip_message  (同 addlog_aosp_wifienable_javawifitip_ xx)  ### 在AOSP工程根目录的 build_device.bash  和 build_msi_device.sh  两个 编译文件 添加 修改 埋点 \n"

                    + Cur_Bat_Name  + " #_"+rule_index+" 1  2  tip_message  (同时执行 sh 修改 wifienable 以及标记操作 )  ### 在AOSP工程根目录的 build_device.bash  和 build_msi_device.sh  两个 编译文件 添加 修改 埋点 \n"

                    + Cur_Bat_Name + " #_"+rule_index+ " addlog_aosp_wifienable_java  wifitip_qcom_mtk_version_tip   ### AOSP目录的 WifiEnabler.java 添加Log 埋点 并加入 wifienable_【提示信息(qcom_mtk_version_tip)】 \n"

                    + Cur_Bat_Name + " #_"+rule_index+ " compile_check_java    ### 把当前目录下的 java 文件进行 编译错误的检测 \n"
                    + Cur_Bat_Name + " #_"+rule_index+ " compile_check_java   <xxx.java>  ### 把当前输入 java 文件进行 编译错误的检测 \n"
                    + Cur_Bat_Name + " #_"+rule_index+ " sh_echo_batch   ### 当前操作是批量生成对bash sh的add echo 修改操作 输出文件夹 sh_echo_batch_"+getTimeStampyyyyMMdd_HHmmss()+"文件夹  \n"
                    + Cur_Bat_Name + " #_"+rule_index+ " <xxxx.java>     ###  对输入java 文件 输出 android.util.Log.i(); 的 埋点打印  \n"
                    + Cur_Bat_Name + " #_"+rule_index+ " java_systemout_style  <xxxx.java>     ###  对输入java 文件 输出 system.out.println(); 的 埋点打印  \n"
                    + Cur_Bat_Name + " #_"+rule_index+ " <xxxx.sh>   <xxxx.bash>   ###  对输入bash 文件本身进行修改 输出 echo 的 埋点打印  \n"

                    ;
        }



        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {


            if(isAddLog_AOSP_Bash_Operation) {
                aosp_devicebuild_bash_add_echo();

            }

            if(isAddLog_AOSP_WifiEnable_Operation) {
                aosp_wifi_enable_add_log();
                aosp_wpasupplicant_add_log();
            }




            return null;
        }


        void aosp_wpa_supplicant_cha_zhuang() {

            ArrayList<String> wpasupplicant_file_contentlist = ReadFileContentAsList(aosp_wpa_supplicant_c_file);


            ArrayList<String> newCodeList = new ArrayList<String> ();

            for (int i = 0; i < wpasupplicant_file_contentlist.size(); i++) {

                String oneLine = wpasupplicant_file_contentlist.get(i);

                if(oneLine.contains("zukgit")) {
                    continue;
                }

                // I wpa_supplicant: wlan0: CTRL-EVENT-CONNECTED - Connection to 78:e9:cf:23:b5:ee completed

//				wpa_msg(wpa_s, MSG_INFO, WPA_EVENT_CONNECTED "- Connection to "
//						MACSTR " completed [id=%d id_str=%s%s]",
//						MAC2STR(wpa_s->bssid),
//						ssid ? ssid->id : -1,
//						ssid && ssid->id_str ? ssid->id_str : "",
//						fils_hlp_sent ? " FILS_HLP_SENT" : "");

                if(oneLine.contains("- Connection to") && oneLine.contains("wpa_msg") ) {

                    //	wpa_msg(wpa_s, MSG_INFO, "Authentication with timed out.MAC2STR(bssid)");
                    newCodeList.add("wpa_msg(wpa_s, MSG_INFO, \"wpa_zukgit_"+aosp_wpa_supplicant_c_file.getAbsolutePath()+"_"+timestamp_yyyymmdd_hhmmss+"_【"+AOSP_WifiEnable_Version_Tip+"】 【- Connection to 】" +"\");");
                    newCodeList.add(oneLine);

                    continue;
                }

                // wpa_supplicant: wlan0: Own MAC address: c8:58:95:d8:9a:4b
                // wpa_dbg(wpa_s, MSG_DEBUG, "Own MAC address: " MACSTR,MAC2STR(wpa_s->own_addr));
                if(oneLine.contains("Own MAC address:")  ) {

                    //	wpa_msg(wpa_s, MSG_INFO, "Authentication with timed out.MAC2STR(bssid)");
                    newCodeList.add("wpa_msg(wpa_s, MSG_INFO, \"wpa_zukgit_"+aosp_wpa_supplicant_c_file.getAbsolutePath()+"_"+timestamp_yyyymmdd_hhmmss+"_【"+AOSP_WifiEnable_Version_Tip+"】 【 Own MAC address: 】"+"\");");
                    newCodeList.add(oneLine);

                    continue;
                }




                newCodeList.add(oneLine);

            }

            writeContentToFile(aosp_wpa_supplicant_c_file, newCodeList);
            System.out.println(""+aosp_wpa_supplicant_c_file.getAbsolutePath()+" 插桩成功!");
        }

        void aosp_wifi_enable_cha_zhuang() {

            ArrayList<String> wpasupplicant_file_contentlist = ReadFileContentAsList(aosp_settings_wifienabler_file);


            ArrayList<String> newCodeList = new ArrayList<String> ();

            for (int i = 0; i < wpasupplicant_file_contentlist.size(); i++) {

                String oneLine = wpasupplicant_file_contentlist.get(i);

                if(oneLine.contains("zukgit")) {
                    continue;
                }



                if(oneLine.contains("onSwitchToggled(boolean isChecked)") ) {
//					 android.util.Log.i("zoggled", "this_i2");


                    newCodeList.add(oneLine);
                    newCodeList.add("android.util.Log.i(\"wifienabler_zukgit\", \""+aosp_settings_wifienabler_file.getAbsolutePath()+"_"+timestamp_yyyymmdd_hhmmss+"_【"+AOSP_WifiEnable_Version_Tip+"】【 WifiEnabler_onSwitchToggled isChecked=\"+isChecked+\"】\");");


                    continue;
                }

                newCodeList.add(oneLine);

            }

            writeContentToFile(aosp_settings_wifienabler_file, newCodeList);
            System.out.println(""+aosp_settings_wifienabler_file.getAbsolutePath()+" 插桩成功!");
        }



        void aosp_wpasupplicant_add_log(){

            if(aosp_wpa_supplicant_c_file.exists()) {

                aosp_wpa_supplicant_cha_zhuang();

            }else {

                System.out.println(" aosp_wpa_supplicant_c_file 文件不存在: "+ aosp_wpa_supplicant_c_file.getAbsolutePath());
            }

        }

        void aosp_wifi_enable_add_log(){
            aosp_wifi_enable_cha_zhuang();

            // 对 Java 文件 进行 添加注释用   不适合 插装
//        ZAndroidAPPClass mZAndroidAPPClass = new ZAndroidAPPClass(aosp_settings_wifienabler_file.getAbsolutePath());
//        ArrayList<ZMethod> methodList = new ArrayList<ZMethod>();
//        //boolean  onSwitchToggled(boolean isChecked)
//        methodList.add(new ZMethod(mZAndroidAPPClass, "boolean", "onSwitchToggled", "boolean isChecked "));
//        mZAndroidAPPClass.addZMethod(methodList);
//        //   Rule_57_LogTypeStr = "log";   // slog  //syso 三种打印方式
//        Rule_57_ZClassList.add(mZAndroidAPPClass);
//        Begin_Java_Parser();


        }

        public  void Begin_Java_Parser()  {


            //  如果当前的路径没有获得参数 那么 默认对ZClassList 执行操作
            if (isCurPath_AOSP) {  //   static ArrayList<ZClass> ZClassList = new  ArrayList<ZClass>();
                //  判断当前的 路径是否是AOSP 路径
                // curProjectPath
                if (isCurPath_AOSP) {

                    int classSize = Rule_57_ZClassList.size();
                    System.out.println(" 总共需要解析文件的个数  classSize = " + classSize);

                    String newClassCode = "";  //
                    String originClassCode = "";
                    String formatNewClassCode = "";
                    for (int i = 0; i < classSize; i++) {
                        System.out.println(" 开始解析第  " + i + "个文件    文件名为: " + Rule_57_ZClassList.get(i).path);
                        newClassCode = Rule_57_ZClassList.get(i).toNewClassCode();

                        if(newClassCode == null || "".equals(newClassCode)){
                            continue;
                        }
                        // 构建新的方法的内容  zukgitlog_2
                        System.out.println("═══════ 新构建的类文件的内容 如下: newClassCode :  \n" + newClassCode);

                        //  在newClassCode中加入新的Log方法   找到最后一个 { 的位置
                        int lastBlock = newClassCode.lastIndexOf("}");
                        //     System.out.println(" 最后{ 的位置 " +lastBlock );
                        String newClassCodeFix = "";

                        if (!Rule_57_ZClassList.get(i).alreadyAddPrintMethod) {
                            if (Rule_57_ZClassList.get(i).isIDEClass) {
                                //  newClassCodeFix = newClassCode.substring(0,lastBlock)+ "    " +IDEA_PRINT_METHOD + "}";
                                newClassCodeFix = newClassCode.substring(0, lastBlock) + "    " + Rule_57_ZClassList.get(i).GetRealPrintMethod() + "}";
                            } else if (Rule_57_ZClassList.get(i).isAPP) {
                                //      newClassCodeFix = newClassCode.substring(0,lastBlock) + "    " +APP_PRINT_METHOD + "}";
                                newClassCodeFix = newClassCode.substring(0, lastBlock) + "    " + Rule_57_ZClassList.get(i).GetRealPrintMethod() + "}";
                            } else if (Rule_57_ZClassList.get(i).isFramework) {
                                //  newClassCodeFix = newClassCode.substring(0,lastBlock) + "    " +Framework_PRINT_METHOD + "}";
                                newClassCodeFix = newClassCode.substring(0, lastBlock) + "    " + Rule_57_ZClassList.get(i).GetRealPrintMethod() + "}";
                            }

                        } else {  // 已经 添加过 MethodPrint的 类
                            newClassCodeFix = newClassCode;
                        }


                        // System.out.println("  添加 打印Log 的 字符串 newClassCodeFix  \n " +newClassCodeFix );
                        formatNewClassCode = JavaParser.parse(newClassCodeFix).toString();
                        //  System.out.println("═══════ 格式化文件 如下: formatNewClassCode :" + formatNewClassCode);
                        // 把当前的新构建的文件重新写入 .java 文件
                        writeContentToFile(Rule_57_ZClassList.get(i).classFile, formatNewClassCode);
                    }


                } else {
                    //  当前并不是AOSP是主页
                    System.out.println("当前并不是AOSP主页，必须提供 【Java文件路径】 或者 【文件夹路径】！");
                    return;
                }


            }
        }

        void aosp_devicebuild_bash_add_echo(){

            if(aosp_build_device_bash_file.exists()) {

                ArrayList<String> add_echo_list = 	Bash_Sh_File_Add_Echo(aosp_build_device_bash_file);

                writeContentToFile(aosp_build_device_bash_file, add_echo_list);

                System.out.println("当前已经把 AOSP_bash文件:"+aosp_build_device_bash_file.getAbsolutePath()+"  添加完成 echo 埋点! ");

            } else {

                System.out.println("当前已经把 AOSP_bash文件:"+aosp_build_device_bash_file.getAbsolutePath()+"不存在   echo 埋点操作失败! ");

            }






            if(aosp_build_msi_device_sh_file.exists()) {
                ArrayList<String> add_echo_list = 	Bash_Sh_File_Add_Echo(aosp_build_msi_device_sh_file);

                writeContentToFile(aosp_build_msi_device_sh_file, add_echo_list);

                System.out.println("当前已经把 AOSP_sh文件:"+aosp_build_msi_device_sh_file.getAbsolutePath()+"  添加完成 echo 埋点! ");

            }else {

                System.out.println("当前已经把 AOSP_sh文件:"+aosp_build_msi_device_sh_file.getAbsolutePath()+"不存在   echo 埋点操作失败! ");

            }


            if(aosp_kernel_platform_build_kernel_sh_file.exists()) {
                ArrayList<String> add_echo_list = 	Bash_Sh_File_Add_Echo(aosp_kernel_platform_build_kernel_sh_file);

                writeContentToFile(aosp_kernel_platform_build_kernel_sh_file, add_echo_list);

                System.out.println("当前已经把 AOSP_sh文件:"+aosp_kernel_platform_build_kernel_sh_file.getAbsolutePath()+"  添加完成 echo 埋点! ");
            }else {
                System.out.println("当前已经把 AOSP_sh文件:"+aosp_kernel_platform_build_kernel_sh_file.getAbsolutePath()+"不存在   echo 埋点操作失败! ");

            }


            if(aosp_vendor_qcom_build_nonhlos_sh_file.exists()) {

                ArrayList<String> add_echo_list = 	Bash_Sh_File_Add_Echo(aosp_vendor_qcom_build_nonhlos_sh_file);

                writeContentToFile(aosp_vendor_qcom_build_nonhlos_sh_file, add_echo_list);

                System.out.println("当前已经把 AOSP_bash文件:"+aosp_vendor_qcom_build_nonhlos_sh_file.getAbsolutePath()+"  添加完成 echo 埋点! ");

            } else {

                System.out.println("当前已经把 AOSP_bash文件:"+aosp_vendor_qcom_build_nonhlos_sh_file.getAbsolutePath()+"不存在   echo 埋点操作失败! ");

            }


            if(aosp_vendor_qcom_nonhlos_dir.exists() && aosp_vendor_qcom_nonhlos_dir.isDirectory()) {

                File[] nonhlos_file_arr = 	aosp_vendor_qcom_nonhlos_dir.listFiles();

                if(nonhlos_file_arr != null) {
                    for (int i = 0; i < nonhlos_file_arr.length; i++) {
                        File nonhlos_item_file = nonhlos_file_arr[i];

                        if(nonhlos_item_file.isDirectory()) {

                            File nonhlos_common_build_sh_file = new File(nonhlos_item_file.getAbsolutePath()+File.separator+"common/build.sh");


                            if(nonhlos_common_build_sh_file.exists()) {
                                ArrayList<String> add_echo_list = 	Bash_Sh_File_Add_Echo(nonhlos_common_build_sh_file,true);
                                writeContentToFile(nonhlos_common_build_sh_file, add_echo_list);
                                System.out.println("当前已经把 AOSP_bash文件:"+nonhlos_common_build_sh_file.getAbsolutePath()+"  添加完成 echo 埋点! ");
                            }

                            File nonhlos_boot_images_build_sh_file = new File(nonhlos_item_file.getAbsolutePath()+File.separator+"boot_images/build.sh");

                            if(nonhlos_boot_images_build_sh_file.exists()) {
                                ArrayList<String> add_echo_list = 	Bash_Sh_File_Add_Echo(nonhlos_boot_images_build_sh_file,true);
                                writeContentToFile(nonhlos_boot_images_build_sh_file, add_echo_list);
                                System.out.println("当前已经把 AOSP_bash文件:"+nonhlos_boot_images_build_sh_file.getAbsolutePath()+"  添加完成 echo 埋点! ");
                            }



                            File nonhlos_common_build_build_py_file = new File(nonhlos_item_file.getAbsolutePath()+File.separator+"common/build/build.py");


                            if(nonhlos_common_build_build_py_file.exists()) {
                                ArrayList<String> python_log_list = 	PythonFile_Add_Log_Echo(nonhlos_common_build_build_py_file,true);
                                writeContentToFile(nonhlos_common_build_build_py_file, python_log_list);
                                System.out.println("当前已经把 AOSP_bash文件:"+nonhlos_common_build_build_py_file.getAbsolutePath()+"  添加完成 打印 埋点! ");
                            }


                        }
                    }


                }


            }


        }


        public  ArrayList<String> PythonFile_Add_Log_Echo(File srcFile) {

            return PythonFile_Add_Log_Echo(srcFile,false);
        }


        public  ArrayList<String> PythonFile_Add_Log_Echo(File srcFile , boolean isFullname) {
            ArrayList<String> newListContent = new ArrayList<String>();

            File curFile = srcFile;

            String file_name = curFile.getName();
            if(isFullname) {
                file_name =  curFile.getAbsolutePath();
            }
            String operation_timestamp =getTimeStamp_yyyyMMdd_HHmmss();


            ArrayList<String> python_rawList = ReadFileContentAsList(srcFile);

            // lg.log  和 print
            // print("════════════════"+"System Info Begin"+"════════════════")

            if(python_rawList == null) {
                System.out.println("读取文件 "+srcFile.getAbsolutePath()+" 失败! ");
                return newListContent;
            }


            boolean isLogPrint_Flag = isContainInStrList(python_rawList,"lg.log");
            int mOneStepCount = calculPythonOneEmptyStep(python_rawList);

            String print_line_pre = "print(\"";
            String print_line_end = "\")";
            if(isLogPrint_Flag) {
//				 print_line_pre = "lg.log(\"";
//				 print_line_end = "\")";

                print_line_pre = "print(\"";
                print_line_end = "\")";

            }

            int print_count = 1;
            String print_tag = "zukgit ";


            for (int i = 0; i < python_rawList.size(); i++) {

                String preLine = "";
                String curLine = python_rawList.get(i);
                String nextLine = "";
                int pre_line_num = i;
                if(i >= 1 &&  i <= python_rawList.size() -2 ) {

                    do  {
                        //	System.out.println("pre_line_num = "+pre_line_num);
                        preLine = python_rawList.get(pre_line_num-1);
                        pre_line_num = pre_line_num -1;

                    } while((pre_line_num) > 1 && "".equals(preLine.trim()));


                    int next_line_num = i;
                    do  {
                        nextLine = python_rawList.get(next_line_num+1);
                        next_line_num = next_line_num + 1;

                    } while((next_line_num) < (python_rawList.size() -2)  && "".equals(nextLine.trim()));


                }

                if(curLine.contains(print_tag.trim())) {
                    //	System.out.println("已经 包含 tag["+print_tag+"]  跳过该行!");

                    continue;
                }




                if(curLine.trim().startsWith("#") || curLine.trim().startsWith("====") || curLine.trim().startsWith("\\")
                        || curLine.trim().endsWith("\\")  || curLine.trim().endsWith(",")   ) {
                    //	System.out.println("以 # 号 ==== 号 \\\\号  开头 那么是注释  那么 跳过");
                    newListContent.add(curLine);
                    continue;
                }








                int emptyCount = getEmptyBeginCount(curLine);
                int emptyCount_next = getEmptyBeginCount(nextLine);
                int emptyCount_pre = getEmptyBeginCount(preLine);


                if(curLine.trim().startsWith("for ") && curLine.trim().contains("in ")) {
                    String var_item = curLine.substring(0,curLine.indexOf("in ")).trim();
                    var_item = 	var_item.replace("for ", "").replace(" ", "");

                    if(curLine.trim().endsWith("]")) {
                        // System.out.println("不是正常的 for 循环  不执行打印!");
                        newListContent.add(curLine);   // 先打印 原始 数据
                        continue;
                    }


//				    for i in range(1, 4):
//				            print("zukgit  _887_ D:\1A\1\build_old.py\Z9_prule.py_20221202_174509_i="+i+"")
//				            enemy = Rule5_EnemyTank(i)

                    int for_space_count = emptyCount+mOneStepCount;
                    if(for_space_count !=  emptyCount_next && emptyCount_next != 0 ) {  //  两者 不一致时 和 下一行 保持一致
                        for_space_count = emptyCount_next;
                    }
                    //	System.out.println("pre_line="+preLine+"【emptyCount_pre】="+emptyCount_pre);
                    //	System.out.println("curLine="+curLine+"【emptyCount】="+emptyCount);
                    //	System.out.println("nextLine="+nextLine+"【emptyCount_pre】="+emptyCount_next);

                    var_item = "str("+var_item+")";

                    String print_code_py = getRepeatString(" ", for_space_count)+print_line_pre+
                            print_tag+" _"+print_count+"_ "+file_name+"_"+operation_timestamp+"_"+var_item+"="+"\"+"+var_item+"+\""     // 打印的数据
                            +print_line_end;

                    print_count++;

                    newListContent.add(curLine);   // 先打印 原始 数据

                    newListContent.add(print_code_py);  //  再 打印输出



                    continue;

                }

                //  进入方法 的 打印
                if(curLine.trim().startsWith("def ")  && curLine.contains(":")
                        && curLine.contains("(")  && curLine.contains(")")) {
                    String func_name = curLine.substring(0,curLine.indexOf("(")).trim();
                    func_name = func_name.replace("def ", "").trim();

                    String func_params= curLine.substring(curLine.indexOf("("), curLine.indexOf(")")).trim();
                    func_params = func_params.replace("(","").trim();
                    func_params = func_params.replace(")","").trim();

                    ArrayList<String> param_list = new ArrayList<String>();
                    if(func_params.equals("")) {  // 为 空的参数
                        param_list.add("");
                    } else if(!func_params.contains(",")) {

                        if(!func_params.contains("*")) {

                            func_params = "str("+func_params+")";

                            param_list.add(func_params);
                        }


                    } else if(func_params.contains(",")) {
                        String[] param_arr = func_params.split(",");

                        if(param_arr != null) {

                            for (int j = 0; j < param_arr.length; j++) {
                                String param_item = param_arr[j].trim();
                                // copytree(src, dst, symlinks=False, ignore=None)
                                // __init__(self, length = 3, headPos = [5,3], direction = 'right')


                                if(!param_item.contains("]") &&  !param_item.contains("[")
                                        && !param_item.contains(")") &&  !param_item.contains("(")
                                        &&  !param_item.contains("*")) {
                                    String param_name = param_item;
                                    if(param_item.contains("=")) {
                                        param_name =  param_name.substring(0,param_name.indexOf("="));
                                    }

                                    param_name  = "str("+param_name+")";
                                    param_list.add(param_name);

                                }


                            }


                        }

                    }


                    StringBuilder param_sb = new StringBuilder();
                    for (int j = 0; j < param_list.size(); j++) {
                        String param_name_item =	param_list.get( j).trim();

                        if(!"".equals(param_name_item)) {
                            param_sb.append("+\"  "+param_name_item+"=\"+"+param_name_item);
                        }

                    }

                    param_sb.append(");");  // print_line_end



                    String print_code_py = getRepeatString(" ", emptyCount+mOneStepCount)+print_line_pre+
                            print_tag+" _"+print_count+"_ "+file_name+"_"+operation_timestamp+"_[ method_in "+func_name+" ] \""+param_sb.toString();      // 打印的数据
//					+print_line_end;

                    print_count++;


                    newListContent.add(curLine);   // 先打印 原始 数据

                    newListContent.add(print_code_py);  //  再 打印输出
                    continue;



                }



                if(curLine.contains("=") && !curLine.trim().endsWith("{") ) {
                    String var_item = curLine.substring(0,curLine.indexOf("=")).trim();

                    // 如果 变量 还包含 空格  括号 那么 不打印 var
                    if(var_item.contains(" ") || var_item.contains("\"") ||
                            var_item.contains("(") || var_item.contains(")")) {
                        newListContent.add(curLine);
                        continue;
                    }

//			        texts = [font.render(str(letter[i]), True, (0, 255, 0))
//			                 for i in range(len(letter))]    // 多行 表达式时   不打印

                    if(nextLine.contains("]") && !nextLine.contains("[") ) {
                        newListContent.add(curLine);
                        continue;
                    }



                    var_item  = "str("+var_item+")";


                    // ['exec_dir']    在 字符串里 去掉 '  变为 空
                    String print_code_py = getRepeatString(" ", emptyCount)+print_line_pre+
                            print_tag+" _"+print_count+"_ "+file_name+"_"+operation_timestamp+"_ "+var_item.replace("'", "")+"="+"\"+"+var_item+"+\""     // 打印的数据
                            +print_line_end;
                    print_count++;



                    newListContent.add(curLine);   // 先打印 原始 数据

                    newListContent.add(print_code_py);  //  再 打印输出
                    continue;
                }

                newListContent.add(curLine);   // 先打印 原始 数据

            }



            return newListContent;
        }




        public  ArrayList<String> Bash_Sh_File_Add_Echo(File srcFile ) {

            return Bash_Sh_File_Add_Echo(srcFile,true); //  默认 所有的显示 全局的路径  会更清晰

        }


        public  ArrayList<String> Bash_Sh_File_Add_Echo(File srcFile , boolean isFullname) {
            ArrayList<String> newListContent = new ArrayList<String>();

            File curFile = srcFile;

            String file_name = curFile.getName();
            if(isFullname) {
                file_name =  curFile.getAbsolutePath();
            }
            String operation_timestamp =timestamp_yyyymmdd_hhmmss;

            int echo_count = 1;
            if (curFile != null) {

                FileReader curReader;
                try {

                    curReader = new FileReader(curFile);

                    BufferedReader curBR = new BufferedReader(new InputStreamReader(new FileInputStream(curFile), "utf-8"));
                    String oldOneLine = "";
                    String newOneLine = "";
                    String pre_one_line = "";


                    while (oldOneLine != null) {

                        oldOneLine = curBR.readLine();

                        if(!newOneLine.contains("zukgit")) {  // 修改 老的 上一句  会被 echo代替
                            pre_one_line = newOneLine;
                        }

                        if (oldOneLine == null || oldOneLine.trim().isEmpty()) {
                            newListContent.add("");
                            continue;
                        }

//	                    System.out.println(" \"this is test string\" ");
//	                    System.out.println("adb shell am broadcast -a com.Android.test --es<string> test_string \"this is test string\" —ei<int> test_int 100 —ez<boolean> test_boolean true");
                        newOneLine = new String(oldOneLine).trim();

                        //1.注释
                        if(newOneLine.contains("zukgit")) {  //  如果当前行 包含 zukgit  那么是旧的 打印  不理它 直接跳过  继续检测下一行
                            continue;
                        }

                        //1.注释
                        if(newOneLine.startsWith("#")) {  // 以 # 开头 是注释  直接 跳过

                            newListContent.add(newOneLine);
                            continue;
                        }


                        // 最后是以 " 或者 \ 结尾的  不操作
                        //echo zukgit_build_device_old.bash_479  "$ {build_int_files}=${build_int_files}"
                        // ramdisk-recovery.img \

                        //1. 不包含 等号 而且是以 \ 和  为 结尾 说明 可能是 多行操作   不执行 打印操作
                        // fuck 这里 " 为结尾 不能 这样写
                        if( (newOneLine.endsWith("\\") ))   {  // 以 \   为 结尾 开头 是多行  直接 跳过

                            newListContent.add(newOneLine);
                            continue;
                        }

                        // 当前 只有 一个 引号  那么 也 跳过
                        if( (newOneLine.endsWith("\"")) && ( newOneLine.indexOf("\"") == newOneLine.lastIndexOf("\"") ))   {  // 以 \   为 结尾 开头 是多行  直接 跳过

                            newListContent.add(newOneLine);
                            continue;
                        }






                        // 只对 包含 = 等号的 变量进行输出
                        //  script_name=$(basename ${script_path})   不以 if 开头  只有 一个 等号
                        //2. 只有一个等号的 赋值 的 表达式的处理
                        if(!newOneLine.startsWith("if")
                                && !newOneLine.contains("!=")
                                && newOneLine.contains("=")
                                && newOneLine.indexOf("=") == newOneLine.lastIndexOf("=") ) {
                            String equal_var_str = newOneLine.substring(0,newOneLine.indexOf("=")).trim();

                            if(equal_var_str.contains(" ")) {  //  // 如果 变量名称中 含有 空格那么 就不打印它了
                                newListContent.add(newOneLine);
                                continue;
                            }

                            String echo_var_command = "echo zukgit_"+file_name+"_"+echo_count+"_"+operation_timestamp+"  "+"\"$ {"+equal_var_str+"}=${"+equal_var_str+"}\"";
                            echo_count++;
                            newListContent.add(newOneLine);
                            newListContent.add(echo_var_command);
                            continue;
                        }


                        //3. 方法的内部  那么打印调用的方法
                        //function release_build_info {    并且是 以 { 为结尾的 方法  否则 报错
                        if(newOneLine.startsWith("function ") && newOneLine.endsWith("{")) {

                            String function_name = newOneLine.replace("{", "").replace("}", "").replace("(", "").replace(")", "").replace("function", "zfunc").trim();
                            String method_echo_command =  "echo zukgit_"+file_name+"_"+echo_count+"_"+operation_timestamp+"  "+" ______func_begin___________ "+function_name+" ___________";
                            echo_count++;
                            newListContent.add(newOneLine);
                            newListContent.add(method_echo_command);
                            continue;
                        }


                        // 如果当前语句中有变量  那么 获取 所有的变量的名字  并打印
                        //          cp ${RBE_log_dir}/rbe_metrics.* ${build_info_dir}/ || true
                        //4.
                        // 4.1 如果当前 不是以 \ 为 结尾  但 包含${   , 那么 要
                        // 	cp -f ${BUILD_SCRIPT_DIR}/boot/QcomPkg/SocPkg/Palima/Common/uefipil_oneli.cfg \
                        //	${BUILD_SCRIPT_DIR}/boot/QcomPkg/SocPkg/Palima/Common/uefipil.cfg

                        if(newOneLine.contains("${")) {
                            String[] var_arr = newOneLine.split("\\$\\{");
                            if(var_arr == null) {
                                newListContent.add(newOneLine);
                                continue;
                            }

                            ArrayList<String> var_list = new ArrayList<String>();
                            for (int i = 0; i < var_arr.length; i++) {
                                String varItem = var_arr[i]+" ";;

                                if(i == 0) {   // 第一个分隔项 是 没有匹配的
                                    continue;
                                }

                                if(varItem.contains("}")) {
                                    String var_name = varItem.trim().substring(0,varItem.indexOf("}"));

                                    if(var_name.contains(" ")) {  // 如果 变量名称中 含有 空格那么 就不打印它了
                                        continue;
                                    }

                                    String echo_var_command =  "echo zukgit_"+file_name+"_"+echo_count+"_"+operation_timestamp+"  "+"  "+"\"$ {"+var_name+"}=${"+var_name+"}\"";
                                    echo_count++;
//									newListContent.add(echo_var_command);
                                    var_list.add(echo_var_command);


                                }
                            }

                            if(pre_one_line != null && pre_one_line.endsWith("\\")) {
                                // 如果 当前行的上一行 是 \ 结尾的话  当前行 说明是多行的最后一行 那么先输出当前行 再 打印
//								System.out.println("______");
//								System.out.println("newOneLine_A = "+ newOneLine );
//								System.out.println("pre_one_line_A = "+ pre_one_line );
//								System.out.println("end_with__\\_A  =  " + pre_one_line.endsWith("\\"));
//								System.out.println("______");

                                newListContent.add(newOneLine);
                                newListContent.addAll(var_list);


                            }else {

//								System.out.println("______");
//								System.out.println("newOneLine_B = "+ newOneLine );
//								System.out.println("pre_one_line_B = "+ pre_one_line );
//								System.out.println("end_with__\\_B  =  " + pre_one_line.endsWith("\\"));
//								System.out.println("______");
                                // 先打印  再 输出
                                newListContent.addAll(var_list);
                                newListContent.add(newOneLine);
                            }

                            continue;
                        }

                        //5.
                        // generate_product_graph $NINJA_BUILD_FILE $MSI_TARGET  没有 括号 扩起的 变量
                        if(newOneLine.contains("$") && !newOneLine.contains("${") && !newOneLine.contains(")")   ) {
                            String[] var_arr = newOneLine.split("\\$");
                            if(var_arr == null) {
                                newListContent.add(newOneLine);
                                continue;
                            }



                            for (int i = 0; i < var_arr.length; i++) {
                                String varItem = var_arr[i]+" ";

                                if(i == 0) {   // 第一个分隔项 是 没有匹配的
                                    continue;
                                }

                                String var_name = "";
                                if(varItem.contains(" ")) {
                                    var_name = varItem.trim().substring(0,varItem.indexOf(" "));


                                    if(var_name.contains(" ") || var_name.contains("/") || var_name.contains(".") ) {  // 如果 变量名称中 含有 空格那么 就不打印它了
                                        continue;
                                    }
                                    var_name = var_name.replace("\\", "").replace("/", "").replace("\"", "").replace(",", "").replace(" ", "");
                                    String echo_var_command =  "echo zukgit_"+file_name+"_"+echo_count+"_"+operation_timestamp+"  "+"  "+"\"$ {"+var_name+"}=${"+var_name+"}\"";
                                    echo_count++;
                                    newListContent.add(echo_var_command);

                                }
                            }
                            newListContent.add(newOneLine);
                            continue;


                        }



                        newListContent.add(newOneLine.trim());
                    }
                    curBR.close();

                } catch (IOException e) {
                    e.printStackTrace();
                }
            } else {
                System.out.println("Failed !");
            }
            return newListContent;
        }




    }


    static String calculIndexFlag(Node curNode) {
        String indexFlag = "";
        if (curNode != null && curNode.getMetaModel().getType() == MethodDeclaration.class) {
            return "[0]";
        } else {  // 把自己在
            List<Node> curChildList = curNode.getParentNode().get().getChildNodes();
            for (int i = 0; i < curChildList.size(); i++) {
                if (curNode == curChildList.get(i)) {
                    indexFlag = "[" + i + "]";
                    break;
                }
            }
        }
        indexFlag = calculIndexFlag(curNode.getParentNode().get()) + indexFlag;
        return indexFlag;
    }

    static void NodeMapPrint(Map<String, ArrayList<Node>> sameNodeMap) {
        Map.Entry<String, ArrayList<Node>> entry;
        if (sameNodeMap != null) {
            Iterator iterator = sameNodeMap.entrySet().iterator();
            while (iterator.hasNext()) {
                entry = (Map.Entry<String, ArrayList<Node>>) iterator.next();
                String key = entry.getKey();  //Map的Value
                ArrayList<Node> sameNodeList = entry.getValue();  //Map的Value
                System.out.println("════════Same Node Begin════════");
                for (int i = 0; i < sameNodeList.size(); i++) {

                    Node sameNodeitem = sameNodeList.get(i);
                    String indexIdentify = calculIndexFlag(sameNodeitem);
                    System.out.println(" 相同Node 索引:" + i + " Content = " + sameNodeitem + "indexIdentify = " + indexIdentify + "   FatherType = " + sameNodeitem.getParentNode().get().getMetaModel().getType());

                }
                System.out.println("════════Same Node End════════");
            }
        }


    }

    static class ZAndroidAPPClass extends ZAndroidClass {
        ZAndroidAPPClass(String path, ArrayList<ZMethod> methodList) {
            super(path, methodList);
            isAPP = true;
        }

        ZAndroidAPPClass(String path) {
            super(path);
            isAPP = true;
        }


    }

    static class ZAndroidClass extends ZCommonClass {
        ZAndroidClass(String path, ArrayList<ZMethod> methodList) {
            super(path, methodList);
            isIDEClass = false;
            isAndroidClass = true;
        }

        ZAndroidClass(String path) {
            super(path);
            isIDEClass = false;
            isAndroidClass = true;
        }


    }

    static class ZCommonClass extends ZClass {
        ZCommonClass(String path, ArrayList<ZMethod> methodList) {
            super(path, methodList);
        }

        ZCommonClass(String path) {
            super(path);
        }

    }


    static abstract class ZClass {
        CompilationUnit zCompilationUnit;
        ClassOrInterfaceDeclaration zClassOrInterfaceDeclaration;
        ArrayList<ZMethod> zmethodList;
        String originClassContent;  // 类的完整代码
        String newClassContent;    // 经过修改后的代码
        String className;
        String path;    // 类的路径
        File classFile;   // 类对应的文件
        boolean alreadyAddPrintMethod;
        boolean isAPP;
        boolean isFramework;
        boolean isAndroidClass;     //  是否是安卓项目的类
        boolean isIDEClass;       // 是否是IDE 项目的 类
        boolean isInterfaceFile;   // 当前的文件是一个java 接口文件

        ZClass() {

        }

        ZClass(String path) {
            this.path = path;
            if (this.path == null || this.path.equals("") || this.path.equals(".java")) {
                System.out.println(" 解析文件出错！ 文件为空 或者不是Java文件   文件 = " + this.path);
                return;
            }
            String javaName = this.path.substring(this.path.lastIndexOf(File.separator) + 1, this.path.lastIndexOf(".java"));
            if (javaName == null) {
                System.out.println(" 文件名解析出错！");
                return;
            }
            this.className = javaName;
            this.classFile = new File(path);
            alreadyAddPrintMethod = false;
            // zukgitlog_3
            //   System.out.println("ZClass(String path) = "+ classFile.getAbsolutePath() +"   className="+className);  //  接口 public interface

            if (this.classFile.exists()) {
                try {
                    zCompilationUnit = JavaParser.parse(this.classFile);
                    this.originClassContent = zCompilationUnit.toString();

                    Optional<ClassOrInterfaceDeclaration> classOrInterfaceDeclaration_OPT = zCompilationUnit.getClassByName(this.className);

//                    System.out.println(" this.className = "+ this.className);  // C:\Users\zhuzj5\IdeaProjects\JavaParser\src\Main
                    if (classOrInterfaceDeclaration_OPT != null && classOrInterfaceDeclaration_OPT.isPresent()) {
                        zClassOrInterfaceDeclaration = classOrInterfaceDeclaration_OPT.get();
                    } else {
//                        System.out.println(" 解析 ClassOrInterfaceDeclaration 出错 ！");
                        System.out.println("══════════════════════════");
                        System.out.println("PATH接口Interface文件:" + "    无法通过 javaparser解析 ！");
                        System.out.println("Name=" + this.className + "   Path:" + path);
                        System.out.println("══════════════════════════");
                        this.isInterfaceFile = true;
                        return;
                    }

                } catch (Exception e) {
                    e.printStackTrace();
                    System.out.println(" 解析文件出错！ 可能是Lambda表达式  文件 = " + this.path);
                    this.isInterfaceFile = true;  // 标记为interface文件  不解析

                }
            } else {
                System.out.println(" 文件  " + this.path + " 不存在无法解析！ ");
            }
        }


        void InitZmethodFromJavaFile(File javaFIle, ZClass zCurZClass) {
            this.zmethodList = new ArrayList<ZMethod>();
            if(this.isInterfaceFile){
                return;
            }
            ArrayList<ZMethod> curMethod = ParserJavaMethod(javaFIle, zCurZClass);
            this.zmethodList.addAll(curMethod);

        }

        ArrayList<ZMethod> ParserJavaMethod(File javaFile, ZClass zCurZClass) {
            ArrayList<ZMethod> zMethodList = new ArrayList<ZMethod>();

            String javaName = javaFile.getName();
            if (javaName.endsWith(".java")) {
                javaName = javaName.substring(0, javaName.length() - ".java".length());
            }


            try {
                CompilationUnit mCompilationUnit = JavaParser.parse(javaFile);
                Optional<ClassOrInterfaceDeclaration> class_opt = mCompilationUnit.getClassByName(javaName);
                ClassOrInterfaceDeclaration mClassDeclaration = null;
                if (class_opt.isPresent()) {
                    mClassDeclaration = class_opt.get();
                }

                if (mClassDeclaration != null) {


                    List<MethodDeclaration> CurMethodList = mClassDeclaration.getMethods();

                    ArrayList<MethodDeclaration> methodDecList_arr = new ArrayList<MethodDeclaration>();
                    for (MethodDeclaration mMethodDec : CurMethodList) {
                        methodDecList_arr.add(mMethodDec);
                    }

//                    methodDecList_arr.sort(FieldMethod_Compare);

                    int index = 0;
                    for (MethodDeclaration methodDec : methodDecList_arr) {


                        boolean isStaticMethod = methodDec.isStatic();
                        boolean isNativeMethod = methodDec.isNative();
                        boolean isSyncMethod = methodDec.isSynchronized();
                        boolean isAbstractMethod = methodDec.isAbstract();
                        boolean isFinalMethod = methodDec.isFinal();
                        String modifyWord = "";
                        if (isNativeMethod || isAbstractMethod) {   // 过滤 native方法 和  abstract 抽象方法
                            continue;
                        }
                        modifyWord = modifyWord.trim();

//                        methodDec.isThrown("Exception");


                        String methodName = methodDec.getNameAsString(); // 函数名称
                        NodeList<Parameter> methodParamList = methodDec.getParameters();
                        String paramStr = "";    // 函数的参数


                        String methodDecStr = methodDec.getDeclarationAsString(false, false, false);
                        int returnIndex = methodDecStr.indexOf(methodName);
                        String returnString = "";
                        if (returnIndex > 0) {
                            returnString = methodDecStr.substring(0, returnIndex);
                        }
                        //  System.out.println("Signature =  "+  methodDec.getSignature().asString());
                        //        System.out.println("getDeclarationAsString =  "+  methodDec.getDeclarationAsString());
                        //       System.out.println("getDeclarationAsString2 =  "+  methodDec.getDeclarationAsString(false,false,false));
                        for (Parameter param : methodParamList) {
                            //  System.out.println("param = "+ param.toString());
                            paramStr = paramStr + "," + param.toString();
                        }
                        paramStr = paramStr.trim();
                        while (paramStr.startsWith(",")) {

                            paramStr = paramStr.substring(1);
                        }

                        while (paramStr.endsWith(",")) {
                            paramStr = paramStr.substring(1, paramStr.length());
                        }

                        //  System.out.println("returnString = " + returnString + "         methodName = " + methodName + "  paramStr = " + paramStr);
                        //  methodDec.g
                        // 继续点
                        String resultStr = "方法索引" + index + ": " + returnString + " " + methodName + "(" + paramStr + ")";

//                        arrMethodList.add(resultStr);
                        ZMethod curZMtthod = new ZMethod(zCurZClass, returnString.trim(), methodName.trim(), paramStr.trim());
//                        new ZMethod(mZAndroidAPPClass,"boolean","onSwitchToggled","boolean isChecked ")
                        zMethodList.add(curZMtthod);
                        index++;

                    }


                }

            } catch (Exception e) {
                System.out.println("X Exception ");
                System.out.println("解析文件失败! 可能是接口 可能是 lamdaba表达式");
                e.printStackTrace();
            }

            return zMethodList;
        }

        ZClass(String path, ArrayList<ZMethod> methodList) {
            this.path = path;
            this.zmethodList = methodList;
            this.classFile = new File(path);
            if (this.classFile.exists()) {
                try {
                    zCompilationUnit = JavaParser.parse(this.classFile);
                    this.originClassContent = zCompilationUnit.toString();
                } catch (FileNotFoundException e) {
                    e.printStackTrace();
                    System.out.println(" 解析文件出错！  文件 = " + this.path);
                }
            } else {
                System.out.println(" 文件  " + this.path + " 不存在无法解析！ ");
            }

        }


        //计算字符串在给定字符串出现的次数
        public static int calculSrcCount(String src, String des) {
            int index = 0;
            int count = 0;
            while ((index = src.indexOf(des, index)) != -1) {
                count++;
                index = index + des.length();
            }
            System.out.println(des + "出现了 " + count + " 次");
            return count;
        }


        public static int getCharacterPosition(String originStr, String src, int orderIndex) {
//这里是获取"/"符号的位置
            int resultValue = -1;
            try {
                Matcher slashMatcher = Pattern.compile(src).matcher(originStr);
                int mIdx = 0;
                while (slashMatcher.find()) {
                    mIdx++;
                    if (mIdx == orderIndex) {
                        break;
                    }
                }
                resultValue =  slashMatcher.start();

                return resultValue;
            } catch (Exception e){
                System.out.println("getCharacterPosition 检索 "+ src +"第"+orderIndex+"次出现位置失败!");
            }finally {
                return resultValue;
            }

        }


        static String replaceWithIndex(String oriStr, String src, String dest, int index) {
            String curResultStr = oriStr;
            if (!curResultStr.contains(src)) {   //  如果没有包含src  那么 原样返回
                System.out.println("原样返回1  不包含！src");
                return oriStr;
            }
            int order = index + 1;

            int srcCount = calculSrcCount(oriStr, src);
            if (order <= 0 || order > srcCount) {  //  如果给出的索引为负数 或者 索引+1 > 大于 字符串个数 那么返回原样
                System.out.println("原样返回2   order=" + order + "  srcCount= " + srcCount);
                return oriStr;
            }

            int curPlaceIndex = getCharacterPosition(oriStr, src, order);
            if (curPlaceIndex < 0) {
                System.out.println("原样返回3   curPlaceIndex=" + curPlaceIndex);

                return oriStr;
            }

            int beginIndex = oriStr.indexOf(src, curPlaceIndex);
            int length = src.length();
            int endIndex = beginIndex + length;
            if (beginIndex < 0) {
                System.out.println("原样返回4   beginIndex=" + beginIndex);

                return oriStr;
            }

            if (endIndex > oriStr.length()) {
                System.out.println("原样返回5   endIndex=" + endIndex + "  oriStr.length()=" + oriStr.length());

                return oriStr;
            }
            curResultStr = oriStr.substring(0, beginIndex) + dest + oriStr.substring(endIndex);

//            curResultStr.indexOf()


            return curResultStr;
        }

        // 把原有的Class代码转为新替换的Class的代码
        String toNewClassCode() {
            String originClassCode = "";
            String newClassCode = "";
            String originMethodCode = "";
            String newMethodCode = "";

            if (this.originClassContent == null || this.originClassContent.equals("")) {
                System.out.println("解析文件出现错误: originClassContent 为空");
                return null;
            }
            // zukgitlog_4  原始类的内容
            //  System.out.println("═══════ originClassContent ═══════\n"+this.originClassContent);
            originClassCode = new String(this.originClassContent);

            if (originClassCode.contains("zukgit")) {
                System.out.println(" 该类已经添加了Log 不再添加Log的打印方法 MetodPrint!");
                this.alreadyAddPrintMethod = true;
            }

            newClassCode = new String(originClassCode);
            int mMethodIndex = 1;
            for (ZMethod zmethod : this.zmethodList) {
                //System.out.println("  当前解析Method: = "+ zmethod.methodName);
                //  curClassCode.replaceAll(zmethod.originCodeString,)
                int allNodeSize = zmethod.checkAllNode(zmethod.methodDeclaration);   //  获取总共Method 中多少个结点
                if (allNodeSize == 0) {
                    continue;
                }

                if (zmethod.originCodeString.contains("@Test")) {
                    continue;
                }

                // 去掉方法的注释   //  //  //
                zmethod.logOnlyParam_originCodeString = tryToClearHeadCommandB(zmethod.originCodeString);

                // 如果方法中包含 @Test   那么也不解析 zukgit_log zukgit1_log zukgitlog_1
                //  System.out.println("zmethod.originCodeString 去除方法头部注释后 = \n"+ zmethod.logOnlyParam_originCodeString);

                int expressNodeSize = zmethod.expressNodeList.size();    //  每个表达式 前面 添加一些 log 以此 来观察 程序 运行
                // zukgitlog_5
                //      System.out.println(" allNodeSize = "+ allNodeSize +"       表达式结点 expressNodeSize = "+ expressNodeSize);
                originMethodCode = zmethod.originCodeString;
                //       System.out.println("第" + mMethodIndex+" 个方法开始解析 methodName =:" +zmethod.methodName);
                mMethodIndex++;

                //   去掉 zukgit
//                if (zmethod.originCodeString.contains("zukgit")) {  // 对已经添加过Log的方法不再处理
//                    //  System.out.println(" 该方法已经添加了Log 不再添加Log 添加log!"+zmethod.methodName);
//                    //  System.out.println(" 该方法已经添加了Log  需要进行修正 Log 打印的时间点);
//                    zmethod.belongClass.alreadyAddPrintMethod = true;
//                    continue;
//                }



                newMethodCode = new String(zmethod.logOnlyParam_originCodeString);

                NodeMapPrint(zmethod.sameExpressNodeMap);
                Object[] sameSetKey = zmethod.sameExpressNodeMap.keySet().toArray();
                for (int i = 0; i < sameSetKey.length; i++) {
                    ArrayList<Node> sameNodeList = zmethod.sameExpressNodeMap.get(sameSetKey[i]);
                    for (int j = 0; j < sameNodeList.size(); j++) {
                        int nodeIndex = j;
                        Node curNode = sameNodeList.get(j);
                        boolean needBlock = curNode.getParentNode().get().getMetaModel().getType() == com.github.javaparser.ast.stmt.IfStmt.class;

                        String code1 = zmethod.fixExpressNodeString(curNode.toString());  //  需要对这里进行fix  去除空格与注释
                        String[] analysysCode = zmethod.tryAnalysisExpressNodeString(curNode.toString());

                        //  如果父类不为空  并且父类是 com.github.javaparser.ast.stmt.IfStmt   并且父类的子项只有两个
                        String log = zmethod.buildIndexLog();
                        String codePre1 = "";
                        String codeBack1 = "";
                        if (analysysCode != null && analysysCode.length == 2) {
                            codePre1 = analysysCode[0];
                            codeBack1 = analysysCode[1];
                        }

                        if (checkExceptionFlag(codePre1)) {
                            codePre1 = "";
                        }
                        if (checkExceptionFlag(codeBack1)) {
                            codeBack1 = "";
                        }
                        String code2 = log + codePre1 + "  " + code1 + codeBack1;

                        Node fatherNode = curNode.getParentNode().get();

                        if (needBlock) {
                            code2 = "{" + code2 + "}";
                        }
                        System.out.println("═══════════map-same-code-begin══════════");
                        System.out.println("index: " + j + "  sameCode oldMethodCode = " + newMethodCode);
                        String oldMethodCode = new String(newMethodCode);
                        // 原始的已经变化了  之前的替换已经被 "  test1 = 11;" 已经被替换为 "test1 = 11;" 所以 需要减1
                        newMethodCode = replaceWithIndex(oldMethodCode, "  " + code1, code2, nodeIndex);
                        System.out.println("index:" + j + "  sameCode code1 = " + "  " + code1);
                        System.out.println("index:" + j + "  sameCode code2 = " + code2);
                        System.out.println("index: " + j + "  sameCode newMethodCode = " + newMethodCode);
                        System.out.println("old == new  " + oldMethodCode.equals(newMethodCode));
                        System.out.println("═══════════map-same-code-end══════════");
                        System.out.println();
                    }


                }

                for (int j = 0; j < expressNodeSize; j++) {
                    //  Node node =  zmethod.expressNodeList.get(j);
                    Node node = (Node) zmethod.expressNodeList.toArray()[j];
                    String code1 = zmethod.fixExpressNodeString(node.toString());  //  需要对这里进行fix  去除空格与注释
                    String[] analysysCode = zmethod.tryAnalysisExpressNodeString(node.toString());  // 对参数进行分析  String[2]  === type和typename
//Line 695: ══════=== fixStr = Toast.makeText(mContext, R.string.wifi_in_airplane_mode, Toast.LENGTH_SHORT).show();
//Line 700: ══════=== fixStr = mSwitchWidget.setChecked(false);
//Line 705: ══════=== fixStr = mMetricsFeatureProvider.action(mContext, MetricsEvent.ACTION_WIFI_ON);
//Line 710: ══════=== fixStr = mMetricsFeatureProvider.action(mContext, MetricsEvent.ACTION_WIFI_OFF, mConnected.get());
//Line 715: ══════=== fixStr = mSwitchWidget.setEnabled(true);
//Line 720: ══════=== fixStr = Toast.makeText(mContext, R.string.wifi_error, Toast.LENGTH_SHORT).show();

                    //  如果父类不为空  并且父类是 com.github.javaparser.ast.stmt.IfStmt   并且父类的子项只有两个
                    String log = zmethod.buildIndexLog();
                    String codePre1 = "";
                    String codeBack1 = "";
                    if (analysysCode != null && analysysCode.length == 2) {
                        codePre1 = analysysCode[0];
                        codeBack1 = analysysCode[1];
                    }
//                    codeBackXXX =   报错的
//                            zPrintLog(>);
                    //   System.out.println(" codePreXXX   = "+ codePre1);
                    //   System.out.println(" codeBackXXX = "+ codeBack1);

//                    expected one of "!=" "%" "%=" "&" "&&" "&=" "(" ")" "*" "*=" "+" "+=" "," "-" "-=" "->"
//                    "/" "/=" "::" "<" "<<=" "<=" "=" "==" ">" ">=" ">>=" ">>>=" "?" "^" "^="
//                    "instanceof" "|" "|=" "||"

                    if (checkExceptionFlag(codePre1)) {
                        codePre1 = "";
                    }


                    if (checkExceptionFlag(codeBack1)) {
                        codeBack1 = "";
                    }
                    //  System.out.println(" codePreXXX_B   = "+ codePre1);
                    // System.out.println(" codeBackXXX_B = "+ codeBack1);


                    String code2 = log + codePre1 + code1 + codeBack1;

                    Node fatherNode = node.getParentNode().get();

                    if (fatherNode != null && fatherNode.getMetaModel().getType() == com.github.javaparser.ast.stmt.IfStmt.class) {
                        code2 = "{" + code2 + "}";   //  对于  if()   int = aa  ;    // 这样的表达式处理
                        //System.out.println(" fatherNode.getChildNodes().size = "+ fatherNode.getChildNodes().size());
                    }
/*                    else if(fatherNode != null && fatherNode.getMetaModel().getType() == com.github.javaparser.ast.stmt.BlockStmt.class && fatherNode.getChildNodes().size() == 1){
                        code2 = "{" + code2 + "}" ;   //  对于  if()   int = aa  ;    // 这样的表达式处理

                    }*/


                    System.out.println();
                    System.out.println();
//                    System.out.println("═════════════════════════Begin════════════════════");
                    Node grandFatherNode = fatherNode.getParentNode().get();
                    System.out.println("code2 = " + code2);


//                    System.out.println("node.getMetaModel().getType() = "+ node.getMetaModel().getType());
//                         System.out.println("node.tostring = "+node.toString());
//                         for (int i = 0; i < node.getChildNodes().size(); i++) {
//                            System.out.println("curNode-child["+i+"] = "+ node.getChildNodes().get(i).getMetaModel().getType() );
//                         }
//                    System.out.println("fatherNode.tostring = "+fatherNode.toString());
//                        System.out.println("fatherNode.getMetaModel().getType() = "+ fatherNode.getMetaModel().getType());
//                    System.out.println("father-child-size="+fatherNode.getChildNodes().size());
//                    for (int i = 0; i < fatherNode.getChildNodes().size(); i++) {
//                        System.out.println("child["+i+"] = "+ fatherNode.getChildNodes().get(i).getMetaModel().getType() );
//                    }
//
//                        if(grandFatherNode != null){
//                            System.out.println("grandFatherNode.getMetaModel().getType() = "+ grandFatherNode.getMetaModel().getType());
//                            System.out.println("grandFatherNode = "+ grandFatherNode.toString());
//                        }
//                    System.out.println("═════════════════════════End════════════════════");


                    System.out.println();
                    System.out.println();

                    //System.out.println("############## index="+j+"     原有的Log node.toString() = "+code1);
                    //System.out.println("############## index="+j+"     现有的Log code2 = "+code2);

                    //  当前的 code1 是否是  某个 expressNode 的 子集
                    //  判断 当前的 code1 是否含有多个子项
                    newMethodCode = newMethodCode.replace("  " + code1, code2);     //  继续点  这里因为空格的原因无法匹配到
// ############## index=0     原有的Log node.toString() = Toast.makeText(mContext, R.string.wifi_in_airplane_mode, Toast.LENGTH_SHORT).show();
//############## index=0     现有的Log code2 =
// android.util.Log.i("zukgit_onSwitchToggled","this is indexLog index= 0");
// Toast.makeText(mContext, R.string.wifi_in_airplane_mode, Toast.LENGTH_SHORT).show();
                    //System.out.println("############## index="+j+"     现有的  newMethodCode  = "+newMethodCode);

                }

                //System.out.println("！！！！！！！！！！新构建的方法 Method的方法 如下: 原始方法 :" + zmethod.originCodeString);  // 构建新的方法的内容
                //System.out.println("！！！！！！！！！！新构建的方法 Method的方法 如下: newMethodCode :" + newMethodCode);  // 构建新的方法的内容
                String addBlankOriginCodeString = "";
                if (zmethod.originCodeString.startsWith("/*")) {
                    String originCodeStringWithOutZhuShi = zmethod.originCodeString.substring(zmethod.originCodeString.indexOf("*/") + 2).trim();
                    addBlankOriginCodeString = originCodeStringWithOutZhuShi.replaceAll("\n", "\n    ");
                    //System.out.println("Method 开头包含注释 /***/ ！！");
                } else {
                    addBlankOriginCodeString = zmethod.originCodeString.replaceAll("\n", "\n    ");
                    //System.out.println("Method 开头不包含注释 /***/ ！！");
                }


                if (addBlankOriginCodeString.startsWith("@Override")) {
                    addBlankOriginCodeString = "    " + addBlankOriginCodeString;
                }
                addBlankOriginCodeString = addBlankOriginCodeString.replace("    * ", "* ");
                addBlankOriginCodeString = addBlankOriginCodeString.replace("    */", "*/");

                if (zmethod.buildIndexLogList != null) {

                    for (int i = 0; i < zmethod.buildIndexLogList.size(); i++) {
                        String index = zmethod.buildIndexLogList.get(i);
                        //System.out.println("序号 : "+ i  + "   出现的序号: +" + (index) );
                    }

                }

                newMethodCode = zmethod.fixnewMethodCode(newMethodCode); // 把  this_is_indexLog_index=0  依次设置序号
                // System.out.println("═════════=   newMethodCode  Begin═════════==");
                //  System.out.println(newMethodCode);
                //  System.out.println("═════════=   newMethodCode  End═════════==");
                //  System.out.println("═════════=   newClassCode  Begin═════════==");

                newClassCode = newClassCode.replace(addBlankOriginCodeString, newMethodCode); // 构建新类文件内容

                if (!newClassCode.contains(newMethodCode)) {
                    //System.out.println("第一次匹配失败 在 addBlankOriginCodeString 和 newClassCode中的方法 格式问题不对称");
                    //System.out.println("1.newClassCode 中的格式无法查询  需要查看Log ");
                    //System.out.println("2.当前去匹配去适应的method字符串是:\n"+ addBlankOriginCodeString);

                    String classCodeTemplate = "class ZTemplate {" + addBlankOriginCodeString + " }";

                    CompilationUnit compileUtil = JavaParser.parse(classCodeTemplate);

                    String strCode1 = compileUtil.toString();
                    //System.out.println(strCode1);
                    String sreCode2 = strCode1.substring("class ZTemplate {".length());
                    String strCode3 = sreCode2.substring(0, sreCode2.lastIndexOf("}"));
                    String firstCode = "";
                    firstCode = strCode3.substring(0, 1);
                    //    System.out.println("firstCode1 = "+ firstCode);
                    while (!strCode3.startsWith(" ")) {
                        firstCode = strCode3.substring(0, 1);
                        //System.out.println("firstCode2 = "+ firstCode);
                        strCode3 = strCode3.substring(1);
                    }
                    if (newClassCode.contains(strCode3)) {
                        // System.out.println("第二次匹配成功 在 strCode3 和 newClassCode中的方法 格式问题对称");
                        newClassCode = newClassCode.replace(strCode3, newMethodCode);

                    } else {
                        // System.out.println("第二次匹配失败 在 strCode3 和 newClassCode中的方法 格式问题不对称");
                    }
                } else {
                    //System.out.println("第一次匹配成功 在 addBlankOriginCodeString 和 newClassCode中的方法 格式对称");

                }
                // System.out.println(newClassCode);
                //  System.out.println("═════════=   newClassCode  End═════════==");
                //   System.out.println("═════════=   addBlankOriginCodeString  Begin═════════==");
                //  System.out.println(addBlankOriginCodeString);
                //  System.out.println("═════════=   addBlankOriginCodeString  End═════════==");
                newMethodCode = null;
            }
            // System.out.println("！！！！！！！！！！  原始类的内容 :" + originClassCode);  // 构建新的方法的内容
            //  System.out.println("！！！！！！！！！！新类的内容 :" + newClassCode);  // 构建新的方法的内容
            return newClassCode;
        }

        void addZMethod(ArrayList<ZMethod> zmethodList) {
            this.zmethodList = zmethodList;
        }
        /*fafa*/


        static String tryToClearHeadCommandB(String originMethodContent) {
            String methodOnly = originMethodContent.trim();
            String resultCode = originMethodContent;
            if (!methodOnly.startsWith("//")) {
                return originMethodContent;
            } else {
                String[] codeArr = originMethodContent.split("\n");
                StringBuilder sb = new StringBuilder();
                int beginIndex = 0;
                for (int i = 0; i < codeArr.length; i++) {
                    if (!codeArr[i].trim().startsWith("//")) {
                        beginIndex = i;
//                        System.out.println("头部注释:  i"+i+"    " + codeArr[i]);
                        break;
                    }

                    if (codeArr[i].trim().contains("zukgit")) {   // 包含 zukgit 的 去掉
                        beginIndex = i;
//                        System.out.println("头部注释:  i"+i+"    " + codeArr[i]);
                        break;
                    }

                }

                for (int i = 0; i < codeArr.length; i++) {
//                    System.out.println("所有分割情况 i="+i+ "  value = "+codeArr[i]);
                }
                for (int j = beginIndex; j < codeArr.length; j++) {
                    sb.append(codeArr[j] + "\n");

                }

                resultCode = sb.toString();
//                System.out.println("去除Head注释的方法字符:"+ resultCode );
            }


            return resultCode;

        }

        static ArrayList<File> initJavaFileFromParam(ArrayList<String> keyList) {
            ArrayList<File> curJavaFileList = new ArrayList<File>();

            //  如果当前的文件是以./ 文件开头的话 那么说明 传入的参数是 相对路径  需要转为绝对路径
            for (int i = 0; i < keyList.size(); i++) {
                String itemStr = keyList.get(i);
                String absItemStr = "";
                if (itemStr.startsWith("./") || itemStr.startsWith(".\\")) {
                    itemStr = itemStr.replace("./", "");
                    itemStr = itemStr.replace(".\\", "");
                    absItemStr = curProjectPath + File.separator + itemStr;
                } else {
                    absItemStr = itemStr;    // 传递过来的就是绝对路径
                }


                File cuAabsItemStrFile = new File(absItemStr);
                if (cuAabsItemStrFile.exists() && cuAabsItemStrFile.getName().endsWith(".java")) {
                    // 文件存在 并且是以  .java 文件为结尾的 文件
                    curJavaFileList.add(cuAabsItemStrFile);
                }
            }


            return curJavaFileList;

        }



        String GetRealPrintMethod() {
            String methodPrint = new String(COMMON_PRINT_METHOD);
            String holdStr = "ZukgitHoldPlace";
            String MethodStr = "";
//            if (isIDEClass) {
//                MethodStr = "System.out.println(";
//            } else if (isAPP) {
//                MethodStr = "android.util.Log.i(\"" + TAG + "_" + className + "\",";
//            } else if (isFramework) {
//                MethodStr = "android.util.SLog.i(\"" + TAG + "_" + className + "\",";
//            } else {
//                MethodStr = "System.out.println(";
//            }


            if (Rule_57_LogTypeStr.equals("syso")) {
                MethodStr = "System.out.println(";
            } else if (Rule_57_LogTypeStr.equals("log")) {
                MethodStr = "android.util.Log.i(\"" + Rule_57_TAG + "_" + className + "\",";
            } else if (Rule_57_LogTypeStr.equals("slog")) {
                MethodStr = "android.util.SLog.i(\"" + Rule_57_TAG + "_" + className + "\",";
            } else {
                MethodStr = "System.out.println(";
            }


            String returnStr = methodPrint.replaceAll(holdStr, MethodStr);


//            boolean isAPP;
//            boolean isFramework;
//            boolean isAndroidClass;     //  是否是安卓项目的类
//            boolean isIDEClass;       // 是否是IDE 项目的 类


            return returnStr;
        }
    }


    static class ZMethod {
        MethodDeclaration methodDeclaration;
        NodeList<Parameter> methodParamList;
        String paramLogString;   //  参数的打印字符串
        ZClass belongClass;
        Set<Node> expressNodeList;   //  表达式结点的集合( 不重复 )
        Map<String, ArrayList<Node>> sameExpressNodeMap; // 表达式 相同的结点 但是父节点不同  比如 { int a =3  ; a=2; if(xxx) a=2;}
        String methodIdentify;   // 方法的唯一标识
        String returnString;   // 方法返回值
        String methodName;  // 方法名称
        String paramString;  // 方法参数字符串
        String ownerClassName;   // 方法拥有类名称
        String originCodeString;  // 方法的字符串集合
        String logOnlyParam_originCodeString;  //
        int methodLogIndex;
        String newCodeString;    // 已替换方法的集合
        ArrayList<String> buildIndexLogList;


        String fixnewMethodCode(String newMethodContent) {
            String flagStr = "this_is_indexLog_index=0";
            if (!newMethodContent.contains(flagStr)) {
                return newMethodContent;
            }
            String curMethodContent = newMethodContent;
            int addIntValue = 1;
            int flagIndex = newMethodContent.indexOf(flagStr);
            while (flagIndex > 0) {

                String currentLog = "this_is_indexLog_index=" + addIntValue;
                curMethodContent = curMethodContent.substring(0, flagIndex) + currentLog + curMethodContent.substring(flagIndex + flagStr.length());
                flagIndex = curMethodContent.indexOf(flagStr);
                addIntValue++;
                //System.out.println(" addIntValue = "+ addIntValue +  "   flagIndex = "+ flagIndex);

//                addIntValue = 905   flagIndex = 1398
//                addIntValue = 906   flagIndex = 1398
//                addIntValue = 907   flagIndex = 1398

            }


            return curMethodContent;
        }


        String[] tryAnalysisExpressNodeString(String nodeString) {
            String checkCode = "";
//            System.out.println(" 表达式分析 返回分析代码 " );
//            System.out.println(" 表达式:  "+  nodeString);
            // 表达式 以 // 开头 那么 就不解析
            if (nodeString.trim().startsWith("//")) {
                return null;
            }


            //   System.out.println('=');
            //   intValue = -10;  (处理)
            //   int xxx = 10;
            //  System.out.println("method1   intValue =  ge" + intValue);
            // 对于那些事赋值语句的句子 进行 代码的分析
            // 有些表达式 内的 字符串 里面 包含 等号 这些表达式 不处理
            // 1.判断是否包含等号  2.以等号分割的长度 必须等于2
            // 3. 等号前面的数值不能包含空格 不能包含双引号  单引号“ ‘
//  Map<String, String> map = new HashMap<String, String>();
            if (nodeString.contains("=")) {
                String strArr[] = nodeString.split("=");
                if (strArr.length != 2) {
                    return null;
                }  // 确保只分出两个 子subString
                //   wifiConfig = Method.xxxxx();      type = 1
                //  WifiGraturation wifiConfig = Method.xxxxx();    typ2 = 2
                // final int wifiApState = mWifiManager.getWifiApState();  type3 =3
                String variableName = "";

                String str1 = strArr[0].trim();
                String str2 = strArr[1].trim();
                variableName = str1;
                // 继续点
                if (str1.contains("\"") || str1.contains("\'")) {
                    //  不能包含双引号  单引号“ ‘
                    return null;
                }  // intValue = -10;
                int type = 1;

                if (str1.contains(" ")) {
                    String[] arrStrTest = str1.split(" ");
                    if (arrStrTest != null && arrStrTest.length == 2) {
                        type = 2;
                        variableName = arrStrTest[1].trim();
                    } else if (arrStrTest != null && arrStrTest.length == 3 && str1.contains(",") && !arrStrTest[2].contains("<") && !arrStrTest[2].contains(">")) {
// 第二种类型   //  Map<String, String> map
                        // final int wifiApState
                        type = 2;
                        variableName = arrStrTest[2].trim();

                    } else if (arrStrTest != null && arrStrTest.length == 3 && arrStrTest[0].trim().equals("final")) {
                        //   // final int wifiApState = mWifiManager.getWifiApState();
                        type = 2;
                        variableName = arrStrTest[2].trim();
                    } else {

                        return null;
                    }

                }
                //  泛华的打印Log的方法
                // variableName  指向变量名称   type标识当前的表达形式 1 2

                //  0 是打印前的Log
                // 1  是 执行后的Log
                String strShuZu[] = new String[2];

                if (type == 1) {  //  wifiConfig = Method.xxxxx();      type = 1
                    String code1 = "\nzPrintLog(" + variableName + ");\n";
                    String code2 = "\nzPrintLog(" + variableName + ");\n";
                    strShuZu[0] = code1;
                    strShuZu[1] = code2;
                    // 是否有对称的() 的 括号
                    if (!hasDoubleBlock(code1.trim()) || !hasDoubleBlock(code2.trim()) ||
                            !hasDoubleMiddleBlock(code1.trim()) || !hasDoubleMiddleBlock(code2.trim())) {
                        return null;
                    }

                } else if (type == 2) {   //  WifiGraturation wifiConfig = Method.xxxxx();    typ2 = 2
                    strShuZu[0] = "\n";
                    String code1 = "\nzPrintLog(" + variableName + ");\n";
                    strShuZu[1] = code1;

                    // 是否有对称的() 的 括号
                    if (!hasDoubleBlock(code1.trim()) || !hasDoubleMiddleBlock(code1.trim())) {
                        return null;
                    }
                }

                return strShuZu;


            } else {
                return null;
            }


        }

        static boolean hasDoubleMiddleBlock(String express) {
            boolean flag = false;
            int getStrCharNumA = calculStrCount(express, '[');
            int getStrCharNumB = calculStrCount(express, ']');

            if (getStrCharNumA == getStrCharNumB) {
                flag = true;
            }

            return flag;

        }

        static boolean hasDoubleBlock(String express) {
            boolean flag = false;
            int getStrCharNumA = calculStrCount(express, '(');
            int getStrCharNumB = calculStrCount(express, ')');

            if (getStrCharNumA == getStrCharNumB) {
                flag = true;
            }

            return flag;

        }

        static int calculStrCount(String src, char charTarget) {
            int count = 0;
            String curFixStr = src.trim();

            for (int i = 0; i < curFixStr.length(); i++) {
                char charitem = curFixStr.charAt(i);

                if (charitem == charTarget) {
                    count++;
                }
            }

            return count;
        }

        String fixExpressNodeString(String nodeString) {
            String fixStr = "";
            if (nodeString.contains("\n")) {

                String[] strArr = nodeString.split("\n");
                for (int i = 0; i < strArr.length; i++) {
                    if (!strArr[i].trim().startsWith("//")) {
                        fixStr = fixStr + strArr[i].trim();
                    }
                }

            } else {
                fixStr = nodeString;
            }

// Log if user was connected at the time of switching off.
//mMetricsFeatureProvider.action(mContext, MetricsEvent.ACTION_WIFI_OFF, mConnected.get());


            // Log if user was connected at the time of switching off.
            // mMetricsFeatureProvider.action(mContext, MetricsEvent.ACTION_WIFI_OFF, mConnected.get());
            // System.out.println("══════=== fixStr = "+ fixStr);
            return fixStr;
        }

        int getNodeLength(Node node) {
            int nodelength = 0;
            if (node.getChildNodes().size() == 0) {
//                System.out.println(" 叶子结点的类型: "+  node.getMetaModel().getType() + " 内容为: "+ node.toString());

                return 0;
            } else {
//                System.out.println(" 非叶子结点的类型: "+  node.getMetaModel().getType() + " 内容为: "+ node.toString()  );
                if (node.getMetaModel().getType() == com.github.javaparser.ast.stmt.ExpressionStmt.class) {
//                    System.out.println("═════════=表达式类型 ExpressionStmt :"+  node.getMetaModel().getType() + " 内容为: "+ node.toString()+"═════════=");

                    Node fatherNode = node.getParentNode().get();
                    int fatherNodeChildSize = 0;
                    String fatherType = "";
                    Node yeyeNode;
                    String yeyeType = "";
                    System.out.println("═══════════════════开始═════════════════════");
                    if (fatherNode != null) {


                        System.out.println("当前表达式:" + node.toString() + "   type = " + node.getMetaModel().getType());
                        System.out.println("当前表达式的子表达式大小:" + node.getChildNodes().size());
                        fatherType = fatherNode.getMetaModel().getType().toString();
                        fatherNodeChildSize = fatherNode.getChildNodes() != null ? fatherNode.getChildNodes().size() : 0;
                        System.out.println("父类的表达式: " + fatherNode.toString() + " type = " + fatherNode.getMetaModel().getType());
                        System.out.println("父类的Child-Size = " + fatherNode.getChildNodes().size());
                        for (int i = 0; i < fatherNode.getChildNodes().size(); i++) {
                            System.out.println("child[" + i + "]  str = " + fatherNode.getChildNodes().get(i).toString());
                            System.out.println("child[" + i + "]  type = " + fatherNode.getChildNodes().get(i).getMetaModel().getType());
                        }
                        yeyeNode = fatherNode.getParentNode().get();
                        if (yeyeNode != null) {
                            yeyeType = yeyeNode.getMetaModel().getType().toString();
                            System.out.println("爷爷类的表达式: " + yeyeNode.toString() + "   type = " + yeyeType);
                        }

                    }

                    System.out.println("═══════════════════结束═════════════════════");
                    int index = expressNodeList.size();
                    //   System.out.println("索引:"+index+"   *************表达式的父类表达式类型为 FatherExpressionStmt : fatherType="+fatherType+"     yeyeType="+yeyeType   + "  fatherNodeChildSize = "+ fatherNodeChildSize  );

                    // 表达式的node相同   字符串也相同的情况的处理
                    // 表达式相同  但是上下文件不同   如果在   if  表达式 ; else  表达的情况下 那么可能会造成 语法错误

                    // 对于表达式相同的node 通过ArrayList<Node> 来进行保存  通过判断父节点的类型来 得到是否添加{}
                    // 由于添加Log 是字符串匹配   对于node相同的表达式  字符串都会去匹配 replace
                    // 对于 不需要{}的 表达式  添加了 {} 导致上下文语法不通过
                    // 对于 需要{} 的 表达式  只有添加了 {} 才能使得语法通过

                    //  如果当前的表达式  不包含 这个 node  并且这个Node也包含在 相同Map 的Key中 那么 添加这个node
                    // 如果这个表达式也是 IF 下的单独表达式 那么 也需要替换
                    if (!expressNodeList.contains(node) && !sameExpressNodeMap.keySet().contains(node.toString()) &&
                            node.getParentNode().get().getMetaModel().getType() != com.github.javaparser.ast.stmt.IfStmt.class) {   // 如果有两个相同的sameExpress 那么它们仍然保存在 ArrayList<Node>无法区分
                        expressNodeList.add(node);
                    } else {

                        // 检测当前ArrayList是否为空 为空话 就创建这样的Map
                        ArrayList<Node> nodeList = sameExpressNodeMap.get(node.toString());
                        if (nodeList == null) {
                            nodeList = new ArrayList<Node>();
                        }

                        Node preSameNode = null;
                        if (expressNodeList.contains(node)) {   //  如果是第一次检测到相同  那么需要拿到之前的保存在Set的Node
                            Iterator<Node> it = expressNodeList.iterator();
                            while (it.hasNext()) {   // 拿到之前  SET 中保存的那个 表达式Node
                                Node setNode = it.next();
                                if (setNode != null && node.toString().equals(setNode.toString())) {
                                    preSameNode = setNode;
                                    break;
                                }

                            }//判断是否有下一个
                            expressNodeList.remove(node);  // 拿到之前的Node  再从Set中删除它
                        }

                        if (preSameNode != null) {   //  如果之前的Node 不为空 那么 把它取出来 放到List
                            nodeList.add(preSameNode);
                        }

                        nodeList.add(node);   //  填充当前的Node
                        sameExpressNodeMap.put(node.toString(), nodeList);

                        //  如果已经包含了这个node  那么 检查这个node是否是 if xxx ; else  xxx ; 的 情况
                        //  如果这个 node 满足 if  ; else 的 情况 需要给它 过滤 去除
                    }
                }
                List<Node> listNode = node.getChildNodes();
                nodelength = listNode.size();
                for (Node itemNode : listNode) {
                    nodelength = nodelength + getNodeLength(itemNode);

                }

            }
            return nodelength;

        }

        int checkAllNode(MethodDeclaration method) {
            if (method == null) {
                return 0;
            }
            int num = 0;
            List<Node> curList = method.getChildNodes();
            if (curList == null) {
                return 0;
            }
            num = curList.size();
            if (num == 0) {
                return 0;
            }

            for (Node itemNode : curList) {
                num = num + getNodeLength(itemNode);

            }
            return num;
        }


        synchronized String buildIndexLog() {
            String codeStr =
                    "";
            if (buildIndexLogList == null) {
                buildIndexLogList = new ArrayList<String>();
            }

            codeStr = CommonCodePrint("\"this_is_indexLog_index=" + 0 + "\"");
            // codeStr = CommonCodePrint("this_is_indexLog_index=0");
            methodLogIndex++;

            buildIndexLogList.add("this is indexLog index=" + 0);
            return codeStr;
        }


        ZMethod(ZClass parentClass, String returnString, String methodName, String paramString) {
            this.belongClass = parentClass;
            this.returnString = returnString;
            this.methodName = methodName;
            this.paramString = paramString;
            if (paramString.trim().endsWith(")") && paramString.trim().startsWith("(")) {
                this.paramString = paramString;
            } else {
                this.paramString = "(" + paramString.trim() + ")";
            }
            methodLogIndex = 0;
            this.paramString = tryFixParamFormat(this.paramString);
            this.methodIdentify = (this.returnString + " " + this.methodName + this.paramString).trim();
            this.ownerClassName = this.belongClass.className;

            this.methodDeclaration = getMethodDeclarationFromCompilationUnit(this.belongClass.zClassOrInterfaceDeclaration, methodIdentify);
            if (this.methodDeclaration == null) {
                System.out.println("解析Method为空! 程序退出");
                return;
            }
            this.methodParamList = this.methodDeclaration.getParameters();
            this.originCodeString = this.methodDeclaration.toString();
            if (this.methodParamList != null) {
                paramLogString = makeMethodParamLog(this.methodParamList);
//                System.out.println("依据参数生成的打印Log的代码如下:\n"+ paramLogString);
                // @Override public boolean onSwitchToggled(boolean isChecked, int int1, String str1, ArrayList<String> strArr, String[] strArr1, int[] arrInt)


//  @Override public boolean onSwitchToggled()  获取到这样的字符串  没有考虑到 方法头包含 /**/的情况
                String preCode = "";
                if (originCodeString.trim().startsWith("/*") && originCodeString.trim().contains("*/")) {  // 如果包含注释的话
                    String fixOriginCodeString = originCodeString.substring(originCodeString.indexOf("*/") + 2);
                    preCode = fixOriginCodeString.substring(0, fixOriginCodeString.indexOf("{") + 1).trim();
//                    System.out.println("包含 包头部含注释 preCode  :\n"+ preCode);
                } else {

                    preCode = originCodeString.substring(0, originCodeString.indexOf("{") + 1);
//                    System.out.println("不包头部含注释 preCode  :\n"+ preCode);
                }
                //  public void enableVerboseLogging(int verbose) {
                //  包含注释
                logOnlyParam_originCodeString = originCodeString.replace(preCode, preCode + "\n" + paramLogString);  //  添加了对 参数的打印的代码

                //  把包含的 注释 /***/  去掉
                if (logOnlyParam_originCodeString.trim().startsWith("/*") && logOnlyParam_originCodeString.trim().contains("*/")) {
                    logOnlyParam_originCodeString = logOnlyParam_originCodeString.substring(logOnlyParam_originCodeString.indexOf("*/") + 2);
                }

            }
//            System.out.println("方法的原始字符串:\n"+ originCodeString);
//            System.out.println("加入参数Log的字符串:\n"+ logOnlyParam_originCodeString);

            expressNodeList = new HashSet<Node>();
            //  开始处理表达式的打印
            sameExpressNodeMap = new HashMap<String, ArrayList<Node>>();
        }

        static String tryFixParamFormat(String param) {
            if (!param.contains(",")) {
                while (param.contains("  ")) {
                    param = param.replace("  ", " ");
                }
                return param.trim();
            }
            String fixParam = "";
            String[] strArr = param.split(",");
            int size = strArr.length;

            for (int i = 0; i < size; i++) {
                String curStr = strArr[i].trim();
                while (curStr.contains("  ")) {
                    curStr = curStr.replace("  ", " ");
                }
                fixParam = fixParam + curStr + ", ";
            }
            fixParam = fixParam.trim();
            while (fixParam.endsWith(",")) {
                fixParam = fixParam.substring(0, fixParam.length() - 1);

            }


//            System.out.println("fixParam = "+ fixParam);
            return fixParam;

        }


        // 1 判断基本的数据类型    基本的数据类型不用盘空  直接打印
// 2. 判断是否是基本类型的数组(该数组有多少层级)
// 3 判断如果为 对象类型  那么  需要判空  并打印
// 4.判断是否为对象的集合 (该集合内部是否还包含有集合  集合的层级) 并打印


        String makeMethodParamLog(NodeList<Parameter> paramList) {
            // 决定选择哪一种打印Log的代码
            String paramLogCode = "";
            String itemCode = "";
            for (Parameter paramItem : paramList) {
                //paramItem = boolean isChecked
                //paramItem = int int1

                if (isBasicType(paramItem.toString())) {  // 基本的 boolean  byte char  short int  long float double  8种类型

                    String Code1 = BaseTypeCode(paramItem.toString());
                    itemCode = Code1;
                    //      System.out.println(" 当前的参数是基本数据类型 boolean  byte char  short int  long float double      paramItem = "+ paramItem.toString() +"代码："+ Code1);
                } else if (isBasicShuZu(paramItem.toString())) {

                    String Code2 = BaseTypeListCode(paramItem.toString());
                    itemCode = Code2;
                    //       System.out.println(" 当前的参数是基本数据类型数组[]    paramItem = "+ paramItem.toString() +"代码："+ Code2);
                } else if (isSingleObject(paramItem.toString())) {  //  String xx  Object XX  Integer XXX
                    String Code3 = SingleObjectPrintCode(paramItem.toString());
                    itemCode = Code3;
                    // System.out.println(" 当前的参数是单个类Object类型   paramItem ="+ paramItem.toString() +"代码："+ Code3);
                } else if (isObjectArr(paramItem.toString())) {    //  String[]
                    String Code4 = ArrObjectPrintCode(paramItem.toString());
                    itemCode = Code4;
                    //     System.out.println(" 当前的参数是类的集合 类似于ArrayList<Object> Object[]   paramItem ="+ paramItem.toString()+"代码："+ Code4);
                }

                paramLogCode = paramLogCode + itemCode;

            }
            while (paramLogCode.contains("\n ")) {
                paramLogCode = paramLogCode.replaceAll("\n ", "\n");
            }
            return CommonRuntimeExceptionCodePrint() + CommonProcessAndThreadCodePrint() + paramLogCode;  // 添加所有Log的地方
        }


        static Set<String> ListTypeList = new HashSet<String>();

        {

            ListTypeList.add("Collection");
            ListTypeList.add("List");
            ListTypeList.add("Vector");
            ListTypeList.add("Stack");
            ListTypeList.add("Deque");
            ListTypeList.add("LinkedBlockingDeque");
            ListTypeList.add("Queue");
            ListTypeList.add("ArrayDeque");
            ListTypeList.add("BlockingQueue");
            ListTypeList.add("LinkedTransferQueue");
            ListTypeList.add("LinkedBlockingQueue");
            ListTypeList.add("PriorityQueue");
            ListTypeList.add("ArrayList");
            ListTypeList.add("LinkedList");
            ListTypeList.add("SortedList");
            ListTypeList.add("Map");
            ListTypeList.add("HashMap");
            ListTypeList.add("TreeMap");
            ListTypeList.add("LinkedHashMap");
            ListTypeList.add("SortedMap");
            ListTypeList.add("WeakHashMap");
            ListTypeList.add("ConcurrentHashMap");
            ListTypeList.add("Set");
            ListTypeList.add("EnumSet");
            ListTypeList.add("SortedSet");
            ListTypeList.add("HashSet");
            ListTypeList.add("TreeSet");
            ListTypeList.add("LinkedHashSet");
            ListTypeList.add("CopyOnWriteArraySet");
            ListTypeList.add("Hashtable");
            ListTypeList.add("Iterator");
            ListTypeList.add("Iterable");


            //  Iterable<String>  itable;
            //   Iterator<String> itStr;
            //     ConcurrentHashMap cMap;
            //  BlockingQueue blockque;
            //      CopyOnWriteArraySet arrayset;
//            LinkedHashMap<String,String>  linkMap;
//            LinkedBlockingDeque<String> lk;
//            LinkedTransferQueue<String> lt;
            // Hashtable<String,String> strtable;
            // WeakHashMap<String,String> weekMap;
            //   SortedMap<String,String> sortedMap ;
            //  SortedSet<String> sortedSet ;
            // EnumSet<String> enumSet;
            //    Queue<String> q ;
            //    Vector<String> vec;
            //   Stack<String> stack;
            //   Deque<String> deque;
            //  ArrayDeque<String> arrDeq;
            //  PriorityQueue<String> queue;
        }


        static boolean isObjectArr(String params) {
            boolean isObjectArr = false;
            if (!params.contains(" ")) { // 并不包含空格说明这个参数的格式错误
                //  System.out.println(" 当前参数字符串不符合   参数类型_空格_参数名  的格式 !  解析错误！ params="+ params);
                return false;

            }
            String[] paramArr = params.split(" ");
            if (paramArr.length == 2 && !params.contains(",")) {  // ArrList<Object> arr   ArrayList<List<XX>> map;
                isObjectArr = isArrObjectTypeString(paramArr[0]);           //   paramItem =Map<String, Object> mapValue
            } else if (params.contains(",") && params.contains("<") && params.contains(">")) { // param = Map<String, Object> mapValue

                isObjectArr = isArrObjectTypeString(params.substring(0, params.lastIndexOf(">") + 1).replace(" ", ""));
            } else {

                //   System.out.println(" ═══==当前参数字符串 !  解析错误！══════==");
            }


            return isObjectArr;

        }


        static boolean isArrObjectTypeString(String type) {  //     String xx  Object XX  Integer XXX
            boolean isArrObjectTypeString = false;
            if (!basicTypeList.contains(type.trim()) || type.contains("[]")) {   // ArrayList
                isArrObjectTypeString = true;
                return isArrObjectTypeString;
            }

            for (String curListType : ListTypeList) {
                if (type.contains(curListType)) {
                    isArrObjectTypeString = true;
                    break;
                }
            }
            return isArrObjectTypeString;
        }


        static boolean isSingleObject(String params) {
            boolean isSingleObject = false;
            if (!params.contains(" ")) { // 并不包含空格说明这个参数的格式错误
                System.out.println(" 当前参数字符串不符合   参数类型_空格_参数名  的格式 !  解析错误！");
                return false;

            }
            String[] paramArr = params.split(" ");
            if (paramArr.length != 2) {
                //  System.out.println(" 当前参数字符串不符合   参数类型_空格_参数名  的格式  解析的长度不为2 !  解析错误！");
                return false;
            }

            isSingleObject = isSingleObjectTypeString(paramArr[0]);

            return isSingleObject;

        }

        static boolean isSingleObjectTypeString(String type) {  //     String xx  Object XX  Integer XXX
            boolean isSingleObjectTypeString = true;
            if (!basicTypeList.contains(type.trim()) && !type.contains("[]")) {   // ArrayList
                for (String curListType : ListTypeList) {
                    if (type.contains(curListType)) {
                        isSingleObjectTypeString = false;
                        break;
                    }
                }
            } else if (type.contains("[]")) {
                isSingleObjectTypeString = false;  // 对象数组   不是单独的对象
            }
            return isSingleObjectTypeString;
        }


        static boolean isBasicShuZu(String params) {
            boolean isBasic = false;
            if (!params.contains(" ")) { // 并不包含空格说明这个参数的格式错误
                System.out.println(" 当前参数字符串不符合   参数类型_空格_参数名  的格式 !  解析错误！");
                return false;

            }
            String[] paramArr = params.split(" ");
            if (paramArr.length != 2) {
                //    System.out.println(" 当前参数字符串不符合   参数类型_空格_参数名  的格式  解析的长度不为2 !  解析错误！");
                return false;
            }

            isBasic = isBasicShuzuTypeString(paramArr[0]);

            return isBasic;

        }

        static boolean isBasicShuzuTypeString(String type) {  // byte[] int[]  long[]
            boolean isBasicShuZu = false;
            String curType = new String(type);
            curType = curType.replace("[]", "").trim();  // byte[] ->  byte
            if (basicTypeList.contains(curType.trim()) && type.contains("[]")) {
                isBasicShuZu = true;
            }
            return isBasicShuZu;
        }


        static boolean isBasicType(String params) {
            boolean isBasic = false;
            if (!params.contains(" ")) { // 并不包含空格说明这个参数的格式错误
                System.out.println(" 当前参数字符串不符合   参数类型_空格_参数名  的格式 !  解析错误！");
                return false;

            }
            String[] paramArr = params.split(" ");
            if (paramArr.length != 2) {
                //   System.out.println(" 当前参数字符串不符合   参数类型_空格_参数名  的格式  解析的长度不为2 !  解析错误！");
                return false;
            }

            isBasic = isBasicTypeString(paramArr[0]);

            return isBasic;
        }

        static Set<String> basicTypeList = new HashSet<String>();

        {
            basicTypeList.add("boolean");
            basicTypeList.add("byte");
            basicTypeList.add("char");
            basicTypeList.add("short");
            basicTypeList.add("int");
            basicTypeList.add("long");
            basicTypeList.add("float");
            basicTypeList.add("double");
        }

        static boolean isBasicTypeString(String type) {
            boolean isBasic = false;
            if (basicTypeList.contains(type.trim())) {
                isBasic = true;
            }
            return isBasic;
        }


        String ArrObjectPrintCode(String paramString) {
            String[] param = paramString.split(" ");
            String baseType = param[0];
            String bsseTypeName = param[1];
//            String[] strArr = {"A","B"};
//            int zBaseListSize = strArr.length;
//            for (int zindex = 0 ; zindex < zBaseListSize ; zindex++ ){
//                System.out.println("zindex "+zindex +" : " + strArr[zindex].toString());
//            }

            if (baseType.contains("[]")) {  // String[]  Object[]

                //String code1 = "\nint zBaseListSize = " + bsseTypeName+".length;";
                // String code2 = "\nfor (int zindex = 0 ; zindex < zBaseListSize ; zindex++ ){";
                String code1 = "\n  if( " + bsseTypeName + " != null ){";
                String code2 = "\nfor (int zindex = 0 ; zindex < " + bsseTypeName + ".length" + " ; zindex++ ){";
                String code3 = "\"" + paramString + "  zindex = \" + zindex +\"   :  value= \" + " + bsseTypeName + "[zindex].toString()";      //  " zindex "+zindex +" : " + intArr[zindex]
                String code3_code = CommonCodePrint(code3);
                String code4 = "}  \n";
                String code5 = "}  \nelse { ";
                String code6 = CommonCodePrint("\"" + bsseTypeName + " is null !\"");
                String code7 = "} \n";

                return code1 + code2 + code3_code + code4 + code5 + code6 + code7;
            }
            String codeStr = "";
            if (paramString.contains("<") && paramString.contains(">") && !paramString.contains(",") &&
                    !paramString.contains("map") && !paramString.contains("Map")) {    // List 类型
                codeStr = getCodePrintForCollect(baseType, bsseTypeName);
            } else if (paramString.contains("<") && paramString.contains(">") && paramString.contains(",")) {
                //  map的类型
                // paramString  MAP类型 = Map<String, Object> mapValue
                //   System.out.println("paramString  MAP类型 = "+ paramString );
                String type = paramString.substring(0, paramString.lastIndexOf(">") + 1).replace(" ", "");
                String typeName = paramString.substring(paramString.lastIndexOf(">") + 1);
                codeStr = getCodePrintForCollect(type, typeName);
            }


            //  String codeStr = CommonCodePrint(bsseTypeName+".toString()");
            return codeStr;
        }

        String getCodePrintForCollect(String param1, String param2) {
            String paramName = param1.trim() + " " + param2.trim();
            String baseType = param1;
            String baseTypeName = param2;
//            System.out.println(" baseType ="+ baseType + "    bsseTypeName="+ baseTypeName );

// HashMap 例子
//HashMap map =new HashMap<>();
//map.entrySet().iterator();

// TreeMap 例子
//TreeMap map =new TreeMap<>();
//map.entrySet().iterator();

// LinkedHashMap 例子
//LinkedHashMap map =new LinkedHashMap<>();
//map.entrySet().iterator();

// SortedMap 例子  SortedMap 是抽象类
//SortedMap map  = null;
//map.entrySet().iterator();


// WeakHashMap 例子
//WeakHashMap map =new WeakHashMap<>();
//map.entrySet().iterator();


// ConcurrentHashMap 例子
//ConcurrentHashMap map =new ConcurrentHashMap<>();
//map.entrySet().iterator();


// Hashtable 例子
//Hashtable linkQueue = null ;
//Iterator iterator =    linkQueue.entrySet().iterator();
//iterator.hasNext();
//Map.Entry<String , String> entrya = (Map.Entry<String , String>) iterator.next();
//entrya.getKey();
//entrya.getValue();
            String paramType = "";
            String keyStringType = "";
            String valueStringType = "";
            if (param1.contains("<") && param1.contains(">") && param1.contains(",")) {  //  Map 包含 <String, String>
                paramType = param1.substring(0, param1.indexOf("<"));
                if (param1.contains("Map") || param1.contains("map")) {
                    keyStringType = param1.substring(param1.indexOf("<") + 1, param1.indexOf(","));
                    valueStringType = param1.substring(param1.indexOf(",") + 1, param1.lastIndexOf(">"));
                } else {
                    // 是List的 情况
                    valueStringType = param1.substring(param1.indexOf("<") + 1, param1.indexOf(">"));
                }

            } else if (param1.contains("<") && param1.contains(">") && !param1.contains(",")) {  //   paramItem =ArrayList<String> strArr   param1=ArrayList<String>
                paramType = param1.substring(0, param1.indexOf("<"));
                keyStringType = "";
                valueStringType = param1.substring(param1.indexOf("<") + 1, param1.indexOf(">"));
            } else {
                paramType = param1.trim();
                valueStringType = baseTypeName;
            }

            String code0 = "\n  if( " + baseTypeName + " != null ){";
            if (paramType.endsWith("Map") || "Hashtable".equals(paramType)) {   // 当前 类型是 Map的类型
                String code1 = "";
                if (!keyStringType.isEmpty() && !valueStringType.isEmpty()) {
                    code1 = "\nMap.Entry<" + keyStringType + " , " + valueStringType + "> entry = null;";
                } else {
                    System.out.println("获取到的Map中的key 和 value 为空  出现错误 将退出！  param1 = " + param1);
                    return null;
                }
                //   String code2 = "\n if("+bsseTypeName+" != null){";
                String code3 = "\n java.util.Iterator iterator = " + baseTypeName + ".entrySet().iterator();";
                String code3_1 = "\n int mZindex = 0 ;";
                String code4 = "\n while( iterator.hasNext() ){";

                String code5 = "\n entry = (Map.Entry<" + keyStringType + "," + valueStringType + ">) iterator.next();";
                String code6 = "\"" + baseTypeName + "    index =" + "\"+ mZindex + \"   " + "  entry.Key= \"" + "+ entry.getKey() +" + " \" entry.Value=\"" + "+ entry.getValue()";  // 继续点
                String code6_fix = CommonCodePrint(code6);
                String code6_1 = " mZindex ++ ;";
                String code7 = " }";
                // String code8 = "\n }";

                String code9 = "}  \nelse { ";
                String code10 = CommonCodePrint("\"" + baseTypeName + " is null !\"");
                String code11 = "} \n";

//  Map.Entry<String , ArrayList<String> > entry;
// Map 的 例子
//            Map<String,String> map = null;
//            Map.Entry<String , String> entry;
//            if(map != null){
//                Iterator iterator = map.entrySet().iterator();
//                while( iterator.hasNext() ){
//                    entry = (Map.Entry<String , String>) iterator.next();
//                    entry.getKey();  //Map的Value
//                    entry.getValue();  //Map的Value
//                    System.out.println("zukgit0725"+"entry.getKey()= "+entry.getKey() +" ----entry.getValue()="+entry.getValue());
//                }
//            }

                return code0 + code1 + code3 + code3_1 + code4 + code5 + code6_fix + code6_1 + code7 + code9 + code10 + code11;

            } else if (paramType.endsWith("Set") || paramType.endsWith("List") || paramType.endsWith("Queue") || paramType.endsWith("Deque") ||
                    paramType.endsWith("Stack") || paramType.endsWith("Vector") || paramType.endsWith("Collection")) {
// 当前的是一个List<>   valueStringType 代表当前《》 中的内容
// CopyOnWriteArraySet linkQueue = null ;
//Object[] objectList  = linkQueue.toArray();
//for(int zindex =0 ; zindex < linkQueue.size(); zindex ++){
//System.out.println("zindex "+zindex +" : " + objectList[zindex].toString());
//}
                String code0_list = "\n  if( " + baseTypeName + " != null ){";
                String code1 = "\n Object[] objectList  =" + baseTypeName + ".toArray();";
                String code2 = "\n  for(int zindex =0 ; zindex < " + baseTypeName + ".size(); zindex ++){";
                String code3 = " \"" + paramName + "  index =\"+zindex +" + "\" value :\" + " + "objectList[zindex].toString()";
                String code3_fix = CommonCodePrint(code3);
                String code4 = " }";
                String code5 = "\n}  \nelse { ";
                String code6 = CommonCodePrint("\"" + paramName + " is null !\"");
                String code7 = "} \n";


                return code0_list + code1 + code2 + code3_fix + code4 + code5 + code6 + code7;  // 继续点
            } else {
                // 其余以外的数组关键字  直接  toString 了
                // paramType=Map<String,  valueStringType =Object>
                //    System.out.println("无法判断集合的类型  paramType="+paramType.toString() +"  valueStringType ="+ valueStringType);

                if (checkValueStringType(valueStringType.trim())) {
                    //  包含 .>
                    return CommonCodePrint("\"" + baseTypeName + "=\"+" + baseTypeName + ".toString()");
                }
                // PemessionState>
                return CommonCodePrint(valueStringType.trim() + ".toString()");
            }

            //  Map 需要获取 Key 和 Value的 类型  否则无法转换
            // ═══════════════=   通用 ════════════===

            //    return "";
        }

        static boolean checkValueStringType(String typeStr) {
            boolean flag = true;

            if (typeStr.contains(".>") || typeStr.contains(">.")) {

                flag = false;
            }

            return flag;

        }




        String SingleObjectPrintCode(String paramString) {
            String[] param = paramString.split(" ");
            String baseType = param[0];
            String bsseTypeName = param[1];
            String code1 = "\n if(" + bsseTypeName + " != null ) {";
            String code2 = CommonCodePrint("\"" + paramString + " = \" + " + bsseTypeName + ".toString()");
            String code3 = " } \nelse { ";
            String code4 = CommonCodePrint("\"" + paramString + " ==  null\"  ");
            String code5 = "}\n";
            return code1 + code2 + code3 + code4 + code5;
        }


        public static void getKeyAndValue(Map<String, String> map) {
            Map.Entry<String, String> entry;
            if (map != null) {
                Iterator iterator = map.entrySet().iterator();
                while (iterator.hasNext()) {
                    entry = (Map.Entry<String, String>) iterator.next();
                    entry.getKey();  //Map的Value
                    entry.getValue();  //Map的Value
                    //  System.out.println("zukgit0725"+"entry.getKey()= "+entry.getKey() +" ----entry.getValue()="+entry.getValue());
                }
            }
        }

        String BaseTypeListCode(String paramString) {
//            int[] intArr = {1,2,4};
//            int zBaseListSize = intArr.length;
//            for (int zindex = 0 ; zindex < zBaseListSize ; zindex++ ){
//                System.out.println("zindex "+zindex +" : " + intArr[zindex]);
//            }


            String[] param = paramString.split(" ");
            String baseType = param[0];
            String bsseTypeName = param[1];
            //  String code1 = "\nint zBaseListSize = " + bsseTypeName+".length;";
            String code1 = "";
            String code2 = "\nfor (int zindex = 0 ; zindex < " + bsseTypeName + ".length" + " ; zindex++ ){";
            String code3 = "\"" + paramString + "----index = \" + zindex +\" : \" +  \"  value = \" + " + bsseTypeName + "[zindex]";      //  " zindex "+zindex +" : " + intArr[zindex]
            String code3_code = CommonCodePrint(code3);
            String code4 = "}\n";

            return code1 + code2 + code3_code + code4;
        }


        String BaseTypeCode(String paramString) {
            String[] param = paramString.split(" ");
            String baseType = param[0];
            String bsseTypeName = param[1];
            String code = "\"" + paramString + " = \" + " + bsseTypeName;
            return CommonCodePrint(code);
        }


        String getRuntimeExceptionCode() {
            String excepCode = "";
            return excepCode;

        }

        String CommonCodePrint(String paramString) {    //  boolean  falg |  String like  | ArrayList List  | XXX xClass
            String realPrintCode = "";
            //  String tagMethod = TAG+"_"+this.methodName;
            String tagMethod = Rule_57_TAG + "_" + this.belongClass.className + "_" + this.methodName;

//            if (this.belongClass.isIDEClass) {
//                realPrintCode = "\nSystem.out.println( " + "\" " + tagMethod + "   \" + " + paramString + ");\n";
//            } else if (this.belongClass.isAndroidClass && this.belongClass.isAPP) {
//                // android.util.Log.i
//                realPrintCode = "\nandroid.util.Log.i(\"" + tagMethod + "\"," + paramString + ");\n";
//            } else if (this.belongClass.isAndroidClass && this.belongClass.isFramework) {
//                realPrintCode = "\nandroid.util.Slog.i(\"" + tagMethod + "\"," + paramString + ");\n";
//            }



            if (Rule_57_LogTypeStr.equals("syso")) {
                realPrintCode = "\nSystem.out.println( " + "\" " + tagMethod + "   \" + " + paramString + ");\n";

            }else if(Rule_57_LogTypeStr.equals("log")) {
                realPrintCode = "\nandroid.util.Log.i(\"" + tagMethod + "\"," + paramString + ");\n";

            }else if(Rule_57_LogTypeStr.equals("slog")) {
                realPrintCode = "\nandroid.util.Slog.i(\"" + tagMethod + "\"," + paramString + ");\n";

            }else {
                realPrintCode = "\nSystem.out.println( " + "\" " + tagMethod + "   \" + " + paramString + ");\n";

            }




//            if (LogTypeStr.equals("syso")) {
//
//            }else if(LogTypeStr.equals("log")) {
//
//            }else if(LogTypeStr.equals("slog")) {
//
//            }else {
//
//            }


            return realPrintCode;
        }


        // IDEA 打印
//        RuntimeException re = new RuntimeException();
//        re.fillInStackTrace();
//        re.printStackTrace();

        //  APP层面 安卓打印
//        RuntimeException re = new RuntimeException();
//        re.fillInStackTrace();
//        android.util.Log.v("zukgit", "RuntimeException", re);

        //  Framework层面 安卓打印
//        RuntimeException re = new RuntimeException();
//        re.fillInStackTrace();
//        android.util.SLog.v("zukgit", "RuntimeException", re);

        String CommonProcessAndThreadCodePrint() {
            String strCode1 = "";
            String strCode2 = "";
            String strCode3 = "";

            String tagMethod = Rule_57_TAG + "_" + this.belongClass.className + "_" + this.methodName;

//            if (this.belongClass.isIDEClass) {
//                String re_Name = "re" + System.currentTimeMillis();
//                strCode1 = "\nRuntimeException " + re_Name + " = new RuntimeException();";
//                strCode2 = "\n" + re_Name + ".fillInStackTrace();";
//                String tag = "\nSystem.out.println( " + "\" " + tagMethod + "   RuntimeException.fillInStackTrace() \" );";
//                strCode3 = tag + "\n" + re_Name + ".printStackTrace();\n";
//
//            } else if (this.belongClass.isAndroidClass && this.belongClass.isAPP) {
//                // android.util.Log.i
//                String re_Name = "re" + System.currentTimeMillis();
//                strCode1 = "\nRuntimeException " + re_Name + " = new RuntimeException();";
//                strCode2 = "\n" + re_Name + ".fillInStackTrace();";
//                strCode3 = "\nandroid.util.Log.i(\"" + tagMethod + "\", \"RuntimeException\", " + re_Name + " );\n";
//            } else if (this.belongClass.isAndroidClass && this.belongClass.isFramework) {
//                String re_Name = "re" + System.currentTimeMillis();
//                strCode1 = "\nRuntimeException " + re_Name + " = new RuntimeException();";
//                strCode2 = "\n" + re_Name + ".fillInStackTrace();";
//                strCode3 = "\nandroid.util.SLog.i(\"" + tagMethod + "\", \"RuntimeException\", " + re_Name + " );\n";
//            }


            if (Rule_57_LogTypeStr.equals("syso")) {
                String re_Name = "re" + System.currentTimeMillis();
                strCode1 = "\nRuntimeException " + re_Name + " = new RuntimeException();";
                strCode2 = "\n" + re_Name + ".fillInStackTrace();";
                String tag = "\nSystem.out.println( " + "\" " + tagMethod + "   RuntimeException.fillInStackTrace() \" );";
                strCode3 = tag + "\n" + re_Name + ".printStackTrace();\n";

            }else if(Rule_57_LogTypeStr.equals("log")) {

                // android.util.Log.i
                String re_Name = "re" + System.currentTimeMillis();
                strCode1 = "\nRuntimeException " + re_Name + " = new RuntimeException();";
                strCode2 = "\n" + re_Name + ".fillInStackTrace();";
                strCode3 = "\nandroid.util.Log.i(\"" + tagMethod + "\", \"RuntimeException\", " + re_Name + " );\n";


            }else if(Rule_57_LogTypeStr.equals("slog")) {

                String re_Name = "re" + System.currentTimeMillis();
                strCode1 = "\nRuntimeException " + re_Name + " = new RuntimeException();";
                strCode2 = "\n" + re_Name + ".fillInStackTrace();";
                strCode3 = "\nandroid.util.SLog.i(\"" + tagMethod + "\", \"RuntimeException\", " + re_Name + " );\n";


            }else {

                String re_Name = "re" + System.currentTimeMillis();
                strCode1 = "\nRuntimeException " + re_Name + " = new RuntimeException();";
                strCode2 = "\n" + re_Name + ".fillInStackTrace();";
                String tag = "\nSystem.out.println( " + "\" " + tagMethod + "   RuntimeException.fillInStackTrace() \" );";
                strCode3 = tag + "\n" + re_Name + ".printStackTrace();\n";


            }


//       if (LogTypeStr.equals("syso")) {
//
//        }else if(LogTypeStr.equals("log")) {
//
//        }else if(LogTypeStr.equals("slog")) {
//
//        }else {
//
//        }

            return strCode1 + strCode2 + strCode3;
        }


        String CommonRuntimeExceptionCodePrint() {    //  boolean  falg |  String like  | ArrayList List  | XXX xClass
            String tagMethod = Rule_57_TAG + "_" + this.belongClass.className + "_" + this.methodName;
            String stackName = "stacks" + System.currentTimeMillis();
            String strCode1 = "\njava.util.Map<Thread, StackTraceElement[]> " + stackName + " = Thread.getAllStackTraces();";
            String threadSet_Name = "threadSet" + System.currentTimeMillis();
            String strCode2 = "\njava.util.Set<Thread> " + threadSet_Name + " = " + stackName + ".keySet();";
            String strCode3 = "";
            String getProcessStr = "";
            String threadNum_Name = "threadNum" + System.currentTimeMillis();
            String strCode4 = "\nint " + threadNum_Name + " = 1;";
            String strCode5 = "\nfor (Thread key : " + threadSet_Name + ") {";

            String strCode6 = "\nStackTraceElement[] stackTraceElements = " + stackName + ".get(key);";
            String strCode6_fix = "";
            String strCode7 = "\nfor (StackTraceElement st : stackTraceElements) {";
            String strCode7_fix = "";
            String strCode8 = "\n}";
            String strCode8_fix = "";
            String strCode9 = "\n}";


//                for (Thread key : threadSet) {
//                    StackTraceElement[] stackTraceElements = stacks.get(key);
//                    System.out.println("\n════════════ 线程名称threadName:【 " + key.getName() + "】  进程ID-ProcessID:【"+mProcessId + "】  线程ID-ThreadId:【"+key.getId()+ "】  线程序号-indexId: 【"+ (threadNum++)+ "】 start ══════════");
//                    for (StackTraceElement st : stackTraceElements) {
//                        System.out.println( "StackTraceElement: " + st.toString());
//                    }
//                    System.out.println("════════════ 线程名称threadName: 【" + key.getName() + "】 end ════════════\n");
//                }




//            if (this.belongClass.isIDEClass) {
//                String runtimeMXBean_Name = "runtimeMXBean" + System.currentTimeMillis();
//                getProcessStr = "\njava.lang.management.RuntimeMXBean  " + runtimeMXBean_Name + " = java.lang.management.ManagementFactory.getRuntimeMXBean();";
//                String mProcessId_Name = "mProcessId" + System.currentTimeMillis();
//                String pCodeStr1 = "\nint " + mProcessId_Name + "  =  Integer.valueOf(" + runtimeMXBean_Name + ".getName().split(\"@\")[0]).intValue();";
//                getProcessStr = getProcessStr + pCodeStr1;
//                // System.out.println("\n════════════ 线程名称threadName:【 " + key.getName() + "】  进程ID-ProcessID:【"+mProcessId + "】  线程ID-ThreadId:【"+key.getId()+ "】  线程序号-indexId: 【"+ (threadNum++)+ "】 start ══════════");
//                //    双引号包住愿有的引号
//                strCode6_fix = "\nSystem.out.println( " + "\" " + tagMethod + " \" +" + "\" \\n  线程索引序号下标 【 \"" + " + (" + threadNum_Name + ") +" + "\" 】════════════ 线程名称threadName:【\"" + " + key.getName() + " + " \"  】  进程ID-ProcessID:【 \"" + "+ " + mProcessId_Name + " +  " + " \" 】  线程ID-ThreadId:【 \" " + "+key.getId()+ " + " \" 】 \" );";
//                strCode7_fix = "\nSystem.out.println( st.toString() );";
//                strCode8_fix = "\nSystem.out.println( " + "\" " + tagMethod + " \" + " + "\" \\n  线程索引序号下标 【 \"" + " + (" + threadNum_Name + "++)+ " + "\"  】════════════\" );";
//            } else if (this.belongClass.isAndroidClass && this.belongClass.isAPP) {
//                // android.util.Log.i  int mProcessId = android.os.Process.myPid();
//                String mProcessId_Name = "mProcessId" + System.currentTimeMillis();
//                getProcessStr = "\n int " + mProcessId_Name + " = android.os.Process.myPid();";
//                String strCode6_fix_1 = "\" " + tagMethod + " \" +" + "\" \\n  线程索引序号下标 【 \"" + " +(" + threadNum_Name + ") +" + "\" 】════════════ 线程名称threadName:【\"" + " + key.getName() + " + " \"  】  进程ID-ProcessID:【 \"" + "+ " + mProcessId_Name + " +  " + " \" 】  线程ID-ThreadId:【 \" " + "+key.getId()+ " + " \" 】 \" ";
//                strCode6_fix = "\nandroid.util.Log.i(\"" + tagMethod + "\"," + strCode6_fix_1 + ");\n";
//                strCode7_fix = "\nandroid.util.Log.i(\"" + tagMethod + "\"," + " \"StackTraceElement:\"  + " + strCode6_fix_1 + ");\n";
//                String strCode8_fix_1 = "\" " + tagMethod + " \" +" + "\" \\n  线程索引序号下标 【 \"" + "+ (" + threadNum_Name + "++) +" + "\" 】════════════打印结束\" ";
//                strCode8_fix = "\nandroid.util.Log.i(\"" + tagMethod + "\"," + " \"StackTraceElement:\"  + " + strCode8_fix_1 + ");\n";
//            } else if (this.belongClass.isAndroidClass && this.belongClass.isFramework) {
//                // android.util.SLog.i
//                String mProcessId_Name = "mProcessId" + System.currentTimeMillis();
//                getProcessStr = "\n int " + mProcessId_Name + " = android.os.Process.myPid();";
//                String strCode6_fix_1 = "\" " + tagMethod + " \" + " + "\" \\n  线程索引序号下标 【 \"" + " +(" + threadNum_Name + ")+ " + "\" 】════════════ 线程名称threadName:【\"" + " + key.getName() + " + " \"  】  进程ID-ProcessID:【 \"" + "+ " + mProcessId_Name + " +  " + " \" 】  线程ID-ThreadId:【 \" " + "+key.getId()+ " + " \" 】 \" ";
//                strCode6_fix = "\nandroid.util.SLog.i(\"" + tagMethod + "\"," + strCode6_fix_1 + ");\n";
//                strCode7_fix = "\nandroid.util.Sog.i(\"" + tagMethod + "\"," + " \"StackTraceElement:\"  + " + strCode6_fix_1 + ");\n";
//                String strCode8_fix_1 = "\" " + tagMethod + " \" + " + "\" + \\n  线程索引序号下标 【 \"" + " +(" + threadNum_Name + "++)+ " + "\" 】════════════打印结束\" ";
//                strCode8_fix = "\nandroid.util.Sog.i(\"" + tagMethod + "\"," + " \"StackTraceElement:\"  + " + strCode8_fix_1 + ");\n";
//            }
//



            if (Rule_57_LogTypeStr.equals("syso")) {
                String runtimeMXBean_Name = "runtimeMXBean" + System.currentTimeMillis();
                getProcessStr = "\njava.lang.management.RuntimeMXBean  " + runtimeMXBean_Name + " = java.lang.management.ManagementFactory.getRuntimeMXBean();";
                String mProcessId_Name = "mProcessId" + System.currentTimeMillis();
                String pCodeStr1 = "\nint " + mProcessId_Name + "  =  Integer.valueOf(" + runtimeMXBean_Name + ".getName().split(\"@\")[0]).intValue();";
                getProcessStr = getProcessStr + pCodeStr1;
                // System.out.println("\n════════════ 线程名称threadName:【 " + key.getName() + "】  进程ID-ProcessID:【"+mProcessId + "】  线程ID-ThreadId:【"+key.getId()+ "】  线程序号-indexId: 【"+ (threadNum++)+ "】 start ══════════");
                //    双引号包住愿有的引号
                strCode6_fix = "\nSystem.out.println( " + "\" " + tagMethod + " \" +" + "\" \\n  线程索引序号下标 【 \"" + " + (" + threadNum_Name + ") +" + "\" 】════════════ 线程名称threadName:【\"" + " + key.getName() + " + " \"  】  进程ID-ProcessID:【 \"" + "+ " + mProcessId_Name + " +  " + " \" 】  线程ID-ThreadId:【 \" " + "+key.getId()+ " + " \" 】 \" );";
                strCode7_fix = "\nSystem.out.println( st.toString() );";
                strCode8_fix = "\nSystem.out.println( " + "\" " + tagMethod + " \" + " + "\" \\n  线程索引序号下标 【 \"" + " + (" + threadNum_Name + "++)+ " + "\"  】════════════\" );";



            }else if(Rule_57_LogTypeStr.equals("log")) {

                // android.util.Log.i  int mProcessId = android.os.Process.myPid();
                String mProcessId_Name = "mProcessId" + System.currentTimeMillis();
                getProcessStr = "\n int " + mProcessId_Name + " = android.os.Process.myPid();";
                String strCode6_fix_1 = "\" " + tagMethod + " \" +" + "\" \\n  线程索引序号下标 【 \"" + " +(" + threadNum_Name + ") +" + "\" 】════════════ 线程名称threadName:【\"" + " + key.getName() + " + " \"  】  进程ID-ProcessID:【 \"" + "+ " + mProcessId_Name + " +  " + " \" 】  线程ID-ThreadId:【 \" " + "+key.getId()+ " + " \" 】 \" ";
                strCode6_fix = "\nandroid.util.Log.i(\"" + tagMethod + "\"," + strCode6_fix_1 + ");\n";
                strCode7_fix = "\nandroid.util.Log.i(\"" + tagMethod + "\"," + " \"StackTraceElement:\"  + " + strCode6_fix_1 + ");\n";
                String strCode8_fix_1 = "\" " + tagMethod + " \" +" + "\" \\n  线程索引序号下标 【 \"" + "+ (" + threadNum_Name + "++) +" + "\" 】════════════打印结束\" ";
                strCode8_fix = "\nandroid.util.Log.i(\"" + tagMethod + "\"," + " \"StackTraceElement:\"  + " + strCode8_fix_1 + ");\n";


            }else if(Rule_57_LogTypeStr.equals("slog")) {

                // android.util.SLog.i
                String mProcessId_Name = "mProcessId" + System.currentTimeMillis();
                getProcessStr = "\n int " + mProcessId_Name + " = android.os.Process.myPid();";
                String strCode6_fix_1 = "\" " + tagMethod + " \" + " + "\" \\n  线程索引序号下标 【 \"" + " +(" + threadNum_Name + ")+ " + "\" 】════════════ 线程名称threadName:【\"" + " + key.getName() + " + " \"  】  进程ID-ProcessID:【 \"" + "+ " + mProcessId_Name + " +  " + " \" 】  线程ID-ThreadId:【 \" " + "+key.getId()+ " + " \" 】 \" ";
                strCode6_fix = "\nandroid.util.SLog.i(\"" + tagMethod + "\"," + strCode6_fix_1 + ");\n";
                strCode7_fix = "\nandroid.util.Sog.i(\"" + tagMethod + "\"," + " \"StackTraceElement:\"  + " + strCode6_fix_1 + ");\n";
                String strCode8_fix_1 = "\" " + tagMethod + " \" + " + "\" + \\n  线程索引序号下标 【 \"" + " +(" + threadNum_Name + "++)+ " + "\" 】════════════打印结束\" ";
                strCode8_fix = "\nandroid.util.Sog.i(\"" + tagMethod + "\"," + " \"StackTraceElement:\"  + " + strCode8_fix_1 + ");\n";

            }else {

                String runtimeMXBean_Name = "runtimeMXBean" + System.currentTimeMillis();
                getProcessStr = "\njava.lang.management.RuntimeMXBean  " + runtimeMXBean_Name + " = java.lang.management.ManagementFactory.getRuntimeMXBean();";
                String mProcessId_Name = "mProcessId" + System.currentTimeMillis();
                String pCodeStr1 = "\nint " + mProcessId_Name + "  =  Integer.valueOf(" + runtimeMXBean_Name + ".getName().split(\"@\")[0]).intValue();";
                getProcessStr = getProcessStr + pCodeStr1;
                // System.out.println("\n════════════ 线程名称threadName:【 " + key.getName() + "】  进程ID-ProcessID:【"+mProcessId + "】  线程ID-ThreadId:【"+key.getId()+ "】  线程序号-indexId: 【"+ (threadNum++)+ "】 start ══════════");
                //    双引号包住愿有的引号
                strCode6_fix = "\nSystem.out.println( " + "\" " + tagMethod + " \" +" + "\" \\n  线程索引序号下标 【 \"" + " + (" + threadNum_Name + ") +" + "\" 】════════════ 线程名称threadName:【\"" + " + key.getName() + " + " \"  】  进程ID-ProcessID:【 \"" + "+ " + mProcessId_Name + " +  " + " \" 】  线程ID-ThreadId:【 \" " + "+key.getId()+ " + " \" 】 \" );";
                strCode7_fix = "\nSystem.out.println( st.toString() );";
                strCode8_fix = "\nSystem.out.println( " + "\" " + tagMethod + " \" + " + "\" \\n  线程索引序号下标 【 \"" + " + (" + threadNum_Name + "++)+ " + "\"  】════════════\" );";

            }


            return strCode1 + strCode2 + strCode3 + getProcessStr + strCode4 + strCode5 + strCode6 + strCode6_fix + strCode7 + strCode7_fix + strCode8 + strCode8_fix + strCode9;
        }


        static MethodDeclaration getMethodDeclarationFromCompilationUnit(ClassOrInterfaceDeclaration mClassOrInterfaceDeclaration, String methodIdentify) {
            MethodDeclaration returnMethod = null;
            List<MethodDeclaration> methodList = mClassOrInterfaceDeclaration.getMethods();
            int methodSize = methodList.size();
            String getDeclarationAsString = "";
            for (int i = 0; i < methodSize; i++) {
//                System.out.println("═════════第 "+ i +"个Method方法开始解析═══════════════");
                MethodDeclaration curMethodDeclaration = methodList.get(i);


//                String getName = curMethodDeclaration.getName().toString();
//                System.out.println("MethodDeclaration.getName().toString() = "+ getName);
//
//                String getNameAsString = curMethodDeclaration.getNameAsString();
//                System.out.println("MethodDeclaration.getNameAsString() = "+ getNameAsString);
//
//                String getIdentifier =  curMethodDeclaration.getName().getIdentifier();
//                System.out.println("MethodDeclaration.getName().getIdentifier() = "+ getIdentifier);
//
//                String getDeclarationAsString2=     curMethodDeclaration.getDeclarationAsString();
//                System.out.println("MethodDeclaration.getDeclarationAsString() = "+ getDeclarationAsString2);

                // String MethodDeclaration_toString =  curMethodDeclaration.toString();
                // System.out.println("MethodDeclaration_toString = "+ MethodDeclaration_toString);

                getDeclarationAsString = curMethodDeclaration.getDeclarationAsString(false, false, true);
//                System.out.println("MethodDeclaration.getDeclarationAsString(false,false,true) = "+ getDeclarationAsString);
//                System.out.println("methodIdentify = "+ methodIdentify);

                // 匹配方法   检索当前的方法与解析的方法是否相同   Zukgit1
//                System.out.println("索引:"+i+"    methodIdentify 返回 MethodDeclaration  methodIdentify= " +methodIdentify);
//                System.out.println("索引:"+i+"    methodIdentify 返回 MethodDeclaration  getDeclarationAsString= " + getDeclarationAsString );
//                System.out.println("--------------------------------------------");

                if (methodIdentify.trim().toLowerCase().equals(getDeclarationAsString.trim().toLowerCase())) {
                    NodeList<Parameter> methodParamList = curMethodDeclaration.getParameters();
//                    System.out.println("═════════参数列表Begin═══════════════");
                    for (Parameter param : methodParamList) {
//                        System.out.println("param = "+ param.toString());
                    }
//                    System.out.println("═════════参数列表End═══════════════");

                    returnMethod = curMethodDeclaration;
                    //  System.out.println("索引:"+i+"相等 将返回!  methodIdentify "+ methodIdentify + " getDeclarationAsString ="+ getDeclarationAsString);
                    return returnMethod;
                }
//                System.out.println("══════════════第 "+ i +"个Method方法解析结束══════════════");
            }


            System.out.println(" 没匹配到 methodIdentify 返回null");

            System.out.println("methodIdentify         =: " + methodIdentify + "   methodSize=" + methodSize);
            System.out.println("getDeclarationAsString =: " + getDeclarationAsString + "   methodSize=" + methodSize);
            System.out.println("══════════════");

            return returnMethod;
        }
    }


    static String COMMON_PRINT_METHOD = "    public final static <T> boolean isListType(T t) {        if (t == null) {            return false;        }        String typeInfo = t.getClass().getName();        ZukgitHoldPlace\"isListType  typeInfo =  \" + typeInfo);        String[] zListTypeArr = {\"java.util.Set\",                \"java.util.ArrayList\",                \"java.util.Collection\",                \"java.util.List\",                \"java.util.Vector\",                \"java.util.Stack\",                \"java.util.LinkedList\",                \"javafx.collections.transformation.SortedList\"        };        for (String curStr : zListTypeArr) {                        if (curStr.equals(typeInfo)) {                return true;            }        }        return false;    }    public final static <T> boolean isSetType(T t) {        if (t == null) {            return false;        }        String typeInfo = t.getClass().getName();        ZukgitHoldPlace\"isMapType  typeInfo =  \" + typeInfo);        String[] zSetTypeArr = {\"java.util.EnumSet\",                \"java.util.SortedSet\",                \"java.util.concurrent.CopyOnWriteArraySet\",                \"java.util.LinkedHashSet\",                \"java.util.HashSet\",                \"java.util.TreeSet\",                \"android.util.SparseArray\",                \"android.util.ArraySet\"        };        for (String curStr : zSetTypeArr) {            if (curStr.equals(typeInfo)) {                return true;            }        }        return false;    }    public final static <T> boolean iQueueType(T t) {        if (t == null) {            return false;        }        String typeInfo = t.getClass().getName();        ZukgitHoldPlace\"isMapType  typeInfo =  \" + typeInfo);        String[] zQueueTypeArr = {                \"java.util.concurrent.LinkedBlockingDeque\",                \"java.util.Queue\",                \"java.util.ArrayDeque\",                \"java.util.concurrent.BlockingQueue\",                \"java.util.concurrent.LinkedTransferQueue\",                \"java.util.PriorityQueue\",                \"java.util.concurrent.LinkedBlockingQueue\",        };        for (String curStr : zQueueTypeArr) {            if (curStr.equals(typeInfo)) {                return true;            }        }        return false;    }    public final static <T> boolean isShuZuType(T t) {        if (t == null) {            return false;        }        String typeInfo = t.getClass().getName();        ZukgitHoldPlace\"isMapType  typeInfo =  \" + typeInfo);        String[] zMapTypeArr = {\"[Ljava.lang.String;\",                  \"[Ljava/lang/Object;\",                  \"[I\",                 \"[B\",                  \"[C\",                 \"[S\",                 \"[J\",                 \"[F\",                \"[D\"            };        if(typeInfo.startsWith(\"[L\")){            return true;        }        for (String curStr : zMapTypeArr) {            if (curStr.equals(typeInfo)) {                return true;            }        }        return false;    }    public final static <T> boolean isMapType(T t) {        if (t == null) {            return false;        }        String typeInfo = t.getClass().getName();        ZukgitHoldPlace\"isMapType  typeInfo =  \" + typeInfo);        String[] zMapTypeArr = {\"java.util.HashMap\",                \"java.util.TreeMap\",                \"java.util.LinkedHashMap\",                \"java.util.WeakHashMap\",                \"java.util.concurrent.ConcurrentHashMap\",                \"java.util.Hashtable\",                \"android.util.ArrayMap\"};        for (String curStr : zMapTypeArr) {            if (curStr.equals(typeInfo)) {                return true;            }        }        return false;    }    public final static <T> void zPrintLog(T t) {      if( t ==null){return ;}        ZukgitHoldPlace\" 当前类型:   \" + t.getClass().getName());        if (isListType(t)) {            ZukgitHoldPlace\"List数据类型类型   \");            if (t != null) {                Object[] objectList = ((java.util.List) t).toArray();                for (int zindex = 0; zindex < objectList.length; zindex++) {                    ZukgitHoldPlace\" List   \" + \"ArrayList<Date> dateList  index =\" + zindex + \" value :\" + objectList[zindex].toString());                }            } else {                ZukgitHoldPlace\" List   \" + \"ArrayList<Date> dateList is null !\");            }        } else if (isSetType(t)) {            ZukgitHoldPlace\"Set数据类型类型   \");            if (t != null) {                Object[] objectList = ((java.util.Set) t).toArray();                for (int zindex = 0; zindex < objectList.length; zindex++) {                    ZukgitHoldPlace\" Set   \" + \"ArrayList<Date> dateList  index =\" + zindex + \" value :\" + objectList[zindex].toString());                }            } else {                ZukgitHoldPlace\" Set   \" + \"ArrayList<Date> dateList is null !\");            }        } else if (iQueueType(t)) {            if (t != null) {                Object[] objectList = ((java.util.Queue) t).toArray();                for (int zindex = 0; zindex < objectList.length; zindex++) {                    ZukgitHoldPlace\" Queue :   \" + \"ArrayList<Date> dateList  index =\" + zindex + \" value :\" + objectList[zindex].toString());                }            } else {                ZukgitHoldPlace\" Queue   \" + \"ArrayList<Date> dateList is null !\");            }        } else if (isMapType(t)) {            ZukgitHoldPlace\"Map数据类型类型  \");            if (t != null) {                java.util.Map.Entry<String, String> entry = null;                java.util.Iterator iterator = ((java.util.Map) t).entrySet().iterator();                int mZindex = 0;                while (iterator.hasNext()) {                    entry = ( java.util.Map.Entry<String, String>) iterator.next();                    ZukgitHoldPlace\" Map   \" + \" stringMap    index =\" + mZindex + \"     entry.Key= \" + entry.getKey() + \" entry.Value=\" + entry.getValue());                    mZindex++;                }            } else {                ZukgitHoldPlace\" Map   \" + \" t is null !\");            }        } else if(isShuZuType(t)){            ZukgitHoldPlace\"[] 数组类型格式  \");            if (t != null) {                String Arrtype = t.getClass().getName();                java.util.ArrayList<Object>  valueList= new  java.util.ArrayList();                int[] intArr=null;                byte[] byteArr=null;                char[] charArr=null;                short[] shortArr=null;                long[] longArr=null;                float[] floatArr=null;                double[] doubleArr= null;                boolean[] booleanArr = null;                Object[]  ObjectArr =null;                if(Arrtype.equals(\"[I\")){                       intArr = (int[])t ;                    valueList.add( java.util.Arrays.toString(intArr));                } else if(Arrtype.equals(\"[J\")){                      longArr = (long[])t ;                    valueList.add( java.util.Arrays.toString(longArr));                }else if(Arrtype.equals(\"[F\")){                    floatArr = (float[])t ;                    valueList.add( java.util.Arrays.toString(floatArr));                }else if(Arrtype.equals(\"[D\")){                    doubleArr = (double[])t ;                    valueList.add( java.util.Arrays.toString(doubleArr));                }else if(Arrtype.equals(\"[S\")){                    shortArr = (short[])t ;                    valueList.add( java.util.Arrays.toString(shortArr));                }else if(Arrtype.equals(\"[C\")){                    charArr = (char[])t ;                    valueList.add( java.util.Arrays.toString(charArr));                }else if(Arrtype.equals(\"[B\")){                    byteArr = (byte[])t ;                    valueList.add( java.util.Arrays.toString(byteArr));                }else if(Arrtype.equals(\"[Z\")){                    booleanArr = (boolean[])t ;                    valueList.add( java.util.Arrays.toString(booleanArr));                }else{                    ObjectArr = (Object[]) t ;                    for (Object curObject:ObjectArr ) {                        valueList.add(curObject);                    }                }                for (int zindex = 0; zindex < valueList.size(); zindex++) {                    ZukgitHoldPlace\" shuzu[]   \" + \"XXXX[]   zindex = \" + zindex + \"   :  value= \" + valueList.get(zindex).toString());                }            } else {                ZukgitHoldPlace\" zukgit_B8_Test_method3   \" + \"strArr is null !\");            }        }else {            ZukgitHoldPlace\"    baseObject = true   基本Object对象类型   toString()=\" + t);        }    }";




    class Encry_StringByte_To_Print_Rule_56 extends Basic_Rule {

        String  key_str = "zukgit12";
        ArrayList<String> input_str_list ;

        String encry_method = "DES/ECB/NoPadding";


        Encry_StringByte_To_Print_Rule_56() {
            super("#", 56, 4); //
            input_str_list =  new ArrayList<String>();

        }



        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {



            for (int i = 0; i < input_str_list.size(); i++) {
                String str_temp = input_str_list.get(i);
                System.out.println("");
                System.out.println("_____________["+i+"]["+str_temp+"] 加密操作开始_____________");

                byte[] temp_bytes = str_temp.getBytes();





                String raw_ten_byte_str = 	bytesToIntString(temp_bytes);
                String raw_ten_byte_char_str  =	bytesToIntCharString(temp_bytes,str_temp);
                String raw_hex_byte_str = 	bytesToHexString_Padding(temp_bytes);
                String raw_hex_byte_char_str  =   bytesToHexCharString(temp_bytes,str_temp);

                System.out.println("");
                System.out.println("加密密钥key:【"+key_str+"】");
                System.out.println("原始字符串 :【"+str_temp+"】");
                System.out.println("原始字符串十十进制字节:【["+raw_ten_byte_str+"]】");
                System.out.println("原始字符串十十进制字节:【["+raw_ten_byte_char_str+"]】");
                System.out.println("原始字符串十六进制字节:【["+raw_hex_byte_str+" ]】");
                System.out.println("原始字符串十六进制字节:【["+raw_hex_byte_char_str+"]】");



                try {
                    byte[] 	encrypt_bytes = encrypt(temp_bytes);


                    String enctrypt_str = new String(encrypt_bytes,"utf-8");

                    String jiami_raw_ten_byte_str = 	bytesToIntString(encrypt_bytes);
                    String jiami_raw_ten_byte_char_str  =	bytesToIntCharString(encrypt_bytes,enctrypt_str);
                    String jiami_raw_hex_byte_str = 	bytesToHexString_Padding(encrypt_bytes);
                    String jiami_raw_hex_byte_char_str  =   bytesToHexCharString(encrypt_bytes,enctrypt_str);

                    System.out.println("");
                    System.out.println("加密字符串 :【"+enctrypt_str+"】");
                    System.out.println("加密字符串十十进制字节:【["+jiami_raw_ten_byte_str+"]】");
                    System.out.println("加密字符串十十进制字节:【["+jiami_raw_ten_byte_char_str+"]】");
                    System.out.println("加密字符串十六进制字节:【["+jiami_raw_hex_byte_str+" ]】");
                    System.out.println("加密字符串十六进制字节:【["+jiami_raw_hex_byte_char_str+"]】");


                    byte[] decrypt_bytes = decrypt(encrypt_bytes);


                    String dectrypt_str = new String(decrypt_bytes,"utf-8");

                    String jiemi_raw_ten_byte_str = 	bytesToIntString(decrypt_bytes);
                    String jiemi_raw_ten_byte_char_str  =	bytesToIntCharString(decrypt_bytes,dectrypt_str);
                    String jiemi_raw_hex_byte_str = 	bytesToHexString_Padding(decrypt_bytes);
                    String jiemi_raw_hex_byte_char_str  =   bytesToHexCharString(decrypt_bytes,dectrypt_str);
                    System.out.println("");
                    System.out.println("解密字符串 :【"+dectrypt_str+"】");
                    System.out.println("解密字符串十十进制字节:【["+jiemi_raw_ten_byte_str+"]】");
                    System.out.println("解密字符串十十进制字节:【["+jiemi_raw_ten_byte_char_str+"]】");
                    System.out.println("解密字符串十六进制字节:【["+jiemi_raw_hex_byte_str+" ]】");
                    System.out.println("解密字符串十六进制字节:【["+jiemi_raw_hex_byte_char_str+"]】");





                } catch (Exception e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }






            }





            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            boolean Flag = true;

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem = inputParamList.get(i);
                String paramItem_lower_trim = paramItem.toLowerCase().trim();

                if (paramItem_lower_trim.startsWith("key_")) {
                    key_str = paramItem.replace("key_", "").replace("Key_", "").trim();
                    continue;
                }

                if (paramItem_lower_trim.startsWith("method_")) {
                    encry_method = paramItem.replace("method_", "").replace("METHOD_", "").replace("Method_", "").trim();
                    continue;
                }

                if(i != 0 ) {

                    input_str_list.add(paramItem);
                }

            }
            System.out.println("");
            System.out.println("key_str【"+key_str+"】"+"   encry_method【"+encry_method+"】");

            for (int i = 0; i < input_str_list.size(); i++) {
                System.out.println("解析字符串["+i+"]____"+input_str_list.get(i));
            }

            return super.initParamsWithInputList(inputParamList) && Flag;
        }

        @Override
        String simpleDesc() {

            return  "\n" + Cur_Bat_Name + " #_" + rule_index + " key_zukgit12  12345678 874321   // 对 输入的字符串   进行 加密  并打印 前后数据 对比 key_zukgit12 key_12345678 选中Key密钥 method_DES/ECB/NoPadding 选中加密方法 \n"
                    + Cur_Bat_Name + " #_" + rule_index + " key_abcdefgh 11223344  method_DES/ECB/NoPadding 7788   // 对 输入的字符串   进行 加密  并打印 前后数据 对比 key_zukgit12 key_12345678 选中Key密钥 method_DES/ECB/NoPadding 选中加密方法 \n"
                    + "  \n"
                    + Cur_Bat_Name + " #_" + rule_index + " key_87654321 11223344   // 对 输入的字符串   进行 加密  并打印 前后数据 对比 key_zukgit12 key_12345678 选中Key密钥 method_DES/ECB/NoPadding 选中加密方法 \n"
                    + "  \n"

                    ;
        }


    }

    //1.  不是以 //开头
    //2.  包含  fn
    //3.  包含 pub
    // 4. 包含 (     ,  最后一个 { 转为 【】
    //  5.添加上 序号
    // 转成 md  保存 然后 打印  ###### xxxxxx.rs

    //读取到当前 所有 目录的 .rs 文件  对于 【pub fn】___ 【pub const fn】 pub unsafe   字样的 字符串 转为 md 文件 并且不是// 开头的字符串打印出一份详情MD文件清单
    class Read_RS_File_Print_Pub_Fn_Method_To_MD_Rule_55 extends Basic_Rule {

        ArrayList<File> allRustFile ;  //
        ArrayList<File> allAvaliableRustFile ;  //
        HashMap<File,ArrayList<String>>   mRustFile_MethodMDList_Map;


        Read_RS_File_Print_Pub_Fn_Method_To_MD_Rule_55() {
            super("#", 55, 5); //

            allRustFile = new ArrayList<File>();    //   依据 搜索到 的文件 拍显示  上下才能有关系
            mRustFile_MethodMDList_Map = new HashMap<File,ArrayList<String>> ();

            allAvaliableRustFile = new ArrayList<File>();   //  有效的 rust 文件

        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // mdname_true // kaoyan_true gaokao_true



            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }






        // C:\Users\zhuzj5\.cargo\registry
        // C:\Users\zhuzj5\.rustup\toolchains\stable-x86_64-pc-windows-msvc
        @Override
        String simpleDesc() {

            return "\n" + Cur_Bat_Name + " #_" + rule_index
                    + "     //   读取到当前 所有 目录的 .rs 文件  对于 【pub fn】___ 【pub const fn】 pub unsafe   字样的 字符串 转为 md 文件 并且不是// 开头的字符串打印出一份详情MD文件清单 \n"
                    + Cur_Bat_Name + "  #_" + rule_index	+ "  ### 读取到当前 所有 目录的 .rs 文件  对于 【pub fn】___ 【pub const fn】 pub unsafe   字样的 字符串 转为 md 文件 并且不是// 开头的字符串打印出一份详情MD文件清单   \n"
                    + Cur_Bat_Name + "  #_" + rule_index	+ "  ###  cd  C:\\Users\\"+getUserName()+"\\.cargo\\registry  && "+Cur_Bat_Name + "  #_" + rule_index+"  \n"
                    + Cur_Bat_Name + "  #_" + rule_index	+ "  ###  cd  C:\\Users\\"+getUserName()+"\\.rustup\\toolchains\\stable-x86_64-pc-windows-msvc  && "+Cur_Bat_Name + "  #_" + rule_index+"  \n"
                    + ""
//			zrule_apply_G2.bat  #_53  appname_z  productappend_xxx
                    ;
        }

        @Override
        ArrayList<File> applyDir_SubFileListRule5(ArrayList<File> allSubDirFileList,
                                                  ArrayList<File> allSubRealFileList) {



            for (int i = 0; i < allSubRealFileList.size(); i++) {


                File targetItem = allSubRealFileList.get(i);

                System.out.println("realdile["+i+"]["+allSubRealFileList.size()+"]__"+targetItem.getAbsolutePath());
                if (targetItem.getName().toLowerCase().endsWith(".rs")) {
                    allRustFile.add(targetItem);


                    ArrayList<String> rawRsContentList = 	ReadFileContentAsList(targetItem);

                    if(rawRsContentList != null && rawRsContentList.size() > 0) {


                        ArrayList<String> pub_fn_list =  read_pub_fn_FromList(rawRsContentList);
                        System.out.println("targetItem="+targetItem.getAbsolutePath()+"  pub_fn_list="+pub_fn_list.size() +" rawRsContentList="+rawRsContentList.size());
                        if(pub_fn_list != null && pub_fn_list.size() > 0 ) {

                            ArrayList<String> mdRSMethodContentList = new ArrayList<String> ();

                            String codePreBlock = "```";
                            String rust_str = File.separator+"rust";

                            String register_str = "registry";
                            String github_str = "github";



                            String abs_path = targetItem.getAbsolutePath();
                            if(targetItem.getAbsolutePath().contains(rust_str)) {
                                abs_path = abs_path.substring(abs_path.indexOf(rust_str),abs_path.length());

                            } else if(abs_path.contains(register_str) && abs_path.contains(github_str)  ) {


                                String github_1_str = abs_path.substring(abs_path.indexOf(github_str)+github_str.length());

                                if(github_1_str.contains(File.separator)){

                                    abs_path = github_1_str.substring(github_1_str.indexOf(File.separator));
                                } else if(github_1_str.contains("\\")) {

                                    abs_path = github_1_str.substring(github_1_str.indexOf("\\"));
                                }



                            }
                            String  file_head = "## "+ abs_path+"\n\n"+codePreBlock;
                            String codeEndBlock = "\n```\n";

                            mdRSMethodContentList.add(file_head);
                            mdRSMethodContentList.addAll(pub_fn_list);

                            mdRSMethodContentList.add(codeEndBlock);

                            allAvaliableRustFile.add(targetItem);
                            mRustFile_MethodMDList_Map.put(targetItem, mdRSMethodContentList);


                        }

                    }

                }


            }

            if(mRustFile_MethodMDList_Map.size() == 0) {
                System.out.println("当前 目录 "+curDirPath+" 没有 含有有效 pub fn 的 .rs 文件!!   无法生成 md  文件内容  请检查! ");
                return super.applyDir_SubFileListRule5(allSubDirFileList, allSubRealFileList);
            }






            ArrayList<String>  allContentList = new ArrayList<String>();
            allContentList.add("---");
            allContentList.add("layout: post");
            allContentList.add("title: Rust方法集合");
            allContentList.add("category: 代码");
            allContentList.add("tags: Code");
            allContentList.add("keywords: Rust Code");
            allContentList.add("typora-root-url: ..\\..\\..\\");
            allContentList.add("typora-copy-images-to: ..\\..\\..\\public\\zimage");
            allContentList.add("---");
            allContentList.add("");
            allContentList.add("## 简介");
            allContentList.add(" * TOC");
            allContentList.add(" {:toc}");
            allContentList.add("");
            allContentList.add("");
            allContentList.add("");
            allContentList.add("");




            for (int i = 0; i < allAvaliableRustFile.size(); i++) {

                File rs_pub_fn_file = allAvaliableRustFile.get(i);
                System.out.println("avaliable_rs["+i+"]["+allAvaliableRustFile.size()+"] = "+ rs_pub_fn_file.getAbsolutePath());
                ArrayList<String> fnList  = mRustFile_MethodMDList_Map.get(rs_pub_fn_file);
                if(fnList != null) {
                    allContentList.addAll(fnList);
                    allContentList.add("");
                }


            }

            if(allContentList.size() > 0 ) {

                writeContentToFile(G2_Temp_Text_File, allContentList);
                NotePadOpenTargetFile(G2_Temp_Text_File.getAbsolutePath());
                System.out.println("成功执行 读取到当前 所有 目录的 .rs 文件 记录 pub fn 方法的操作!  将打开 \n "+G2_Temp_Text_File.getAbsolutePath()+"\n 显示MD内容!");
            }





            return super.applyDir_SubFileListRule5(allSubDirFileList, allSubRealFileList);

        }


        ArrayList<String> 	read_pub_fn_FromList(ArrayList<String>  mRawRustContentList){
            ArrayList<String>   pub_method_name_list = new 	ArrayList<String> ();

            ArrayList<String>   pub_macro_name_list = new 	ArrayList<String> ();

            ArrayList<String> allContent = new ArrayList<String> ();

            int method_index = 1;
            int macro_index  = 1 ;  // 宏函数 以  !结尾的函数
            for (int i = 0; i < mRawRustContentList.size(); i++) {
                String oneLine  = mRawRustContentList.get(i).trim();
                //1.  不是以 //开头
                //2.  包含  fn
                //3.  包含 pub
                // 4. 包含 (     ,  最后一个 { 转为 【】
                //  5.添加上 序号
                // 转成 md  保存 然后 打印  ###### xxxxxx.rs

                if(oneLine.startsWith("//")) {
                    continue;
                }
                if(oneLine.contains("pub") && oneLine.contains(" fn ")  && oneLine.contains("(") ) {

                    oneLine = oneLine.replace("{", "【】");
                    pub_method_name_list.add(method_index+"  "+oneLine);
                    method_index++;
                    continue;

                }


                if(oneLine.startsWith("macro_rules!") && oneLine.contains("{")   ) {

                    oneLine = oneLine.replace("{", "【】");
                    pub_macro_name_list.add(macro_index+"  "+oneLine);
                    macro_index++;
                    continue;
                }


            }

            if(pub_method_name_list.size() > 0 ) {
                allContent.add("═════════ pub fn 函数");
                allContent.addAll(pub_method_name_list);
                allContent.add("");
                allContent.add("");
            }

            if(pub_macro_name_list.size() > 0 ) {
                allContent.add("═════════ macro_rules! 宏函数 ");
                allContent.addAll(pub_macro_name_list);
                allContent.add("");
                allContent.add("");
            }



            return allContent;

        }

    }


    class Send_Email_TO_Dst_Rule_54 extends Basic_Rule {

        ArrayList<String> message_tip_list;

        // 0 只发送文字内容--本机信息等
        // 1--搭配 query_dir 发送本地对应目录的所有文件的字符串
        // 2--发送屏幕截图
        // 3--发送指定文件到附件 // 可以一起实现啊 0123 , 111 那么就只执行一个1 type_0123
        String sendType = "0";
        String quChong_Type = "0";

        ArrayList<File> queryDirList; // 用户输入的多个需要查询所有文件的文件夹的目录
        ArrayList<File> attatchFileList; // 可能包含 文件夹 以及 文件的路径 upfile_
        ArrayList<WifiItem> wifiItemList = new ArrayList<WifiItem>(); // Wifi 相关的信息

        String dstemail = "";
        String content_text = ""; // 邮件的内容

        String subject_text = ""; // 主题

        // 是否重复 一直发
        boolean isLoop = false;

        int repeatcount = 1; // 默认的发送次数

        int interval = 1; // 默认发送的间隔 秒为单位 默认1 秒

        String mCurrentUserName = "null";

        Send_Email_TO_Dst_Rule_54() {
            super("#", 54, 4); //
            attatchFileList = new ArrayList<File>();
            queryDirList = new ArrayList<File>();
            message_tip_list = new ArrayList<String>();
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // mdname_true // kaoyan_true gaokao_true

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem_lower_trim = inputParamList.get(i);
//				String paramItem_lower_trim = paramItem.toLowerCase().trim();

                if (paramItem_lower_trim.startsWith("dst_")) {
                    dstemail = paramItem_lower_trim.replace("dst_", "");
                }

                if (paramItem_lower_trim.startsWith("type_")) { // type_012341
                    String mSendtype = paramItem_lower_trim.replace("type_", ""); // 0 只发送文字内容 1--发送屏幕截图

                    sendType = mSendtype;

//					if(isNumeric(mSendtype)) {  // .contain("0") .contain("1")   .contain("2")    .contain("3")  来判断是否有
//						sendType = mSendtype;
//					}else {
//						System.out.println("当前发送的 type_ 后缀 不是数字: 请检查! " + paramItem_lower_trim);
//					}

                }

                if (paramItem_lower_trim.startsWith("content_")) {
                    content_text = paramItem_lower_trim.replace("content_", ""); // 0 只发送文字内容 1--发送屏幕截图
                }

                if (paramItem_lower_trim.startsWith("subject_")) {
                    subject_text = paramItem_lower_trim.replace("subject_", ""); // 0 只发送文字内容 1--发送屏幕截图
                }

                if (paramItem_lower_trim.startsWith("loop_true")) {
                    isLoop = true; // 0 只发送文字内容 1--发送屏幕截图
                }

                if (paramItem_lower_trim.startsWith("repeatcount_")) {
                    String count_str = paramItem_lower_trim.replace("repeatcount_", "");
                    if (isNumeric(count_str)) {
                        repeatcount = Integer.parseInt(count_str);
                    }

                }

                if (paramItem_lower_trim.startsWith("interval_")) {
                    String interval_str = paramItem_lower_trim.replace("interval_", "");
                    if (isNumeric(interval_str)) {
                        interval = Integer.parseInt(interval_str);
                    }

                }

                if (paramItem_lower_trim.startsWith("query_")) {
                    String query_dir_path = paramItem_lower_trim.replace("query_", "");
                    File queryFile = new File(query_dir_path);
                    if (queryFile.exists() && queryFile.isDirectory()) {
                        queryDirList.add(queryFile);
                    } else {
                        System.out.println("paramItem_lower_trim 对应的 queryFile 不存在 ! -->" + paramItem_lower_trim);

                        if (!queryFile.exists()) {
                            System.out.println("paramItem_lower_trim 对应的 queryFile 不存在 ! -->" + paramItem_lower_trim);
                            message_tip_list.add("参数[" + paramItem_lower_trim + "]" + "对应的 queryFile 不存在 ! -->"
                                    + paramItem_lower_trim);
                        } else if (queryFile.isFile()) {
                            System.out.println("paramItem_lower_trim 对应的 upload_file  是文件夹 ! -->" + paramItem_lower_trim
                                    + " 无法上传 请检查");
                            message_tip_list.add("参数[" + paramItem_lower_trim + "]" + "对应的 是文件  无法查询所有子文件 ! -->"
                                    + paramItem_lower_trim);

                        }

                    }
                }

                if (paramItem_lower_trim.startsWith("upfile_")) {
                    String up_file_path = paramItem_lower_trim.replace("upfile_", "");
                    File upFile = new File(up_file_path);
                    if (upFile.exists() && upFile.isFile()) {
                        attatchFileList.add(upFile);
                    } else {
                        if (!upFile.exists()) {
                            System.out.println("paramItem_lower_trim 对应的 upload_file 不存在 ! -->" + paramItem_lower_trim);
                            message_tip_list.add("参数[" + paramItem_lower_trim + "]" + "对应的 upload_file 不存在 ! -->"
                                    + paramItem_lower_trim);
                        } else if (upFile.isDirectory()) {
                            System.out.println("paramItem_lower_trim 对应的 upload_file  是文件夹 ! -->" + paramItem_lower_trim
                                    + " 无法上传 请检查");
                            message_tip_list.add("参数[" + paramItem_lower_trim + "]" + "对应的 是文件夹  无法添加到附件 ! -->"
                                    + paramItem_lower_trim);

                        }

                    }

                }

            }
            System.out.println("═══════════════════输入参数展示 Begin ══════════════════");

            quChong_Type = calcul_QuChong_Type(sendType);
            if (quChong_Type == null || "".equals(quChong_Type)) {
                quChong_Type = "0"; // 默认 执行0 的操作
            }

            ArrayList<String> infoList = getParamsInfoList();
            for (int i = 0; i < infoList.size(); i++) {
                System.out.println(infoList.get(i));
            }

            System.out.println("═══════════════════输入参数展示 End ══════════════════");

            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }

        // 0 只发送文字内容--本机信息等
        // 1--搭配 query_dir 发送本地对应目录的所有文件的字符串
        // 2--发送屏幕截图
        // 3--发送指定文件到附件 // 可以一起实现啊 0123 , 111 那么就只执行一个1 type_0123
        @Override
        String simpleDesc() {

            return "\n" + Cur_Bat_Name + " #_" + rule_index
                    + "  dst_zukgit@foxmail.com  type_0  subject_Cmder测试  content_HelloWorld         //  给dst目的邮箱发送邮件 type=0 【0=打印简单信息 1=查询目录(query_)  2=发送截屏 3=发送附件(upload_)】   \n"
                    + Cur_Bat_Name + "  #_" + rule_index
                    + " type_1  query_D/1A/221013    query_D/1A/221012     ###  把对应文件夹下的文件列表发送邮件  dst目的邮箱默认 foxmail  \n"
                    + Cur_Bat_Name + "  #_" + rule_index + " type_2      ###   截取当前电脑屏幕发送到邮箱   \n" + Cur_Bat_Name
                    + "  #_" + rule_index
                    + " type_3  upfile_D/1A/221013/G2.bat  upfile_D/1A/123.txt     ###  把对应多个文件当作有邮箱附件发送  type=3   \n"
                    + Cur_Bat_Name + "  #_" + rule_index + " type_2   loop_true   ###   不断循环发送当前电脑屏幕截屏发送到邮箱   \n"
                    + Cur_Bat_Name + "  #_" + rule_index
                    + " type_2   repeatcount_10 interval_30  ###   发送10个电脑屏幕截屏间隔为30秒发送到邮箱   \n" + Cur_Bat_Name + " #_"
                    + rule_index
                    + "  dst_zukgit@foxmail.com  type_0123  subject_Cmder测试  content_HelloWorld         //   操作 0 1 2 3 一起执行   \n"

                    + "";
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            char[] send_type_arr = quChong_Type.toCharArray();

            ArrayList<String> extraInfoList = new ArrayList<String>();
            HashMap<File, String> imageFile_Desc_Map = new HashMap<File, String>();
            ArrayList<File> mParamAttatchFileList = new ArrayList<File>();
            ArrayList<String> queryDirInfoList = new ArrayList<String>(); // 查询 列表的数据

            if (isLoop) {
                repeatcount = 1000000; // 重复 10000万次 已达到 无限 循环的目的
            }

            for (int i = 0; i < repeatcount; i++) {

                extraInfoList.clear();
                imageFile_Desc_Map.clear();
                mParamAttatchFileList.clear(); // 要 上传 的 文件 本来 就不会重复

                // 0 只发送文字内容--本机信息等 时间戳 等简单的数据
                // 1--搭配 query_dir 发送本地对应目录的所有文件的字符串
                // 2--发送屏幕截图
                // 3--发送指定文件到附件 // 可以一起实现啊 0123 , 111 那么就只执行一个1 type_0123
                for (int j = 0; j < send_type_arr.length; j++) {
                    String oneCharType = send_type_arr[j] + "";

                    switch (oneCharType) {
                        case "0":
                            ArrayList<String> simple_info_List = getSimpleInfoList();
                            if (simple_info_List != null) {
                                extraInfoList.addAll(simple_info_List);
                            }

                            break;

                        case "1":

                            if (queryDirInfoList.size() == 0) {

                                queryDirInfoList
                                        .add("═════════" + "QueryDir[" + queryDirList.size() + "]" + " Begin ═════════");

                                for (int k = 0; k < queryDirList.size(); k++) {
                                    File queryDir = queryDirList.get(k);
                                    queryDirInfoList.add(
                                            "═════════" + "QueryDir[" + k + "][" + queryDirList.size() + "]" + "═════════");
                                    if (queryDir.exists() && queryDir.isDirectory()) {
                                        ArrayList<File> allSubFile = getAllSubFile(queryDir, "*");
                                        addQueryFileInfo(queryDir, queryDirInfoList, allSubFile, k, queryDirList.size());
                                        System.out.println("AA_ queryDir=" + queryDir + "  queryDir.exists()="
                                                + queryDir.exists() + "    queryDir.isDirectory()=" + queryDir.isDirectory()
                                                + "  allSubFile.size()=" + allSubFile.size());

                                    } else {

                                        System.out.println(
                                                "BB_ queryDir=" + queryDir + "  queryDir.exists()=" + queryDir.exists()
                                                        + "    queryDir.isDirectory()=" + queryDir.isDirectory());
                                    }

                                }
                                queryDirInfoList
                                        .add("═════════" + "QueryDir[" + queryDirList.size() + "]" + " End ═════════");
                            }

                            if (queryDirInfoList.size() != 0) {

                                System.out.println("queryDirInfoList.size() = " + queryDirInfoList.size());

                                for (int k = 0; k < queryDirInfoList.size(); k++) {
                                    System.out.println("query_file = " + queryDirInfoList.get(k));

                                }
                                extraInfoList.addAll(queryDirInfoList);

                            }

                            break;

                        case "2":

                            File screenShotFile = getPCScreenFile();
                            if (screenShotFile.exists()) {
                                imageFile_Desc_Map.put(screenShotFile,
                                        getTimeStampyyyyMMdd_HHmmss() + "_" + mCurrentUserName + "屏幕截图");
                            } else {
                                System.out.println("当前屏幕截图失败 screenShotFile=" + screenShotFile);
                            }

                            break;

                        case "3":
                            mParamAttatchFileList.addAll(attatchFileList);

                            break;

                        default:
                            System.out.println("oneCharType = " + oneCharType + "  没有执行规则!");
                    }

                }

                try {
                    System.out
                            .println("═════════════[" + i + "][" + repeatcount + "] 次发送邮件  interval=" + interval + "秒");

                    String mSubjectStr = subject_text;
                    if (mSubjectStr == null || "".equals(mSubjectStr)) {
                        mSubjectStr = mCurrentUserName + "_repeat[" + i + "][" + repeatcount + "]";
                    } else {
                        mSubjectStr = subject_text + "_" + mCurrentUserName + "_repeat[" + i + "][" + repeatcount + "]";
                    }
                    sendemail(false ,mCurrentUserName, dstemail, mSubjectStr, content_text, getParamsInfoList(),
                            extraInfoList, imageFile_Desc_Map, mParamAttatchFileList);
                    Thread.sleep(interval * 1000);
                } catch (Exception e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                    System.out.println("e = "+e.getMessage());
                }

            }
            System.out.println(" 次发送邮件 程序 执行 结束 ! ");

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        void addQueryFileInfo(File queryFile, ArrayList<String> fileInfoList, ArrayList<File> allSubFile, int index,
                              int count) {
            if (allSubFile == null || allSubFile.size() == 0) {

                return;
            }

            fileInfoList.add("═════════QueryDir[" + index + "][" + count + "]_" + queryFile.getAbsolutePath());

            for (int i = 0; i < allSubFile.size(); i++) {
                File fileItem = allSubFile.get(i);
                fileInfoList.add("file[" + i + "][" + allSubFile.size() + "]__" + fileItem.getAbsolutePath());
            }
            fileInfoList.add("");
        }

        ArrayList<String> getSimpleInfoList() {
            ArrayList<String> mSimpleInfoList = new ArrayList<String>();

            ArrayList<String> wifiInfoList = getWifiInfoList();
            if (wifiInfoList != null && wifiInfoList.size() > 0) {
                mSimpleInfoList.add("________" + "Wifi_Info" + "________");
                mSimpleInfoList.addAll(wifiInfoList);
                mSimpleInfoList.add("");
                mSimpleInfoList.add("");
            }

            String osName = System.getProperties().getProperty("os.name").toLowerCase();

            Runtime r = Runtime.getRuntime();
            Properties props = System.getProperties();

            Map<String, String> map = System.getenv(); // System.getenv().get("USERNAME")

            String userName = map.get("USERNAME");// 获取用户名
            mCurrentUserName = userName;
            String computerName = map.get("COMPUTERNAME");// 获取计算机名
            String userDomain = map.get("USERDOMAIN");// 获取计算机域名

            ArrayList<String> SystemInfoList = new ArrayList<String>();

            SystemInfoList.add("操作系统OS:" + osName);
            SystemInfoList.add("用户名:" + "【System.getenv().get(\"USERNAME\")" + "】" + userName);
            SystemInfoList.add("计算机名:【System.getenv().get(\"COMPUTERNAME\")】" + computerName);
            SystemInfoList.add("计算机域名:【System.getenv().get(\"USERDOMAIN\")\"】" + userDomain);
            SystemInfoList.add("JVM可以使用的总内存:" + "【Runtime.getRuntime().totalMemory()】 " + r.totalMemory()); // 【Runtime.getRuntime().totalMemory()】
            SystemInfoList.add("JVM可以使用的剩余内存:" + "【Runtime.getRuntime().freeMemory()】 " + r.freeMemory());
            SystemInfoList
                    .add("JVM可以使用的处理器个数:" + "【Runtime.getRuntime().availableProcessors()】 " + r.availableProcessors());
            SystemInfoList.add("Java的运行环境版本:" + "【java.version】" + props.getProperty("java.version"));
            SystemInfoList.add("Java的运行环境供应商:" + "【java.vendor】" + props.getProperty("java.vendor"));
            SystemInfoList.add("Java供应商的URL:" + "【java.vendor.url】" + props.getProperty("java.vendor.url"));
            SystemInfoList.add("Java的安装路径:" + "【java.home】" + props.getProperty("java.home"));
            SystemInfoList.add("Java的虚拟机规范版本:" + "【java.vm.specification.version】"
                    + props.getProperty("java.vm.specification.version"));
            SystemInfoList.add("Java的虚拟机规范供应商:" + "【java.vm.specification.vendor】"
                    + props.getProperty("java.vm.specification.vendor"));
            SystemInfoList.add(
                    "Java的虚拟机规范名称:" + "【java.vm.specification.name】" + props.getProperty("java.vm.specification.name"));
            SystemInfoList.add("Java的虚拟机实现版本:" + "【java.vm.version】" + props.getProperty("java.vm.version"));
            SystemInfoList.add("Java的虚拟机实现供应商:" + "【java.vm.vendor】" + props.getProperty("java.vm.vendor"));
            SystemInfoList.add("Java的虚拟机实现名称:" + "【java.vm.name】" + props.getProperty("java.vm.name"));
            SystemInfoList.add("Java运行时环境规范版本:" + "【java.specification.version】"
                    + props.getProperty("java.specification.version"));
            SystemInfoList.add(
                    "Java运行时环境规范供应商:" + "【java.specification.vender】" + props.getProperty("java.specification.vender"));
            SystemInfoList
                    .add("Java运行时环境规范名称:" + "【java.specification.name】" + props.getProperty("java.specification.name"));
            SystemInfoList.add("Java的类格式版本号:" + "【java.class.version】" + props.getProperty("java.class.version"));
            SystemInfoList.add("Java的类路径:" + "【java.class.path】" + props.getProperty("java.class.path"));
            SystemInfoList.add("加载库时搜索的路径列表:" + "【java.library.path】" + props.getProperty("java.library.path"));
            SystemInfoList.add("默认的临时文件路径:" + "【java.io.tmpdir】" + props.getProperty("java.io.tmpdir"));
            SystemInfoList.add("一个或多个扩展目录的路径:" + "【java.ext.dirs】" + props.getProperty("java.ext.dirs"));
            SystemInfoList.add("操作系统的名称:" + "【os.name】" + props.getProperty("os.name"));
            SystemInfoList.add("操作系统的构架:" + "【os.arch】" + props.getProperty("os.arch"));
            SystemInfoList.add("操作系统的版本:" + "【os.version】" + props.getProperty("os.version"));
            SystemInfoList.add("当前系统文件分隔符:" + "【file.separator】" + props.getProperty("file.separator"));
            SystemInfoList.add("当前系统路径分隔符:" + "【path.separator】" + props.getProperty("path.separator"));
            SystemInfoList.add("行分隔符:" + "【line.separator】" + props.getProperty("line.separator"));
            SystemInfoList.add("用户的账户名称:" + "【user.name】" + props.getProperty("user.name"));
            SystemInfoList.add("用户的主目录:" + "【user.home】" + props.getProperty("user.home"));
            SystemInfoList.add("用户的Desktop目录:" + "【user.desktop】" + props.getProperty("user.desktop"));
            SystemInfoList.add("用户的当前工作目录:" + "【user.dir】" + props.getProperty("user.dir"));

            mSimpleInfoList.add("________" + "System_Prop_Info" + "________");
            for (int i = 0; i < SystemInfoList.size(); i++) {
                mSimpleInfoList.add("system[" + i + "][" + SystemInfoList.size() + "]__" + SystemInfoList.get(i));
            }

            mSimpleInfoList.add("");
            mSimpleInfoList.add("________" + "Java_Prop_Info" + "________");

            Properties system_props = System.getProperties();
            Object[] keyObjs = System.getProperties().stringPropertyNames().toArray();

            for (int i = 0; i < keyObjs.length; i++) {
                String key = keyObjs[i] + "";
                String value = system_props.getProperty(key);
                mSimpleInfoList
                        .add("Java_Property[" + i + "][" + keyObjs.length + "]" + "【 " + key + "____" + value + "】");
            }

            mSimpleInfoList.add("________" + "Screen_Info" + "________");
            int width = getZScreenWeight();
            int high = getZScreenHeight();
            mSimpleInfoList.add("屏幕分辨率:" + width + "x" + high);
            mSimpleInfoList.add("屏幕宽:" + width);
            mSimpleInfoList.add("屏幕高:" + high);

            return mSimpleInfoList;

        }

        String readStringFromFile_UTF8(File fileItem) {
            StringBuilder sb = new StringBuilder();
            try {
                BufferedReader curBR = new BufferedReader(
                        new InputStreamReader(new FileInputStream(fileItem), "utf-8"));
//		            BufferedReader curBR = new BufferedReader(new InputStreamReader(new FileInputStream(fileItem)));
                String lineContent = "";
                while (lineContent != null) {
                    lineContent = curBR.readLine();
                    if (lineContent == null || lineContent.trim().isEmpty()) {
                        continue;
                    }
                    sb.append(lineContent + "\n");
                }
                curBR.close();
            } catch (Exception e) {
            }
            return sb.toString();
        }

        int getZScreenHeight() {
            // CMD 和 IDE下 宽高一致 1920x1080
            GraphicsDevice gd = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();
            int height = gd.getDisplayMode().getHeight();
            return height;

        }

        int getZScreenWeight() {

            // CMD 和 IDE下 宽高一致 1920x1080

            GraphicsDevice gd = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();
            int width = gd.getDisplayMode().getWidth();
            return width;

        }

        ArrayList<String> getParamsInfoList() {

            ArrayList<String> infoList = new ArrayList<String>();
//			infoList.add("dst["+dstemail+"]" +"  "+"sendType["+sendType+"]"+"  quChong_Type["+quChong_Type+"] "+"isLoop["+isLoop+"]" +"  interval["+interval+"]  "+"repeatcount["+repeatcount+"]" +"  "+"subject["+subject_text+"]"+" "+"content_text["+content_text+"]");
            infoList.add("dst[" + dstemail + "]");
            infoList.add("sendType[" + sendType + "]");
            infoList.add("quChong_Type[" + quChong_Type + "]");
            infoList.add("isLoop[" + isLoop + "]");
            infoList.add("interval[" + interval + "]");
            infoList.add("repeatcount[" + repeatcount + "]");
            infoList.add("subject[" + subject_text + "]");
            infoList.add("content_text[" + content_text + "]");

            for (int i = 0; i < queryDirList.size(); i++) {
                File queryFile = queryDirList.get(i);
                infoList.add(
                        "_____query_file[" + i + "][" + queryDirList.size() + "]" + "__" + queryFile.getAbsolutePath());
            }

            for (int i = 0; i < attatchFileList.size(); i++) {
                File attatchFile = attatchFileList.get(i);
                infoList.add(
                        "_____upfile[" + i + "][" + attatchFileList.size() + "]__" + attatchFile.getAbsolutePath());
            }

            for (int i = 0; i < message_tip_list.size(); i++) {
                String tip_item = message_tip_list.get(i);
                infoList.add("_____tip[" + i + "][" + message_tip_list.size() + "]__" + tip_item);
            }

            return infoList;

        }

        // 11111 转为1 01231 转为 0123 321 转为 123 2314转为 1234
        // 0 只发送文字内容--本机信息等
        // 1--搭配 query_dir 发送本地对应目录的所有文件的字符串
        // 2--发送屏幕截图
        // 3--发送指定文件到附件 // 可以一起实现啊 0123 , 111 那么就只执行一个1 type_0123
        String calcul_QuChong_Type(String inputType) { // 去重 去重复
            String quchong_type_str = "";
            StringBuilder inputType_SB = new StringBuilder();

            if (inputType == null || "".equals(inputType.trim())) {
                return "0";
            }

            if (inputType.contains("0")) {
                inputType_SB.append("0");
            }

            if (inputType.contains("1")) {
                inputType_SB.append("1");
            }

            if (inputType.contains("2")) {
                inputType_SB.append("2");
            }

            if (inputType.contains("3")) {
                inputType_SB.append("3");
            }

            if (inputType.contains("4")) {
                inputType_SB.append("4");
            }

            if (inputType.contains("5")) {
                inputType_SB.append("5");
            }

            if (inputType.contains("6")) {
                inputType_SB.append("6");
            }

            if (inputType.contains("7")) {
                inputType_SB.append("7");
            }

            if (inputType.contains("8")) {
                inputType_SB.append("8");
            }

            if (inputType.contains("9")) {
                inputType_SB.append("9");
            }
            if (inputType.contains("a")) { // 往后继续了
                inputType_SB.append("a");
            }

            return inputType_SB.toString();

        }

    }

    /*
     * 1.AndroidManifest.xml 改变 package 包的名称 <manifest
     * xmlns:android="http://schemas.android.com/apk/res/android"
     * xmlns:tools="http://schemas.android.com/tools"
     * package="com.and.zvideo_and_dy_clone1"> 【】
     *
     * 2. 所有的 import com.and.zvideo_and_dy.*; 都改为 import
     * com.and.改为zvideo_and_dy_clone1.*;
     *
     * 然后再把 对应的 package="com.and.zvideo_and_dy_clone1 的文件夹名称从zvideo_and_dy
     * 改为zvideo_and_dy_clone1
     *
     *
     *
     * 3.build.gradle
     *
     * defaultConfig { applicationId "com.and.zvideo_and_dy_clone1"【】 minSdkVersion
     * 21 targetSdkVersion 30 versionCode 1 versionName "1.0"
     *
     * testInstrumentationRunner "androidx.test.runner.AndroidJUnitRunner" }
     *
     * 4.settings.gradle rootProject.name = "zvideo_and_dy_clone1"
     *
     *
     * 5.所有的 Java 文件中的 【2.已实现】
     *
     * import com.and.zvideo_and_dy.R; 替换为 import com.and.zvideo_and_dy_clone1.R;
     *
     * 6. app 名称需要变更为_1 AndroidManifest.xml <application android:allowBackup="true"
     * android:icon="@mipmap/launch_icon" android:label="@string/app_name"
     * android:roundIcon="@mipmap/launch_icon" android:theme="@style/AppTheme"
     * android:largeHeap="true" android:requestLegacyExternalStorage="true"
     * android:supportsRtl="true">
     *
     * strings.xml <string name="app_name">VLC</string> 改为 <string
     * name="app_name">VLC_1</string>
     */
    class Copy_APK_Product_ChangeProductName_Rule_53 extends Basic_Rule {
        File src_apk_Dir; // APK源目录 D:\apk_dir/A_product
        File dst_apk_Dir; // APK目的目录 // D:\apk_dir/A_product_20220815_154034_clone

        File src_AndroidManifest_xml_File;
        File src_build_gradle_File;
        File src_settings_gradle_File;
        File src_strings_xml_File;
        ArrayList<File> src_fixed_FileList; // 需要重新写入数据的文件列表
        HashMap<File, ArrayList<String>> srcFile_fixedContent_Map; // 原文件作为key 修复后的内容作为value的 Map

        File dst_AndroidManifest_xml_File;
        File dst_build_gradle_File;
        File dst_settings_gradle_File;
        File dst_strings_xml_File;

        String old_product_name; // 就得工程名称 com.and.app1
        String new_productappend_name; // 新的追加的工程名称 appendname

        String old_product_endfixname; // 原来的工程名称的最后小数点后的字符串 app1
        File old_product_endfixname_DirFile; // 对应的工程目录
        String new_product_endfixname; // 原来的工程名称的最后小数点后的字符串 app1_4qrqr

//		后缀名称   app1  改为 app1_4qrqr

        String new_product_name; // 新的工程名称 com.and.app1_appendname

        String old_app_show_name; // 旧的 app显示的名字 <string name="app_name">VLC</string>
        String new_app_show_name; // 新的 app 显示的名字
        ArrayList<File> src_all_Java_FileList; // 所有的 原目录 java 文件
        ArrayList<File> dst_all_Java_FileList; // 所有的 目的目录 java 文件

        // 有些 xml 中 有自定义view 制订了
        ArrayList<File> src_all_Layout_XmlFileList; // 所有的 原目录 java 文件
        ArrayList<File> dst_all_Layout_XmlFileList; // 所有的 目的目录 java 文件

        // 需要 进行 复制操作的文件 所有 文件夹 所有文件
        ArrayList<File> src_needCopyFileList = new ArrayList<File>();
        String HHmmss_timestr; // 时分秒时间戳
        String YYMMdd_timestr; // 年月日 时间戳

        // 经过 修改 后的 Androidmanifest.xml 的 所有内容
        ArrayList<String> dst_AndroidManifest_xml_File_StrList;
        // 经过 修改 后的 strings.xml 的 所有内容
        ArrayList<String> dst_strings_xml_File_StrList;

        // 经过 修改 后的 build.gradle 的 所有内容
        ArrayList<String> dst_build_gradle_File_StrList;

        // 经过 修改 后的 settings.gradle 的 所有内容
        ArrayList<String> dst_settings_gradle_File_StrList;

        // appname_xxxxxx // apk显示的名称 默认为 a
        // productappend_xxxx // 工程名称后缀增加 什么 已达到简单克隆目的

        Copy_APK_Product_ChangeProductName_Rule_53() {
            super("#", 53, 5); //

            src_needCopyFileList = new ArrayList<File>();

            dst_AndroidManifest_xml_File_StrList = new ArrayList<String>();
            dst_strings_xml_File_StrList = new ArrayList<String>();
            dst_build_gradle_File_StrList = new ArrayList<String>();
            dst_settings_gradle_File_StrList = new ArrayList<String>();

            src_all_Java_FileList = new ArrayList<File>();
            dst_all_Java_FileList = new ArrayList<File>();

            src_all_Layout_XmlFileList = new ArrayList<File>();
            dst_all_Layout_XmlFileList = new ArrayList<File>();

            src_fixed_FileList = new ArrayList<File>();
            srcFile_fixedContent_Map = new HashMap<File, ArrayList<String>>();
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // mdname_true // kaoyan_true gaokao_true

            // 判断当前的输入的路径 是否是一个apk工程的根目录
            // 1. 包含 AndroidManifest.xml 包含 gradle文件

            if (!isShellInAndroidAPKDir()) {
                System.out.println("不是APK目录  src_settings_gradle_File=" + src_settings_gradle_File
                        + "  src_build_gradle_File=" + src_build_gradle_File + "  src_AndroidManifest_xml_File="
                        + src_AndroidManifest_xml_File + "  src_strings_xml_File=" + src_strings_xml_File);

                return false;
            }

            System.out.println("APK目录 src_settings_gradle_File=" + src_settings_gradle_File + "  src_build_gradle_File="
                    + src_build_gradle_File + "  src_AndroidManifest_xml_File=" + src_AndroidManifest_xml_File
                    + "  src_strings_xml_File=" + src_strings_xml_File);

            // appname_xxxxxx // apk显示的名称 默认为 z
            // productappend_xxxx // 工程名称后缀增加 什么 已达到简单克隆目的 默认为原有dir+时间戳 dy-->dy_081512
            new_app_show_name = "z";
            HHmmss_timestr = getTimeStamp_HHmmss();
            YYMMdd_timestr = getTimeStamp_YYYYMMdd();
            new_productappend_name = HHmmss_timestr;

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem_lower_trim = inputParamList.get(i);
//				String paramItem_lower_trim = paramItem.toLowerCase().trim();

                if (paramItem_lower_trim.startsWith("appname_")) {

                    String input_appname_str = (" " + paramItem_lower_trim).replace(" appname_", "");
                    input_appname_str = input_appname_str.replace(" ", "");

                    new_app_show_name = input_appname_str;

                }

                if (paramItem_lower_trim.startsWith("productappend_")) {

                    String input_productname_str = (" " + paramItem_lower_trim).replace(" productappend_", "");
                    input_productname_str = input_productname_str.replace(" ", "");

                    new_productappend_name = input_productname_str;

                }

            }
            System.out.println(
                    "new_app_show_name =" + new_app_show_name + "   new_productappend_name=" + new_productappend_name);

            src_apk_Dir = new File(curDirPath);

            if (!src_apk_Dir.exists()) {
                System.out.println("当前Shell 目录 不存在 请检查  src_apk_Dir=" + src_apk_Dir);
                return false;
            }

            String src_dir_name = src_apk_Dir.getName();
            String dst_dir_name = src_dir_name + "_" + new_productappend_name;
            String dst_dir_path = src_apk_Dir.getAbsolutePath().replace(src_dir_name, dst_dir_name);

            dst_apk_Dir = new File(dst_dir_path);

//					dst_apk_Dir = new File(src_apk_Dir.getAbsolutePath()+File.separator+HHmmss_timestr);

            // 读取旧的工程名称 以及 旧的 app的显示的名称
            // String old_product_name; // 就得工程名称 com.and.app1
            // String old_app_show_name; // 旧的 app显示的名字 <string name="app_name">VLC</string>

            old_product_name = readAndroidManifext_ProductName(src_AndroidManifest_xml_File, new_productappend_name);

            if (old_product_name == null) {
                System.out.println(
                        "当前工程文件 src_AndroidManifest_xml_File=" + src_AndroidManifest_xml_File + " 无法读取到工程名称!!  请检查!! ");
                return false;
            }
            if (old_product_name.contains(".")) {
                old_product_endfixname = old_product_name.substring(old_product_name.lastIndexOf(".") + 1);
                new_product_endfixname = old_product_endfixname + "_" + new_productappend_name;
            } else {

                old_product_endfixname = old_product_name;
                new_product_endfixname = old_product_endfixname + "_" + new_productappend_name;
            }

            new_product_name = old_product_name + "_" + new_productappend_name;

            System.out.println(" 当前输入 old_product_name[ " + old_product_name + "]   new_product_name[ "
                    + new_product_name + "]" + "old_product_endfixname[" + old_product_endfixname + "]  "
                    + " new_product_endfixname=" + new_product_endfixname);

            if (src_strings_xml_File.exists()) {
                old_app_show_name = readStringsXml_AppName(src_strings_xml_File, new_app_show_name);

            }
            System.out.println(" 当前输入 old_app_show_name[ " + old_app_show_name + "]   new_app_show_name[ "
                    + new_app_show_name + "]" + "  ");

            // settings.gradle 和 build.gradle 的 applicationId "com.and.zvideo_and_dy" 改为 新的

            initSettings_Gradle(src_settings_gradle_File, old_product_name, new_product_name);
            initBuild_Gradle(src_build_gradle_File, old_product_name, new_product_name);

            System.out.println(" 当前输入 SRC[ " + src_apk_Dir.getAbsolutePath() + "]  Dst[ "
                    + dst_apk_Dir.getAbsolutePath() + "]" + " ] 存在  将执行 克隆 apk代码逻辑");

            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }

        void initSettings_Gradle(File settingsGradleFile, String oldPackageName, String newPackageName) {

            ArrayList<String> settingsStrList = ReadFileContentAsList(settingsGradleFile);

            if (settingsStrList == null) {
                System.out.println("从 settingsGradleFile=" + settingsGradleFile + "读取到的数据为空! ");
                return;
            }
            System.out.println("settingsGradleFile = " + settingsGradleFile + "   oldPackageName=" + oldPackageName
                    + "   newPackageName=" + newPackageName);
            for (int i = 0; i < settingsStrList.size(); i++) {
                String lineStr = settingsStrList.get(i);
                // rootProject.name =
                if (lineStr.contains("rootProject.name")) {
                    dst_settings_gradle_File_StrList.add("rootProject.name = \"" + new_product_endfixname + "\"");
                    continue;
                }

                String lineStr_Replace_Str = lineStr.replace(oldPackageName, newPackageName);
                dst_settings_gradle_File_StrList.add(lineStr_Replace_Str);
            }

            src_fixed_FileList.add(settingsGradleFile);
            srcFile_fixedContent_Map.put(settingsGradleFile, dst_settings_gradle_File_StrList);

            System.out.println("dst_settings_gradle_File_StrList.size() = " + dst_settings_gradle_File_StrList.size());

        }

        void initBuild_Gradle(File BuildGradleFile, String oldPackageName, String newPackageName) {

            ArrayList<String> BuildStrList = ReadFileContentAsList(BuildGradleFile);

            if (BuildStrList == null) {
                System.out.println("从 BuildGradleFile=" + BuildGradleFile + "读取到的数据为空! ");
                return;
            }

            for (int i = 0; i < BuildStrList.size(); i++) {
                String lineStr = BuildStrList.get(i);
                String lineStr_Replace_Str = lineStr.replace(oldPackageName, newPackageName);
                dst_build_gradle_File_StrList.add(lineStr_Replace_Str);
            }

            src_fixed_FileList.add(BuildGradleFile);
            srcFile_fixedContent_Map.put(BuildGradleFile, dst_build_gradle_File_StrList);

            System.out.println("dst_build_gradle_File_StrList.size() = " + dst_build_gradle_File_StrList.size());

        }

        String readStringsXml_AppName(File stringsXmlFile, String newAppName) {

            String local_appName = null;

            if (stringsXmlFile == null || !stringsXmlFile.exists()) {
                return local_appName;
            }

            ArrayList<String> rawStringXml_StrList = ReadFileContentAsList(stringsXmlFile);

            if (rawStringXml_StrList == null) {
                return local_appName;
            }

            for (int i = 0; i < rawStringXml_StrList.size(); i++) {
                String oneLineStr = rawStringXml_StrList.get(i);
                // <string name="app_name">VLC</string>
                if (oneLineStr.contains("name=\"app_name\"")) {
                    String appNameBeginStr = oneLineStr.substring(oneLineStr.indexOf("name=\"app_name\"")).trim();

                    local_appName = appNameBeginStr.replace("name=\"app_name\"", "").trim();
                    local_appName = local_appName.replace(" ", "");
                    local_appName = local_appName.replace("</string>", "");
                    local_appName = local_appName.replace("<string", "");
                    local_appName = local_appName.replace("\"", "");
                    local_appName = local_appName.replace(">", "");
                    local_appName = local_appName.replace("<", "");
                    String fixed_product_linestr = "<string name=\"app_name\">" + newAppName + "</string>";
                    dst_strings_xml_File_StrList.add(fixed_product_linestr);
                    continue;
                }
                dst_strings_xml_File_StrList.add(oneLineStr);

            }

            src_fixed_FileList.add(stringsXmlFile);
            srcFile_fixedContent_Map.put(stringsXmlFile, dst_strings_xml_File_StrList);

            return local_appName;

        }

        String readAndroidManifext_ProductName(File manifestFile, String productappendStr) {
            String local_prductName = null;

            if (manifestFile == null || !manifestFile.exists()) {
                return local_prductName;
            }

            ArrayList<String> rawAndroidManifest_StrList = ReadFileContentAsList(manifestFile);

            if (rawAndroidManifest_StrList == null) {
                return local_prductName;
            }

            for (int i = 0; i < rawAndroidManifest_StrList.size(); i++) {
                String oneLineStr = rawAndroidManifest_StrList.get(i);

                if (oneLineStr.contains("package=")) {
                    String packageBeginStr = oneLineStr.substring(oneLineStr.indexOf("package=")).trim();

                    local_prductName = packageBeginStr.replace("package=", "").trim();
                    local_prductName = local_prductName.replace(" ", "");
                    local_prductName = local_prductName.replace("\"", "");
                    local_prductName = local_prductName.replace(">", "");
                    local_prductName = local_prductName.replace("<", "");
                    local_prductName = local_prductName.replace("\"", "");
                    String new_product_Name = local_prductName + "_" + productappendStr;
                    String fixed_product_linestr = oneLineStr.replace(local_prductName, new_product_Name);
                    System.out.println("fixed_product_linestr = " + fixed_product_linestr + "  new_product_Name="
                            + new_product_Name);
                    dst_AndroidManifest_xml_File_StrList.add(fixed_product_linestr);
                    continue;
                }
                dst_AndroidManifest_xml_File_StrList.add(oneLineStr);

            }

            src_fixed_FileList.add(manifestFile);
            srcFile_fixedContent_Map.put(manifestFile, dst_AndroidManifest_xml_File_StrList);

            return local_prductName;
        }
        // 1. 根目录下有 settings.gradle
        // 2. 根目录下有 build.gradle
        // 3. 根目录\app\src\main\AndroidManifest.xml 文件存在

        boolean isShellInAndroidAPKDir() {
            boolean isApkDirFlag = false;
            File shellDir = new File(curDirPath);
            if (!shellDir.exists()) {
                System.out.println("当前 输入的路径错误: 不存在:  curDirPath = " + curDirPath);
                return isApkDirFlag;
            }

            src_settings_gradle_File = new File(shellDir.getAbsolutePath() + File.separator + "settings.gradle");
            if (!src_settings_gradle_File.exists()) {
                System.out.println("当前 app工程目录下不包含 settings.gradle 文件 请检查!  curDirPath=" + curDirPath);
                return isApkDirFlag;
            }

            src_build_gradle_File = new File(
                    shellDir.getAbsolutePath() + File.separator + "app" + File.separator + "build.gradle");
            if (!src_build_gradle_File.exists()) {
                System.out.println("当前 app工程目录下不包含 apk目录/app/settings.gradle 文件 请检查!  curDirPath=" + curDirPath);
                return isApkDirFlag;
            }

            src_AndroidManifest_xml_File = new File(shellDir.getAbsolutePath() + File.separator + "app" + File.separator
                    + "src" + File.separator + "main" + File.separator + "AndroidManifest.xml");
            if (!src_AndroidManifest_xml_File.exists()) {
                System.out.println(
                        "当前 app工程目录下不包含 apk目录/app/src/main/AndroidManifest.xml 文件 请检查!  curDirPath=" + curDirPath);
                return isApkDirFlag;
            }

            src_strings_xml_File = new File(shellDir.getAbsolutePath() + File.separator + "app" + File.separator + "src"
                    + File.separator + "main" + File.separator + "res" + File.separator + "values" + File.separator
                    + "strings.xml");

            if (!src_strings_xml_File.exists()) {
                System.out.println("当前 apk目录/app/src/main/res/values/strings.xml  文件不存在   注意:显示的APK名称可能无法修改!");
            }

            return true;

        }

        @Override
        String simpleDesc() {

            return "\n" + Cur_Bat_Name + " #_" + rule_index
                    + "  appname_xxxxxx  productappend_xxxxx    // 如果 当前 shell 目录是app代码根目录 那么在clone一个apk到父文件夹 appname指定显示的apk名称 productappend用于在原有工程名添加后缀使得app相互独立  \n"
                    + Cur_Bat_Name + "  #_" + rule_index
                    + " appname_z      ### 如果 当前 shell 目录是app代码根目录 那么在clone一个apk到父文件夹 appname指定显示的apk名称为z  productappend用于在原有工程名添加后缀使得app相互独立  复制zapp zmain 代码目录  \n"
                    + ""
//			zrule_apply_G2.bat  #_53  appname_z  productappend_xxx
                    ;
        }

        @Override
        ArrayList<File> applyDir_SubFileListRule5(ArrayList<File> allSubDirFileList,
                                                  ArrayList<File> allSubRealFileList) {

            // 创建 clone 的 目录文件
            try {
                dst_apk_Dir.mkdirs();
            } catch (Exception e) { //

                System.out.println("创建 dst_apk_Dir=" + dst_apk_Dir + " 失败!");
            }

            if (!dst_apk_Dir.exists()) {
                System.out.println("当前 Clone 目录 不存在 请检查  dst_apk_Dir=" + dst_apk_Dir);
                return null;
            }
            dst_apk_Dir.mkdirs();
            if (!dst_apk_Dir.exists()) {

                System.out.println("当前 Clone 目录 不存在 请检查  dst_apk_Dir=" + dst_apk_Dir);
                return null;
            }

            // old_product_endfixname_DirFile
            int matchFileCount = 0;
            for (int i = 0; i < allSubDirFileList.size(); i++) {
                File dirFile = allSubDirFileList.get(i);

                String dirName = dirFile.getName();
                String dirFile_AbsPath = dirFile.getAbsolutePath();

                if (dirName.equals(old_product_endfixname) && !dirFile_AbsPath.contains("ap_generated_sources")
                        && !dirFile_AbsPath.contains("out") && !dirFile_AbsPath.contains("generated")
                        && !dirFile_AbsPath.contains("androidTest")
                        && !dirFile_AbsPath.contains((File.separator + "test" + File.separator))
                        && !dirFile_AbsPath.contains("intermediates")) {
                    old_product_endfixname_DirFile = dirFile;
                    System.out.println("match_old_product_endfixname[" + matchFileCount + "] = " + dirFile_AbsPath);
                    matchFileCount++;
                }
            }

            if (old_product_endfixname_DirFile == null) {
                System.out.println(
                        "当前没有找到 " + old_product_name + "对应的工程目录地址:" + old_product_endfixname_DirFile + "  执行失败请检查!");
                return null;
            }
            System.out.println("old_product_endfixname_DirFile = " + old_product_endfixname_DirFile);

// old_product_endfixname;
// zmain-Life-main_203136\app\src\main\java\com\and\zmain_life  变为
// zmain-Life-main_203136\app\src\main\java\com\and\zmain_life_203136

            String old_product_endfixname_Path = old_product_endfixname_DirFile.getAbsolutePath();
            String new_product_endfixname_Path = old_product_endfixname_Path.replace(old_product_endfixname,
                    new_product_endfixname);

            for (int i = 0; i < allSubRealFileList.size(); i++) {
                File copyItem = allSubRealFileList.get(i);
                String copyItem_AbsPath = copyItem.getAbsolutePath();
                // zmain-Life-main 和 zmain-Life-main_202111
                String endfixname_path_AbsPath = copyItem_AbsPath.replace(old_product_endfixname_Path,
                        new_product_endfixname_Path);
                if (copyItem_AbsPath.contains(old_product_endfixname_Path)) {
                    System.out.println("匹配到 old_product_endfixname_Path=" + old_product_endfixname_Path + " match文件 = "
                            + copyItem_AbsPath);
                }
                String targetItem_AbsPath = endfixname_path_AbsPath.replace(src_apk_Dir.getAbsolutePath(),
                        dst_apk_Dir.getAbsolutePath());
                File targetItem = new File(targetItem_AbsPath);
                if (copyItem.getName().toLowerCase().endsWith(".java")) {
                    src_all_Java_FileList.add(copyItem);
                    dst_all_Java_FileList.add(targetItem);
                }

                if (copyItem.getName().toLowerCase().endsWith(".xml") && copyItem.getAbsolutePath().toLowerCase()
                        .contains((File.separator + "layout" + File.separator))) {
                    src_all_Layout_XmlFileList.add(copyItem);
                    dst_all_Layout_XmlFileList.add(targetItem);
                }

                System.out.println("copyItem[" + (i + 1) + "][" + allSubRealFileList.size() + "] = " + copyItem
                        + "  targetItem=" + targetItem_AbsPath + "  old_product_endfixname_Path="
                        + old_product_endfixname_Path + "   new_product_endfixname_Path=" + new_product_endfixname_Path
                        + "   src_apk_Dir=" + src_apk_Dir + "  dst_apk_Dir=" + dst_apk_Dir);

                fileCopy(copyItem, targetItem);
            }

            System.out.println("src_fixed_FileList.size() = " + src_fixed_FileList.size());
            System.out.println("dst_all_Layout_XmlFileList.size() = " + dst_all_Layout_XmlFileList.size());

            // 开始对 目标文件 进行 修改
            for (int i = 0; i < src_fixed_FileList.size(); i++) {
                File product_fixed_file = src_fixed_FileList.get(i);
                String product_fixed_file_AbsPath = product_fixed_file.getAbsolutePath();
                String target_fixed_file_path = product_fixed_file_AbsPath.replace(src_apk_Dir.getAbsolutePath(),
                        dst_apk_Dir.getAbsolutePath());
                File target_fixed_file = new File(target_fixed_file_path);
                if (target_fixed_file.exists()) {
                    ArrayList<String> matchFixedArr = srcFile_fixedContent_Map.get(product_fixed_file);
                    if (matchFixedArr != null && matchFixedArr.size() > 0) {
                        System.out.println("Product_writeItem[" + (i + 1) + "][" + src_fixed_FileList.size()
                                + "]  --> linenum=" + matchFixedArr.size());
                        writeContentToFile(target_fixed_file, matchFixedArr);
                    }

                    for (int j = 0; j < matchFixedArr.size(); j++) {
                        System.out.println(matchFixedArr.get(j));
                    }

                }

            }

            System.out.println("dst_all_Java_FileList.size() = " + dst_all_Java_FileList.size());
            for (int i = 0; i < dst_all_Java_FileList.size(); i++) {

                File javaFileItem = dst_all_Java_FileList.get(i);
                System.out.println("Java_writeItem[" + (i + 1) + "][" + dst_all_Java_FileList.size() + "]  ");

                ArrayList<String> rawContent = ReadFileContentAsList(javaFileItem);

                if (rawContent == null || rawContent.size() == 0) {
                    continue;
                }

                ArrayList<String> fixed_rawContent = new ArrayList<String>();
                for (int j = 0; j < rawContent.size(); j++) {
                    String lineStr = rawContent.get(j);

                    if (lineStr.contains(old_product_name)) {
                        String fixedStr = lineStr.replace(old_product_name, new_product_name);
                        fixed_rawContent.add(fixedStr);
                        continue;
                    }

                    fixed_rawContent.add(lineStr);

                }
                writeContentToFile(javaFileItem, fixed_rawContent);

            }

            System.out.println("dst_all_Layout_XmlFileList.size() = " + dst_all_Layout_XmlFileList.size());
            for (int i = 0; i < dst_all_Layout_XmlFileList.size(); i++) {

                File xmlFileItem = dst_all_Layout_XmlFileList.get(i);
                System.out.println("Xml_writeItem[" + (i + 1) + "][" + dst_all_Layout_XmlFileList.size() + "]  ");

                ArrayList<String> rawContent = ReadFileContentAsList(xmlFileItem);

                if (rawContent == null || rawContent.size() == 0) {
                    continue;
                }

                ArrayList<String> fixed_rawContent = new ArrayList<String>();
                for (int j = 0; j < rawContent.size(); j++) {
                    String lineStr = rawContent.get(j);

                    if (lineStr.contains(old_product_name)) {
                        String fixedStr = lineStr.replace(old_product_name, new_product_name);
                        fixed_rawContent.add(fixedStr);
                        continue;
                    }

                    fixed_rawContent.add(lineStr);

                }
                writeContentToFile(xmlFileItem, fixed_rawContent);

            }

            System.out.println("Clone APK 的操作已完成   目标目录=" + dst_apk_Dir);

            return super.applyDir_SubFileListRule5(allSubDirFileList, allSubRealFileList);

        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);

        }

    }

    class Delete_SameMD5File_OnlyExistOneInDir_Rule_52 extends Basic_Rule {

        boolean showmd5 = false;
        boolean force_delete = false;

        boolean clear_emptydir = false;  // 清除  空 文件夹


        ArrayList<File> needDeleteFileList; // 需要删除的文件

        ArrayList<String> allMD5List; // 所有文件的MD5的值

        Delete_SameMD5File_OnlyExistOneInDir_Rule_52() {
            super("#", 52, 5); //
            force_delete = false;
            showmd5 = false;
            needDeleteFileList = new ArrayList<File>();
            allMD5List = new ArrayList<String>();
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // mdname_true // kaoyan_true gaokao_true

//			src_xxxxxx
//			dst_xxxxx

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem_lower_trim = inputParamList.get(i);
//				String paramItem_lower_trim = paramItem.toLowerCase().trim();

                if (paramItem_lower_trim.startsWith("delete_true")) {
                    force_delete = true;
                }

                if (paramItem_lower_trim.startsWith("showmd5_true")) {
                    showmd5 = true;
                }

                if (paramItem_lower_trim.startsWith("clear_emptydir")) {
                    clear_emptydir = true;
                }

            }

            System.out.println(" 当前输入 delete_true=" + force_delete +  "  showmd5="+showmd5+"   clear_emptydir="+clear_emptydir);

            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }

        void operation_delete_empty_dirs(ArrayList<File> allDirFileList) {

            allDirFileList.sort(mFileDateComparion_Deep_Seperator);


            for (int i = 0; i < allDirFileList.size(); i++) {
                File file_item =  allDirFileList.get(i);
                boolean isEmptyDir = true;
                if(file_item.exists() && file_item.listFiles() != null  && file_item.listFiles().length > 0 ) {
                    isEmptyDir = false;

                }


                if(isEmptyDir) {
                    System.out.println("删除 all_dir["+i+"]["+allDirFileList.size()+"] = " +" file_seperator["+getStrRepeatCount(file_item.getAbsolutePath(), File.separator)+"] isEmptyDir["+isEmptyDir+"]  Path=" + file_item.getAbsolutePath() );

                    file_item.delete();

                }else {

                    System.out.println("保留 all_dir["+i+"]["+allDirFileList.size()+"] = " +" file_seperator["+getStrRepeatCount(file_item.getAbsolutePath(), File.separator)+"] isEmptyDir["+isEmptyDir+"]  Path=" + file_item.getAbsolutePath() );

                }


            }

        }

        @Override
        ArrayList<File> applyDir_SubFileListRule5(ArrayList<File> allSubDirFileList,
                                                  ArrayList<File> allSubRealFileList) {
            ArrayList<File> allOperationDirList = new ArrayList<File>();
            if (allSubDirFileList != null) {
                allOperationDirList.addAll(allSubDirFileList);
            }
            allSubDirFileList.add(curDirFile);

            if(clear_emptydir) {

                System.out.println("执行删除 空文件夹的操作! ");
                operation_delete_empty_dirs(allSubDirFileList);

                return null ;
            }

            for (int i = 0; i < allOperationDirList.size(); i++) {
                File subDir = allOperationDirList.get(i);
                File[] subFileArr = subDir.listFiles();
                if (subFileArr == null || subFileArr.length == 0) {
                    continue;
                }
                ArrayList<String> md5ValueList = new ArrayList<String>();

                for (int j = 0; j < subFileArr.length; j++) {
                    File fileItem = subFileArr[j];
                    if (fileItem.isDirectory()) {
                        continue;
                    }
                    String md5Value = getMD5Three(fileItem.getAbsolutePath());

                    if (!allMD5List.contains(md5Value)) {
                        allMD5List.add(md5Value);
                    }

                    if (!md5ValueList.contains(md5Value)) {
                        md5ValueList.add(md5Value);
                    } else { // 如果 已经 包含 这个 MD5 说明 已经 包含 这个文件了 那么加入 需要被删除的列表
                        needDeleteFileList.add(fileItem);
                    }

                }

            }

            for (int i = 0; i < needDeleteFileList.size(); i++) {
                File needDeleteFile = needDeleteFileList.get(i);
                System.out.println("need_delete_重复[" + i + "] = " + needDeleteFile.getAbsolutePath());

                if (force_delete) {
                    needDeleteFile.delete();
                }
            }

            String delete_tip = force_delete ? "强制删除Flag:OK" : "强制删除Flag:False";
            System.out.println("相同文件夹下重复文件数量:" + needDeleteFileList.size() + "   " + delete_tip);

            if (showmd5) {

                StringBuilder sbLog = new StringBuilder();
                for (int i = 0; i < allMD5List.size(); i++) {
                    String md5Item = allMD5List.get(i);
                    sbLog.append(md5Item + "\n");

                }
                writeContentToFile(G2_Temp_Text_File, sbLog.toString());
                NotePadOpenTargetFile(G2_Temp_Text_File.getAbsolutePath()); // 打开 notepad++
            }

            return super.applyDir_SubFileListRule5(allSubDirFileList, allSubRealFileList);
        }

        @Override
        String simpleDesc() {

            return "\n" + Cur_Bat_Name + " #_" + rule_index
                    + "  delete_true      //  去除在 一个文件夹中 多余的相同的 MD5 文件   只保留 一个MD5  去重操作  \n" + Cur_Bat_Name + "  #_"
                    + rule_index + " showmd5_true    ###  把 当前的目录中的文件的MD5 输出到文本中   \n" + Cur_Bat_Name + "  #_"
                    + rule_index + " showmd5_true delete_true    ###  把 当前的目录中的文件的MD5 输出到文本中 并删除重复文件  \n"
                    + Cur_Bat_Name	+ "  #_" + rule_index + "  clear_emptydir   ###  删除所有子目录 孙目录 为空的 文件夹   \n" + ""
                    + Cur_Bat_Name	+ "  #_" + rule_index + "    ### 打印当前目录的重复文件  \n" + ""
//			zrule_apply_G2.bat  #_46  copyright_show  harddir_true
                    ;
        }

    }

    class SrcDir_Copy2_DstDir_WithFileLength_Rule_51 extends Basic_Rule {
        File src_Dir; // 源目录
        File dst_Dir; // 目的目录

        // 需要执行 从 src 复制到 dst 的 实体文件的 对应关系
        HashMap<File, File> srcFile_dstFile_Map;
        ArrayList<File> needCopyFileList = new ArrayList<File>(); // 需要 进行 复制操作的文件(文件大小不一样)
        private File copyFileItem;

        SrcDir_Copy2_DstDir_WithFileLength_Rule_51() {
            super("#", 51, 4); //

            needCopyFileList = new ArrayList<File>();
            srcFile_dstFile_Map = new HashMap<File, File>();
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // mdname_true // kaoyan_true gaokao_true

//			src_xxxxxx
//			dst_xxxxx

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem_lower_trim = inputParamList.get(i);
//				String paramItem_lower_trim = paramItem.toLowerCase().trim();

                if (paramItem_lower_trim.startsWith("src_")) {

                    String srcDirPath = (" " + paramItem_lower_trim).replace(" src_", "");
                    srcDirPath = srcDirPath.replace(" ", "");

                    File srcDirFile = new File(srcDirPath);
                    if (!srcDirFile.exists()) {
                        System.out.println("当前 SRC目录[" + srcDirPath + "] 不存在 请检查输入参数!");
                        return false;
                    }

                    if (!srcDirFile.isDirectory()) {
                        System.out.println("当前 SRC目录[" + srcDirPath + "] 不是文件夹  请检查输入参数!");

                        return false;
                    }

                    src_Dir = srcDirFile;
                }

                if (paramItem_lower_trim.startsWith("dst_")) {

                    String dstDirPath = (" " + paramItem_lower_trim).replace(" dst_", "");
                    dstDirPath = dstDirPath.replace(" ", "");

                    File dstDirFile = new File(dstDirPath);
                    if (!dstDirFile.exists()) {
                        System.out.println("当前 DST目录[" + dstDirPath + "] 不存在 请检查输入参数!");
                        return false;
                    }

                    if (!dstDirFile.isDirectory()) {
                        System.out.println("当前 DST目录[" + dstDirPath + "] 不是文件夹  请检查输入参数!");

                        return false;
                    }

                    dst_Dir = dstDirFile;
                }

            }

            if (src_Dir == null) {
                System.out.println("当前 SRC 目录[" + src_Dir + "] 为空   请检查输入参数!");

                return false;

            }

            if (dst_Dir == null) {
                System.out.println("当前 DST目录[" + dst_Dir + "] 为空   请检查输入参数!");

                return false;

            }

            System.out.println(" 当前输入 SRC[ " + src_Dir.getAbsolutePath() + "]  Dst[ " + dst_Dir.getAbsolutePath() + "]"
                    + " ] 存在  将执行代码逻辑");

            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }

        // 如果当前的需要 提交的 文件中 不包含 json 文件 那么 不提交这次文件 以达到 省空间的 目的
        // xlsx 每次更新都是全替换 而不是 部分替换 导致 更新文件大小过大

        @Override
        String simpleDesc() {

            return "\n" + Cur_Bat_Name + " #_" + rule_index
                    + "  src_xxxxxx  dst_xxxxx    //  把 当前的 原目录中的所有文件 复制到 对应目录的文件， 额外必须包含json文件   更新stock-xlsx时使用 如果文件大小一致 那么就跳过复制的过程  \n"
                    + Cur_Bat_Name + "  #_" + rule_index
                    + " src_  dst_  ###  把 当前的 原目录中的所有文件 复制到 对应目录的文件，xlsx 每次更新都是全替换 而不是 部分替换 导致 更新文件大小过大 特用更新ActionDemo 一天只更新一次   \n"
                    + ""
//			zrule_apply_G2.bat  #_46  copyright_show  harddir_true
                    ;
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
// TODO Auto-generated method stub

            File[] srcFileArr = src_Dir.listFiles();
            File[] dstFileArr = dst_Dir.listFiles();

            if (srcFileArr == null || srcFileArr.length == 0) {
                System.out.println("  当前 原目录 Src目录[" + src_Dir.getAbsolutePath() + "] 中文件为空  ");

                return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);

            }

            // needCopyFileList

            for (int i = 0; i < srcFileArr.length; i++) {
                File fileItem = srcFileArr[i];
                if (fileItem.isDirectory()) { // 不对 文件夹进行复制
                    continue;
                }

                String name = fileItem.getName();
                String dstMatchFilePath = dst_Dir.getAbsolutePath() + File.separator + name;
                File dstMatchFile = new File(dstMatchFilePath);

                if (dstMatchFile.exists()) {
                    // 源文件大小要大于 10
                    long srcFileSize = fileItem.length();
                    long dstFileSize = dstMatchFile.length();
                    long diffSize = Math.abs(dstFileSize - srcFileSize);

                    if (dstMatchFile.length() != fileItem.length() // 两个文件的大小不一样才执行 copy
                            && fileItem.length() > 10 // 源文件的大小要大于10 才执行 copy
                            && diffSize > 100) { // 两个文件的差异要大于100 才 执行 copy 文件

                        // 原目录 有这个文件 但是和 dst 目录不一致 那么也加入 copy 列表
                        needCopyFileList.add(fileItem);
                        srcFile_dstFile_Map.put(fileItem, dstMatchFile);
                    }
                } else {
                    // 原目录 没有这个文件 那么加入copy列表
                    needCopyFileList.add(fileItem);
                    srcFile_dstFile_Map.put(fileItem, dstMatchFile);
                }

            }

            System.out.println("当前 需要执行 Copy 操作的 文件 的 总数 : " + needCopyFileList.size());
            System.out.println("开始执行 ———————— Copy-Operation begin —————");

            if (needCopyFileList.size() > 0 && isContainJsonFile(needCopyFileList)) {
                for (int i = 0; i < needCopyFileList.size(); i++) {

                    File srcItem = needCopyFileList.get(i);

                    File dstFile = srcFile_dstFile_Map.get(srcItem);
                    System.out.println("开始第[" + i + "] 个_SRC_文件复制 src[" + srcItem + "][Size:" + srcItem.length()
                            + "][MD5:" + getMD5Three(srcItem.getAbsolutePath()) + "]");
                    System.out.println("");

                    if (dstFile == null) {
                        continue;
                    }

                    System.out.println("完成第[" + i + "] 个_DST_文件复制 dst[" + dstFile + "][Size:" + dstFile.length()
                            + "][MD5:" + getMD5Three(dstFile.getAbsolutePath()) + "]");

                    if (dstFile.exists()) {
                        dstFile.delete();
                    }

                    fileCopy(srcItem, dstFile);

                }

            }
            System.out.println("开始执行 ———————— Copy-Operation end —————");

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);

        }

        boolean isContainJsonFile(ArrayList<File> mCopyFileList) {
            for (int i = 0; i < mCopyFileList.size(); i++) {
                File copyFileItem = mCopyFileList.get(i);
                String fileName_lower = copyFileItem.getName().toLowerCase().trim();
                System.out.println("copyFileItem[" + i + "]" + copyFileItem.getAbsolutePath());

                if (fileName_lower != null && fileName_lower.endsWith(".json")) {
                    System.out.println("当前 复制 目录 包含 json 文件:" + copyFileItem.getAbsolutePath() + " 将执行复制操作!");
                    return true;
                }
            }
            System.out.println("当前 复制文件列表 目录 不包含 json 文件      将不执行复制操作!");

            return false;
        }

    }

    // 把 当前的 输入的 jpg 或者 当前目录下的 jpg文件 动态计算成 320 宽度的 字符串 并 在打开的文件中打印
    class JPG_To_TextChar_Rule_50 extends Basic_Rule {
        // true 那么就对当前目录下的所有 jpg文件进行 打印字符串画像操作 false--说明有输入对输入进行操作
        boolean isDirOperation; // 是否没有输入 jpg 文件 而是 输入了一个 目录 默认shell 目录 已经 输入的目录

        StringBuilder allSB;
        File inputDirFile;
        ArrayList<File> jpgFileList;

        JPG_To_TextChar_Rule_50() {
            super("#", 50, 3); //
            jpgFileList = new ArrayList<File>();
            inputDirFile = null;
            allSB = new StringBuilder();
            isDirOperation = false;
        }

        @Override
        boolean allowEmptyDirFileList() {
            // TODO Auto-generated method stub
            return true;
        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {
            // TODO Auto-generated method stub

            for (int i = 0; i < jpgFileList.size(); i++) {
                File jpgFile = jpgFileList.get(i);
                String jpgFileName = jpgFile.getName();
                String getjpgNameNoType = getFileNameNoPoint(jpgFileName);

                File jpgFile_resultDir = null;

                if (isDirOperation && inputDirFile != null) {
                    jpgFile_resultDir = inputDirFile;

                    // 打印的 宽度 默认设置为 320
                    BufferedImage jpgImage;
                    try {
                        jpgImage = resizeImage(jpgFile.getAbsolutePath(), 320);
                        allSB.append(printImage(jpgImage));
                    } catch (IOException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }

//			        System.out.println(" Width:"+image.getWidth()+"  High:"+image.getHeight());

                } else {
                    // 如果 不是 输入 目录 的 话 那么就创建 jpg 的 文件名称 如果是目录的话 那么就在当前目录生成 .json

                    BufferedImage jpgImage;
                    try {
                        jpgImage = resizeImage(jpgFile.getAbsolutePath(), 320);
                        allSB.append(printImage(jpgImage));
                    } catch (IOException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }

//			        System.out.println(" Width:"+image.getWidth()+"  High:"+image.getHeight());

                }

            }

            // 打开 notepad++

            writeContentToFile(G2_Temp_Text_File, allSB.toString());
            NotePadOpenTargetFile(G2_Temp_Text_File.getAbsolutePath());

            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_" + rule_index + "  <指定A.jpg文件> <指定B.jpg文件>  ### 对给定的jpg 打印它的 字符串画像   \n"
                    + Cur_Bat_Name + " #_" + rule_index + "   ### 解析当前目录jpg 打印出所有的画像    \n";
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {
                String strInput = inputParamList.get(i);

                File tempFile = new File(curDirPath + File.separator + strInput);
                if (tempFile.exists() && !tempFile.isDirectory()) {
                    String inputFileName = tempFile.getName().toLowerCase();
                    if (inputFileName.endsWith(".jpg") || inputFileName.endsWith(".JPG")) {
                        jpgFileList.add(tempFile);
                    }

                }

                File inputDir = new File(strInput);
                if (inputDir.exists() && inputDir.isDirectory()) {
                    isDirOperation = true;
                    inputDirFile = inputDir;
                }

                System.out.println("initParamsWithInputList[" + i + "] = " + strInput + "  inputDir.exists()="
                        + inputDir.exists() + "  inputDir.isDirectory()=" + inputDir.isDirectory());

            }

            if (jpgFileList.size() == 0 && inputDirFile == null) {
                System.out.println("当前 输入的 jpg 文件 为 空 无法获取 输入的 jpg 请检查 输入!! ");
                File shellDir = new File(curDirPath);
                if (shellDir != null && shellDir.exists()) {
                    File[] listArr = shellDir.listFiles();

                    if (listArr == null || listArr.length == 0) {
                        System.out.println("当前 输入的目录  " + inputDirFile.getAbsolutePath() + "没有 任何文件操作!!");

                        return false;
                    }
                    for (int i = 0; i < listArr.length; i++) {
                        File fileItem = listArr[i];

                        String inputFileName = fileItem.getName().toLowerCase();
                        if (inputFileName.endsWith(".jpg") || inputFileName.endsWith(".jpg")) {
                            jpgFileList.add(fileItem);
                            isDirOperation = true;
                            inputDirFile = shellDir;
                        }

                    }

                } else {
                    System.out.println("当前 输入的 jpg 文件为空  shell目录为空 无法获取 输入的 xlsx 请检查 输入!! ");
                    return false;

                }

            }

            /*
             * if (inputDirFile != null) { File[] listArr = inputDirFile.listFiles(); if
             * (listArr == null || listArr.length == 0) { System.out.println("当前 输入的目录  " +
             * inputDirFile.getAbsolutePath() + "没有 任何文件操作!!");
             *
             * return false; } for (int i = 0; i < listArr.length; i++) { File fileItem =
             * listArr[i];
             *
             * String inputFileName = fileItem.getName().toLowerCase(); if
             * (inputFileName.endsWith(".jpg") || !jpgFileList.contains(fileItem)) {
             * jpgFileList.add(fileItem); }
             *
             * }
             *
             * }
             */

            if (jpgFileList.size() == 0) {
                System.out.println(
                        "当前 输入的目录  inputDirFile =" + (inputDirFile == null ? "null" : inputDirFile.getAbsolutePath())
                                + "没有 任何文件的 .jpg .JPG文件进行操作!!");

                return false;

            }
            if (inputDirFile == null) {
                System.out.println("ZXX inputDirFile = null " + " jpgFileList.size()=" + jpgFileList.size()
                        + "   isDirOperation=" + isDirOperation);

            } else {
                System.out.println("ZXX inputDirFile =" + inputDirFile.getAbsolutePath() + "    jpgFileList.size()="
                        + jpgFileList.size() + "   isDirOperation=" + isDirOperation);

            }

            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }

        /**
         * 图片缩放
         *
         * @param srcImagePath 图片路径
         * @param targetWidth  目标宽度
         * @return
         * @throws IOException
         */
        public BufferedImage resizeImage(String srcImagePath, int targetWidth) throws IOException {
            Image srcImage = ImageIO.read(new File(srcImagePath));
            // 这里除以2 原始高度除以2 notepad++ 打开宽高宽度不一致 这里使得高度减少一半 看起来对称
            int targetHeight = (int) (getTargetHeight(targetWidth, srcImage) / 2);
            BufferedImage resizedImage = new BufferedImage(targetWidth, targetHeight, BufferedImage.TYPE_INT_RGB);
            Graphics2D graphics2D = resizedImage.createGraphics();
            graphics2D.drawImage(srcImage, 0, 0, targetWidth, targetHeight, null);
            graphics2D.dispose();
            return resizedImage;
        }

        /**
         * 图片缩放
         *
         * @param srcImagePath 图片路径
         * @param targetWidth  目标宽度
         * @return
         * @throws IOException
         */
        public BufferedImage resizeImage2(String srcImagePath, int targetWidth) throws IOException {
            Image srcImage = ImageIO.read(new File(srcImagePath));
            int targetHeight = getTargetHeight(targetWidth, srcImage);
            Image image = srcImage.getScaledInstance(targetWidth, targetHeight, Image.SCALE_DEFAULT);
            BufferedImage bufferedImage = new BufferedImage(targetWidth, targetHeight, BufferedImage.TYPE_INT_RGB);
            bufferedImage.getGraphics().drawImage(image, 0, 0, null);
            return bufferedImage;
        }

        /**
         * 根据指定宽度，计算等比例高度
         *
         * @param targetWidth 目标宽度
         * @param srcImage    图片信息
         * @return
         */
        private int getTargetHeight(int targetWidth, Image srcImage) {
            int targetHeight = srcImage.getHeight(null);
            if (targetWidth < srcImage.getWidth(null)) {
                targetHeight = Math
                        .round((float) targetHeight / ((float) srcImage.getWidth(null) / (float) targetWidth));
            }
            return targetHeight;
        }

        /**
         * 图片打印
         *
         * @param image
         * @throws IOException
         */
        public String printImage(BufferedImage image) throws IOException {
            final char[] PIXEL_CHAR_ARRAY = { 'W', '@', '#', '8', '&', '*', 'o', ':', '.', ' ' };
            int width = image.getWidth();
            int height = image.getHeight();
            StringBuilder imageSB = new StringBuilder();
            for (int i = 0; i < height; i++) {
                for (int j = 0; j < width; j++) {
                    int rgb = image.getRGB(j, i);
                    Color color = new Color(rgb);
                    int red = color.getRed();
                    int green = color.getGreen();
                    int blue = color.getBlue();
                    // 一个用于计算RGB像素点灰度的公式
                    Double grayscale = 0.2126 * red + 0.7152 * green + 0.0722 * blue;
                    double index = grayscale / (Math.ceil(255 / PIXEL_CHAR_ARRAY.length) + 0.5);
                    System.out.print(PIXEL_CHAR_ARRAY[(int) (Math.floor(index))]);
                    imageSB.append(PIXEL_CHAR_ARRAY[(int) (Math.floor(index))]);
                }

                System.out.println();
                imageSB.append("\n");
            }

            imageSB.append("\n");
            imageSB.append("\n");
            imageSB.append("\n");
            imageSB.append("\n");
//	        imageSB.append("\n");
//	        imageSB.append("\n");
            return imageSB.toString();
        }

    }

    // 给定一个 类型的 模板 起始页(默认1) 最终页(默认100)
    // 是否代理(默认false) itemtag(页面内的标记用于过滤) imagetag(详细内容也的照片的标示)
    // CategoryModel_HttpPage_Download_Rule_49

    class CategoryModel_HttpPage_Download_Rule_49 extends Basic_Rule {

        String mCategoryModel; // Page 主页的模板 使用 {page} 来对 页面进行替换 默认为 {page}

        int beginPageIndex;
        int mNextPageStep = 1;
        int endPageIndex;

        ArrayList<String> mDynamicPageUrlList;
        boolean isProxy; // 是否代理

        String mHrefTag = ""; // category 页面下的 每 个项的 标示
        String mImageTag = ""; // 需要下载的图片的特殊标示 如果为空 那么 就下载 全部 不过滤
        int mSleepInterval; // 每个 页面 完成下载的 睡眠 时间 默认 10秒

        // 有些参数从 bat 传递不过来 比如 & ? 等等 需要做转义
        HashMap<String, String> needReplaceWordMap;
        ArrayList<String> needReplaceWordKeyList;
        ArrayList<String> needRealExistWordValueList;

        // https://tieba.baidu.com/f?kw=%E6%9D%8E%E6%AF%85&ie=utf-8&pn=350
        String mCategoryMainUrl; // item 页面是使用相对的路径 没有出现 绝对路径 所以得 保存 这个 主路径
        String httpXpre; // http:// 或者 https://(默认)

        // 有些网页 不是按照 页面内容来的 是按照 多少个item数值 来的 所以有这个参数 每页的步长 默认为1

        ChromeDriver mChromeDriver;
        File ImageDownloadDir;

        CategoryModel_HttpPage_Download_Rule_49() {
            super("#", 49, 4);

            mCategoryModel = "{page}";
            mCategoryMainUrl = mCategoryModel;
            httpXpre = "https://";
            beginPageIndex = 1;
            endPageIndex = 100;
            mDynamicPageUrlList = new ArrayList<String>();

            isProxy = false;
            mHrefTag = ""; // category 页面下的 每 个项的 标示
            mImageTag = ""; // 需要下载的图片的特殊标示
            mSleepInterval = 10;
            mNextPageStep = 1;

            needReplaceWordKeyList = new ArrayList<String>();
            needRealExistWordValueList = new ArrayList<String>();
            needReplaceWordMap = new HashMap<String, String>();
            initReplaceWord();

        }

        void initReplaceWord() {
            addReplaceWord("#", "=");
            addReplaceWord("@", "&");
        }

        void addReplaceWord(String mSrcWord, String mDstWord) {

            needReplaceWordKeyList.add(mSrcWord);
            needRealExistWordValueList.add(mDstWord);
            needReplaceWordMap.put(mSrcWord, mDstWord);

        }

        String replaceWordToExist(String mSrcStr) {
            String result = mSrcStr;

            for (int i = 0; i < needReplaceWordKeyList.size(); i++) {
                String holdstr = needReplaceWordKeyList.get(i);
                String realValue = needReplaceWordMap.get(holdstr);
                result = result.replaceAll(holdstr, realValue);

            }

            return result;

        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            boolean Flag = true;

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem = inputParamList.get(i);
                String paramItem_lower_trim = paramItem.toLowerCase().trim();

                if (paramItem_lower_trim.startsWith("model_")) {
                    String mModelRaw = paramItem_lower_trim.replace("model_", "").trim();
                    mCategoryModel = replaceWordToExist(mModelRaw);
                }

                if (paramItem_lower_trim.startsWith("proxy_true")) {

                    isProxy = true;
                }

                if (paramItem_lower_trim.startsWith("pagestep_")) {
                    String mPageStepStr = paramItem_lower_trim.replace("pagestep_", "").trim();
                    if (isNumeric(mPageStepStr)) {
                        mNextPageStep = Integer.parseInt(mPageStepStr);
                    }
                }

                if (paramItem_lower_trim.startsWith("beginpage_")) {
                    String mBeginPageStr = paramItem_lower_trim.replace("beginpage_", "").trim();
                    if (isNumeric(mBeginPageStr)) {
                        beginPageIndex = Integer.parseInt(mBeginPageStr);
                    }
                }

                if (paramItem_lower_trim.startsWith("endpage_")) {
                    String mEndPageStr = paramItem_lower_trim.replace("endpage_", "").trim();
                    if (isNumeric(mEndPageStr)) {
                        endPageIndex = Integer.parseInt(mEndPageStr);
                    }
                }

                if (paramItem_lower_trim.startsWith("sleeptime_")) {
                    String mSleepTimeStr = paramItem_lower_trim.replace("sleeptime_", "").trim();
                    if (isNumeric(mSleepTimeStr)) {
                        mSleepInterval = Integer.parseInt(mSleepTimeStr);
                    }
                }

                if (paramItem_lower_trim.startsWith("hreftag_")) {
                    String mHrefRaw = paramItem_lower_trim.replace("hreftag_", "").trim();
                    mHrefTag = replaceWordToExist(mHrefRaw);
                }

                if (paramItem_lower_trim.startsWith("imagetag_")) {
                    String mImageTagRaw = paramItem_lower_trim.replace("imagetag_", "").trim();
                    mImageTag = replaceWordToExist(mImageTagRaw);
                }

            }

            ImageDownloadDir = new File(
                    curDirPath + File.separator + "Rule" + rule_index + "_Download_" + getTimeStamp());

            if (!ImageDownloadDir.exists()) {
                ImageDownloadDir.mkdirs();
            }

            File ChromeDriverFile = new File(zbinPath + File.separator + "G2_chromedriver_v91.exe");

            System.setProperty("webdriver.chrome.driver", ChromeDriverFile.getAbsolutePath());

            ChromeOptions CUR_CHROME_OPTIONS = new ChromeOptions();
            // 驱动位置
            CUR_CHROME_OPTIONS.addArguments("--start-fullscreen");

            CUR_CHROME_OPTIONS.setExperimentalOption("excludeSwitches", Collections.singletonList("enable-automation"));

            mChromeDriver = new ChromeDriver(CUR_CHROME_OPTIONS);

//			mCategoryModel = mCategoryModel.replace("{page}", beginPageIndex+"");

//			String mCategoryMainUrl ;  // item 页面是使用相对的路径  没有出现 绝对路径  所以得 保存 这个 主路径
//			String httpXpre ;  //  http://     或者  https://(默认)

            System.out.println(" mCategoryModel = " + mCategoryModel);
            if (mCategoryModel.contains("http://")) {

                httpXpre = "http://";
            }

            String clearHttpModel = mCategoryModel.replace("https://", "").replace("http://", "").trim();

            if (clearHttpModel.contains("/")) {
                mCategoryMainUrl = clearHttpModel.substring(0, clearHttpModel.lastIndexOf("/"));
            }

            System.out.println(" ImageDownloadDir = " + ImageDownloadDir);
            System.out.println(" httpXpre = " + httpXpre);
            System.out.println(" mCategoryMainUrl = " + mCategoryMainUrl);

            System.out.println(" beginPageIndex = " + beginPageIndex);
            System.out.println(" mHrefTag = " + mHrefTag);

            System.out.println(" mImageTag = " + mImageTag);

            System.out.println(" beginPageIndex = " + beginPageIndex);

            System.out.println(" mNextPageStep = " + mNextPageStep);

            System.out.println(" endPageIndex = " + endPageIndex);

            System.out.println(" mSleepInterval = " + mSleepInterval);
            System.out.println(" isProxy = " + isProxy);

            initModelCategoryPageList(mCategoryModel, beginPageIndex, mNextPageStep, endPageIndex);

            return super.initParamsWithInputList(inputParamList) && Flag;
        }

        // model_https://tieba.baidu.com/f?kw#%E6%9D%8E%E6%AF%85@ie#utf-8&pn#{page}
        // beginpage_1 endpage_1000 pagestep_50 hreftag_https://tieba.baidu.com/p/
        // imagetag_ proxy_true sleeptime_10

        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_" + rule_index + "   //   给定一个页面{page}模板 =转为# &转为@  传递到代码进行图片的自动搜索下载功能  \n"

                    + Cur_Bat_Name + " #_" + rule_index
                    + "  model_https://www.52pojie.cn/forum-4-{page}.html  beginpage_1  endpage_94 pagestep_1  hreftag_thread  imagetag_attach.52pojie sleeptime_10  proxy_true    ###// 爬取{page}网页-52破解  \n"

                    + Cur_Bat_Name + " #_" + rule_index
                    + "  model_https://tieba.baidu.com/f?kw#%E6%9D%8E%E6%AF%85@ie#utf-8@pn#{page}   beginpage_0  endpage_1000 pagestep_50  hreftag_p   imagetag_    proxy_true  sleeptime_10   ###// 爬取{page}网页-百度贴吧  \n"

                    ;
        }

        void initModelCategoryPageList(String modelUrl, int beginIndex, int pageStep, int engIndex) {

            String rawModelUrl = new String(modelUrl);

            int curStep = beginIndex;
            for (int i = beginIndex; i <= engIndex; i++) {
                String mModelPageStr = new String(modelUrl);

                String realPage = mModelPageStr.replace("{page}", curStep + "");
                curStep += pageStep;

                mDynamicPageUrlList.add(realPage);
            }

            for (int i = 0; i < mDynamicPageUrlList.size(); i++) {
                String pageTip = mDynamicPageUrlList.get(i);
                System.out.println("realPage[" + (i + 1) + "] = " + pageTip);

            }

        }

        void itemPageOperation(String mPagehtmlCode, String mainUrl, ArrayList<String> mMatchHrefTagInPageList) {

            org.jsoup.nodes.Document curDocument = Jsoup.parse(mPagehtmlCode);

            String rawHtmlStr = curDocument.html();
            ArrayList<String> mAllHrefInPageList = new ArrayList<String>(); // 所有的 href

            Elements mElements = curDocument.getElementsByTag("a");

//			Elements  mElements =  curDocument.select("a[href]");
// a class="bm_h" href="javascript:;" rel="forum.php?mod=forumdisplay&fid=2&page=3" curpage="2" id="autopbn" totalpage="204" picstyle="0" forumdefstyle="">下一页 &raquo;</a>
// <a href="forum-2-3.html" class="nxt">下一页</a>

            if (mElements != null && mElements.size() > 0) {

                System.out.println("a[href] mElements.size()  = " + mElements.size());
                Iterator<org.jsoup.nodes.Element> nextpage_element_iterator = mElements.iterator();
                while (nextpage_element_iterator.hasNext()) {
                    org.jsoup.nodes.Element curElement = nextpage_element_iterator.next();
                    String innerHtml = curElement.html();
                    String href = curElement.attr("href");
                    System.out.println("nexttip_innerHtml = " + innerHtml + "   href[" + href + "]");
                    mAllHrefInPageList.add(href);

                    // 判断这个 Href 是否符合 hreftag
                    if (href.startsWith(mHrefTag)) {

                        if (!mMatchHrefTagInPageList.contains(httpXpre + mainUrl + "/" + href)) {
                            mMatchHrefTagInPageList.add(httpXpre + mainUrl + "/" + href);
                        }

                    }

                    /*
                     * if (isInnerHtmlContainNextTip(innerHtml, nextUrlTipList)) {
                     *
                     * if (href == null || "".equals(href.trim()) || href.contains("javascript")) {
                     * continue; }
                     *
                     * if (!href.startsWith("http")) { String fixed_href = rootUrl_A.mRootUrl + "/"
                     * + href; fixed_href = fixed_href.replace("//", "/"); if
                     * (!categoryUrl_B.mCategoryPageUrlList.contains(fixed_href)) {
                     * categoryUrl_B.nextPageUrl = fixed_href;
                     * categoryUrl_B.mCategoryPageUrlList.add(fixed_href);
                     * System.out.println("a[href]_Next_Tip  nextPageUrl=[" + fixed_href +
                     * "]  innerHtml = " + innerHtml + "   href[" + href + "]");
                     *
                     * return; }
                     *
                     * }
                     *
                     * }
                     */

                }

            }

        }

        void HrefDetailHtmlCodeOperation(String mHrefHtmlCode, ArrayList<String> mImageSrcInPageList) {
            // 获取 全部的 <img

            org.jsoup.nodes.Document hrefDocument = Jsoup.parse(mHrefHtmlCode);

            String rawHrefHtmlStr = hrefDocument.html();

            Elements mImgElements = hrefDocument.getElementsByTag("img");

            if (mImgElements != null && mImgElements.size() > 0) {

                System.out.println("a[href] mElements.size()  = " + mImgElements.size());
                Iterator<org.jsoup.nodes.Element> nextpage_element_iterator = mImgElements.iterator();
                while (nextpage_element_iterator.hasNext()) {
                    org.jsoup.nodes.Element curElement = nextpage_element_iterator.next();
                    String innerHtml = curElement.html();
                    String src = curElement.attr("src");
                    System.out.println("nexttip_innerHtml = " + innerHtml + "   src[" + src + "]");

                    // 判断这个 Href 是否符合 hreftag
                    if (mImageTag == null || "".equals(mImageTag)) {
                        if (src.startsWith("http")
                                && (src.toLowerCase().endsWith(".gif") || src.toLowerCase().endsWith(".webp")
                                || src.toLowerCase().endsWith(".jpg") || src.toLowerCase().endsWith(".png")

                        )) {

                            if (!mImageSrcInPageList.contains(src)) {
                                mImageSrcInPageList.add(src);
                            }

                        }

                    } else {
                        if (src.contains(mImageTag)) {

                            if (src.startsWith("http")
                                    && (src.toLowerCase().endsWith(".gif") || src.toLowerCase().endsWith(".webp")
                                    || src.toLowerCase().endsWith(".jpg") || src.toLowerCase().endsWith(".png")

                            )) {

                                if (!mImageSrcInPageList.contains(src)) {
                                    mImageSrcInPageList.add(src);
                                }

                            }

                        }

                    }

                }

            }

        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            for (int i = 0; i < mDynamicPageUrlList.size(); i++) {
                String pageItemUrl = mDynamicPageUrlList.get(i);
                System.out.println("pageItemUrl[" + (i + 1) + "][" + mDynamicPageUrlList.size() + "] = " + pageItemUrl);
                ArrayList<String> mPageItemHrefList = new ArrayList<String>();

                // 获取到 这个网页的 源码

                String pageHtmlCode = getMainPageHtmlCode(pageItemUrl);

                if (pageHtmlCode == null || pageHtmlCode.length() < 10) {

                    System.out.println(" 获取 PageHtmlCode 失败 --> " + "pageItemUrl[" + (i + 1) + "] = " + pageItemUrl);
                    continue;
                }

                itemPageOperation(pageHtmlCode, mCategoryMainUrl, mPageItemHrefList);

                if (mPageItemHrefList.size() > 0) {

                    for (int j = 0; j < mPageItemHrefList.size(); j++) {
                        String hrefUrl = mPageItemHrefList.get(j);
                        System.out.println("pageItemUrl[" + (i + 1) + "][" + mDynamicPageUrlList.size() + "] = "
                                + pageItemUrl + "  hrefItemUrl[" + (j + 1) + "][" + mPageItemHrefList.size() + "] = "
                                + hrefUrl);

                    }

                    for (int j = 0; j < mPageItemHrefList.size(); j++) {
                        String hrefUrl = mPageItemHrefList.get(j);

                        System.out.println("Down pageItemUrl[" + (i + 1) + "] = " + pageItemUrl + "  hrefItemUrl["
                                + (j + 1) + "][" + j + "] = " + hrefUrl);

                        String mHrefHtmlCode = getMainPageHtmlCode(hrefUrl);

                        if (mHrefHtmlCode == null || mHrefHtmlCode.length() < 10) {

                            System.out.println(" 获取 HrefHtmlCode 失败 --> " + "pageItemUrl[" + (i + 1) + "] = "
                                    + pageItemUrl + "  hrefItemUrl[" + (j + 1) + "][" + j + "] = " + hrefUrl);
                            continue;
                        }

                        ArrayList<String> mImageSrcInHrefPageList = new ArrayList<String>();

                        HrefDetailHtmlCodeOperation(mHrefHtmlCode, mImageSrcInHrefPageList);

                        if (mImageSrcInHrefPageList.size() > 0) {

                            for (int k = 0; k < mImageSrcInHrefPageList.size(); k++) {
                                String imgSrc = mImageSrcInHrefPageList.get(k);
                                String srcType = getFileTypeWithPoint(imgSrc);
                                System.out.println("pageItemUrl[" + (i + 1) + "][" + mDynamicPageUrlList.size() + "] = "
                                        + pageItemUrl + "  hrefItemUrl[" + (j + 1) + "][" + mPageItemHrefList.size()
                                        + "] = " + hrefUrl + " ImgSrc[" + k + "][" + mImageSrcInHrefPageList.size()
                                        + "]=" + imgSrc);

                                File curFileImag = new File(ImageDownloadDir.getAbsolutePath() + File.separator
                                        + getTimeStampLong() + srcType);

                                TryDownLoadImage(imgSrc, curFileImag, 3);

                            }

                        }

                    }

                }

            }

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        public void TryDownLoadImage(String httpUrl, File localFile, int repeatTimes) {

            int byteRead;
            try {

                if (localFile.exists()) {
                    localFile.createNewFile();
                }
                String fileAddress = localFile.getAbsolutePath();
//			String fileAddress = mDownloadedMonthDir.getAbsolutePath() + File.separator
//					+ (source == null || "".equals(source) ? "" : source + "_") + (fileNameNoPoint.replace(" ", ""))
//					+ "_" + index + "_" + getTimeStamp() + ".mp4";

                URLConnection conn = null;
                URL url = new URL(httpUrl);
                if (isProxy) {
                    InetSocketAddress address = new InetSocketAddress("127.0.0.1", 7078);
                    Proxy proxy = new Proxy(Proxy.Type.HTTP, address); // http代理协议类型
                    conn = url.openConnection(proxy);
                } else {
                    conn = url.openConnection();
                }

                System.out.println("下载操作:[ " + httpUrl + " ]   \n fileAddress:" + fileAddress + " isProxy=" + isProxy);

                // 输入流
                InputStream inStream = conn.getInputStream();
                // 封装一个保存文件的路径对象
                File fileSavePath = new File(fileAddress);
                // 注:如果保存文件夹不存在,那么则创建该文件夹
//				File fileParent = fileSavePath.getParentFile();
//				if (!fileParent.exists()) {
//					fileParent.mkdirs();
//				}
                // 写入文件
                FileOutputStream fs = new FileOutputStream(fileSavePath);
                byte[] buffer = new byte[1024];
                while ((byteRead = inStream.read(buffer)) != -1) {
                    fs.write(buffer, 0, byteRead);
                }
                inStream.close();
                fs.close();
                System.out.println("\n-----url[ " + httpUrl + " ]下载完成-----\n" + fileSavePath.getAbsolutePath());

            } catch (FileNotFoundException e) {
                System.out.println("ZFileNotFoundException==" + e.getMessage());
            } catch (IOException e) {
                System.out.println("ZIOException:" + e.getMessage());
                if (repeatTimes <= 3) {
                    TryDownLoadImage(httpUrl, localFile, repeatTimes + 1); // 再次执行 下载操作

                }
            }
        }

    }

    // voice_fafaefafea 读取 voice 的 内容
    class Read_Speak_Word_Rule_48 extends Basic_Rule {
        String mVoice_Utf8;

        Read_Speak_Word_Rule_48() {
            super("#", 48, 4);
            mVoice_Utf8 = "HelloWorld_Zukgit";
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            String mVbsFilePath = zbinPath + File.separator + "B3_voice.vbs";
            String commadStr = "CreateObject(\"SAPI.SpVoice\").Speak \"" + mVoice_Utf8 + "\"";

            try {
                String mANSIStr = new String(commadStr.getBytes("UTF-8"), "GB2312");
            } catch (UnsupportedEncodingException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

            File voice_file = new File(mVbsFilePath);

            ANSI_writeContentToFile(voice_file, commadStr);
//		        UTF8File_To_ANSIFile(voice_file);

//		        RuntimeUtil.exec("Wscript.exe  /x " + voice_file.getAbsolutePath());
            execCMD(voice_file.getAbsolutePath());
            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            boolean Flag = true;

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem = inputParamList.get(i);
                String paramItem_lower_trim = paramItem.toLowerCase().trim();

                if (paramItem_lower_trim.startsWith("voice_")) {
                    mVoice_Utf8 = paramItem_lower_trim.replace("voice_", "").trim();
                }

            }

            return super.initParamsWithInputList(inputParamList) && Flag;
        }

        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_" + rule_index + "   // 读取给定的voice 发出声音  \n"

                    + Cur_Bat_Name + " #_" + rule_index + "  voice_12345ABCDE   // 读取给定的voice 发出声音  \n"

                    ;
        }

    }

    // 给定一个 西瓜视频 主页 下载 该页面内的所有视频文件
    class Download_XiGua_HomeVideo_Rule_47 extends Basic_Rule {
        ArrayList<String> allHrefList; // 所有引用的链接
        ArrayList<String> allNumberHrefList; // 所有只有数字的引用链接( 西瓜视频 里 特有的 )
        ArrayList<String> allNumberHttpLinkList; // https://www.ixigua.com/+数值href的集合
        File mDownloadedMonthDir;
        File ChromeDriverFile;
        // 必须以 http 开头
        String searchHttpUrl; // 从输入传入的 需要得到 的 http 源码的 网页的地址
        ChromeDriver mChromeDriver;
        String curPositionHtmlCodeStr; // 每次得到的 html代码的值 用于突然用户终止程序时 使用

        Download_XiGua_HomeVideo_Rule_47() {
            super("#", 47, 4);
            allHrefList = new ArrayList<String>();
            allNumberHrefList = new ArrayList<String>();
            allNumberHttpLinkList = new ArrayList<String>();
            mDownloadedMonthDir = curDirFile;
            if (mDownloadedMonthDir == null) {
                mDownloadedMonthDir = new File(curDirPath);
            }
        }

        String tryDownLoadXiGuaVideo(ArrayList<String> linkList) {
            StringBuilder downloadLogSB = new StringBuilder();

            if (linkList == null || linkList.size() == 0) {

                downloadLogSB.append("  当前 下载链接 集合 为 空 ");
                return downloadLogSB.toString();

            }

            for (int i = 0; i < linkList.size(); i++) {
                String linkItem = linkList.get(i);

                // zukgit 下载 方式
                XiGua_TouTiao_ParseUrl(i, linkItem);
                downloadLogSB.append("下载 link[" + i + "] " + linkItem + "  执行Over!");

            }

            return downloadLogSB.toString();

        }

        void XiGua_TouTiao_ParseUrl(int index, String url) {
            // String
            // url="https://m.toutiaoimg.cn/group/6966235416110301696/?app=news_article_lite&timestamp=1626072237&group_id=6966235416110301696&share_token=0f88ebb4-c474-4671-9d9b-4b7e76004e38";

            org.jsoup.nodes.Document mainHtml;
            String jiemi_base64_url = null;
            String base64_jiami_url = null;
            String NoMainUrl_VideoTag_url = null; // 对于 没有 main_url 但 有 <video src="http" //这样的页面的处理

            // backup_url_1 有时 main_url 会 解析错误 所以 会导致 下载不了视频 此时 需要用 备用视频下载
            String jiemi_base64_bankurl = null;
            String base64_jiami_bankurl = null;

            String main_url_keyword = "\"main_url\":\"";
            String bankup_url_keyword = "\"backup_url_1\":\"";

            try {
                mainHtml = Jsoup.parse(getXiGua_MainPageSource(url));

                if (mainHtml != null && mainHtml.toString().contains("mediatype=\"video\"")
                        && mainHtml.toString().contains("src=\"http") && mainHtml.toString().contains("<video")) {
                    String mainHtmlStr = mainHtml.toString();
                    // <video class="" tabindex="2" mediatype="video"
                    // src="http://v3-default.ixigua.com/c
                    String begin_video_tag = mainHtmlStr.substring(mainHtmlStr.indexOf("<video"));
                    String src_begin_tag = begin_video_tag.substring(begin_video_tag.indexOf("src=\"http"));
                    String http_begin_tag = src_begin_tag.replace("src=\"http", "");
                    String target_video_url = "http" + http_begin_tag.substring(0, http_begin_tag.indexOf("\""));
                    NoMainUrl_VideoTag_url = target_video_url;
                    System.out.println("当前页面源码有 Video Tag 标签 ");

                    System.out.println();
                    System.out.println("url = " + url);
                    System.out.println("NoMainUrl_VideoTag_url = " + NoMainUrl_VideoTag_url);
                    System.out.println("===============mainHtml Begin============ ");

                    System.out.println(mainHtml);

                    System.out.println("===============mainHtml Endxx============ ");

                    System.out.println();

                } else {
                    System.out.println();
                    System.out.println("url = " + url);
                    System.out.println("===============mainHtml Begin============ ");

                    System.out.println(mainHtml);

                    System.out.println("===============mainHtml Endxx============ ");

                    System.out.println();
                }
                if (mainHtml != null) {
                    String MainHtmlStr = mainHtml.toString();

                    // 把 "main_url":" 去除 那么 起点 就是 我们 要找的 url
                    // "backup_url_1":"

                    base64_jiami_url = calculXiGuaMainUri(url, MainHtmlStr, main_url_keyword);
                    base64_jiami_bankurl = calculXiGuaMainUri(url, MainHtmlStr, bankup_url_keyword);
                    if (base64_jiami_url == null) {

                        if (NoMainUrl_VideoTag_url != null) {
                            System.out.println(
                                    "解析出的 base64_jiami_main_url 为空  但存在 video_tag_url = " + NoMainUrl_VideoTag_url);
                            System.out.println(" 尝试下载  video_tag_url : " + NoMainUrl_VideoTag_url);

                            downRawVideo_WithUrl(index, NoMainUrl_VideoTag_url, "", "TouTiao");
                        } else {

                            System.out.println(
                                    "解析出的 base64_jiami_main_url 为空  NoMainUrl_VideoTag_url 为空 无法下载视频到本地   base64_jiami_url="
                                            + base64_jiami_url);

                        }

                    } else {
                        System.out.println("解析出的 base64_jiami_url=[" + base64_jiami_url + "]  尝试解密base64");

                        jiemi_base64_url = jiemi_decryptBASE64(base64_jiami_url);
                        System.out.println();

                        System.out.println("解析出的地址  jiemi_base64_url = [" + jiemi_base64_url + "]");

                        if (jiemi_base64_url.startsWith("http")) {
                            System.out.println("执行 main_url 下载操作!!!    jiemi_base64_url=[" + jiemi_base64_url + "]");
                            System.out.println("XXAAA");
                            downRawVideo_WithUrl(index, jiemi_base64_url, "", "TouTiao");

                            System.out.println("XXBB");
                        } else {
                            System.out.println("解密出的地址不是以  http 开头  无法下载!!!");
                        }

                    }

                } else {
                    System.out.println(
                            "当前读取到的 网页源码为空 ,   可能 G2_chromedriver版本 和 当前浏览器版本不一致!!   \n chromedriver.exe 下载地址: http://npm.taobao.org/mirrors/chromedriver/");
                }

            } catch (Exception e) {
                e.fillInStackTrace();
                // TODO: handle exception
                System.out.println("异常 Exception.getMessage = " + e.getMessage());

                System.out.println("异常 Exception = " + e);

                System.out.println("解密Base64出意外Exception 尝试使用 bankup_url   \njiemi_base64_url=[" + jiemi_base64_url
                        + "]\nbase64_jiami_url=[" + base64_jiami_url + "]    \n base64_jiami_bankurl=["
                        + base64_jiami_bankurl + "]");

                try {
                    if (base64_jiami_bankurl != null) {

                        jiemi_base64_bankurl = jiemi_decryptBASE64(base64_jiami_bankurl);
                    }

                    if (jiemi_base64_bankurl != null && jiemi_base64_bankurl.startsWith("http")) {
                        System.out.println(
                                "执行 bankup_url_1 下载操作!!!    jiemi_base64_bankurl=[" + jiemi_base64_bankurl + "]");
                        downRawVideo_WithUrl(index, jiemi_base64_bankurl, "", "TouTiao");

                    }

                } catch (Exception e1) {

                    System.out.println("尼玛 不干了  备用的 bankup_url 也解析失败!! 下载失败!! jiemi_base64_bankurl =["
                            + jiemi_base64_bankurl + "]");
                    // TODO: handle exception
                }

            }

        }

        /**
         * 获取首页内容
         *
         * @return 首页内容
         * @throws InterruptedException 睡眠中断异常
         */
        String getXiGua_MainPageSource(String url) {

            ChromeOptions CUR_CHROME_OPTIONS = new ChromeOptions();
            // 驱动位置
            CUR_CHROME_OPTIONS.addArguments("--start-fullscreen");

//			CUR_CHROME_OPTIONS.addArguments("Accept=text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8");
//			CUR_CHROME_OPTIONS.addArguments("Accept-Encoding=gzip, deflate, sdch");
//			CUR_CHROME_OPTIONS.addArguments("Accept-Language=zh-CN,zh;q=0.8");
//			CUR_CHROME_OPTIONS.addArguments("Connection=keep-alive");
//			CUR_CHROME_OPTIONS.addArguments("Host=activityunion-marketing.meituan.com");
//			CUR_CHROME_OPTIONS.addArguments("Upgrade-Insecure-Requests=1");
//			CUR_CHROME_OPTIONS.addArguments("User-Agent=Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.3 (KHTML, like Gecko) Version/8.0 Mobile/12A4345d Safari/600.1.4");

            System.setProperty("webdriver.chrome.driver", ChromeDriverFile.getAbsolutePath());
            // 避免被浏览器检测识别
            CUR_CHROME_OPTIONS.setExperimentalOption("excludeSwitches", Collections.singletonList("enable-automation"));

            ChromeDriver driver = new ChromeDriver(CUR_CHROME_OPTIONS);
            int loop_index = 0;
            try {

                driver.get(url);
                long waitTime = Double.valueOf(Math.max(3, Math.random() * 5) * 1000).longValue();
                TimeUnit.MILLISECONDS.sleep(waitTime);
                long timeout = 20_000;
                // 循环下拉，直到全部加载完成或者超时
                do {
                    new Actions(driver).sendKeys(Keys.END).perform();
                    TimeUnit.MILLISECONDS.sleep(waitTime);
                    if (loop_index == 1) {
                        System.out.println("!! 触发点击事件  起始 标识 AAA !!");
                        new Actions(driver).sendKeys(Keys.HOME).perform();
                        TimeUnit.MILLISECONDS.sleep(1500);
                        try {
                            driver.findElement(By.className("xgplayer-start")).click();
                            TimeUnit.MILLISECONDS.sleep(2000);
                        } catch (Exception e) {
                            System.out.println("尝试点击播放按钮失败!! ");

                            System.out.println("click异常:");
                            System.out.println(e.fillInStackTrace());

                        }

                    }

                    TimeUnit.MILLISECONDS.sleep(waitTime);
                    timeout -= waitTime;
                    loop_index++;
                } while (!driver.getPageSource().contains("已经到底部，没有新的内容啦") && timeout > 0);
                System.out.println("已经到底部，没有新的内容啦");
                return driver.getPageSource();
            } catch (Exception e) {
                // TODO: handle exception
                System.out.println("获取网页源码的时候出错  url = " + url);
                e.printStackTrace();

            } finally {
                driver.close();

            }
            return null;
        }

        // 视频的保存 目录 不能是 当前文件 否则 就会执行 同步操作 影响网速
        @SuppressWarnings("unchecked")
        public void downRawVideo_WithUrl(int index, String httpUrl, String fileNameNoPoint, String source) {
//	        String fileAddress = videoSavePath+"/"+source+"/"+title+".mp4";
            if (mDownloadedMonthDir == null) {
                mDownloadedMonthDir = new File(curDirPath);
            }
            String fileAddress = mDownloadedMonthDir.getAbsolutePath() + File.separator
                    + (source == null || "".equals(source) ? "" : source + "_") + (fileNameNoPoint.replace(" ", ""))
                    + "_" + index + "_" + getTimeStamp() + ".mp4";

            System.out.println("index = " + index);
            System.out.println("fileAddress = " + fileAddress);

            System.out.println("httpUrl = " + httpUrl);
            System.out.println("fileNameNoPoint = " + fileNameNoPoint);
            System.out.println("source = " + source);

            int byteRead;
            try {
                URL url = new URL(httpUrl);
                // 获取链接
                URLConnection conn = url.openConnection();
                // 输入流
                InputStream inStream = conn.getInputStream();
                // 封装一个保存文件的路径对象
                File fileSavePath = new File(fileAddress);
                // 注:如果保存文件夹不存在,那么则创建该文件夹
                File fileParent = fileSavePath.getParentFile();
                if (!fileParent.exists()) {
                    fileParent.mkdirs();
                }
                // 写入文件
                FileOutputStream fs = new FileOutputStream(fileSavePath);
                byte[] buffer = new byte[1024];
                while ((byteRead = inStream.read(buffer)) != -1) {
                    fs.write(buffer, 0, byteRead);
                }
                inStream.close();
                fs.close();
                System.out.println("\n-----视频保存路径-----\n" + fileSavePath.getAbsolutePath());
                System.out.println("\nzzfile_3.bat " + fileSavePath.getParentFile().getAbsolutePath());

                System.out.println("由于 isMDName=true  视频文件将以 MD5 属性文件名称进行命名!!! ");

                // 获取文件的 md值 并重命名为 mdxxxx.mp4
                String mdName = getMD5Three(fileSavePath.getAbsolutePath());
                String new_Md_Name = mdName + ".mp4";
                tryReName(fileSavePath, new_Md_Name);
                // 把下载的 mp4 文件 名称 转为 md值

            } catch (FileNotFoundException e) {
                System.out.println(e.getMessage());
            } catch (IOException e) {
                System.out.println(e.getMessage());
            }
        }

        // 把 "main_url":" 去除 那么 起点 就是 我们 要找的 url
        // "backup_url_1":"

        public String calculXiGuaMainUri(String url, String mainHtmlStr, String beginKeyStr) {

            String jiami_main_uri = null;

            if (mainHtmlStr == null) {
                System.out.println("当前 url=" + url + "  获取到的网页源代码 htmlcode 为空!! ");
                return jiami_main_uri;
            }

            if (!mainHtmlStr.contains("\"vtype\":\"mp4\"")) {
                System.out.println("当前 url=" + url + "  获取到的网页源代码 htmlcode   不包含关键字 \"vtype\":\"mp4\" 无法解析视频!! ");
                return jiami_main_uri;
            }

            // "definition":"1080p","quality":"normal","vtype":"mp4"
            // "definition":"720p","quality":"normal","vtype":"mp4"
            // "definition":"480p","quality":"normal","vtype":"mp4"
            // "definition":"360p","quality":"normal","vtype":"mp4"

            String mp4_1080p_keystr = "\"definition\":\"1080p\",\"quality\":\"normal\",\"vtype\":\"mp4\"";
            String mp4_720p_keystr = "\"definition\":\"720p\",\"quality\":\"normal\",\"vtype\":\"mp4\"";
            String mp4_480p_keystr = "\"definition\":\"480p\",\"quality\":\"normal\",\"vtype\":\"mp4\"";
            String mp4_360p_keystr = "\"definition\":\"360p\",\"quality\":\"normal\",\"vtype\":\"mp4\"";

            String mKeyMp4Tag = null; // 如果有 1080p 那么选择1080p 如果只有720p 那么就是720p 选分辨率最高那个

            if (mainHtmlStr.contains(mp4_1080p_keystr)) {
                mKeyMp4Tag = mp4_1080p_keystr;
            } else if (mainHtmlStr.contains(mp4_720p_keystr)) {
                mKeyMp4Tag = mp4_720p_keystr;
            } else if (mainHtmlStr.contains(mp4_480p_keystr)) {
                mKeyMp4Tag = mp4_480p_keystr;
            } else if (mainHtmlStr.contains(mp4_360p_keystr)) {
                mKeyMp4Tag = mp4_360p_keystr;
            }

            if (mKeyMp4Tag == null) {

                System.out.println(
                        "当前 url=" + url + "  获取到的网页源代码 htmlcode  查不到 1080p 720p 480p  360p 视频的任意一个  无法解析视频!! ");

                return jiami_main_uri;
            }

            // 把 要 解析的 分辨率 搞到 第一行位置
            // "definition":"1080p","quality":"normal","vtype":"mp4","vwidth":1920,"vheight":1080,"bitrate":2629630,"fps":25,"codec_type":"h264","size":77367333,"main_url":"...,"backup_url_1":...
            String mp4tag_begin_str = mainHtmlStr.substring(mainHtmlStr.indexOf(mKeyMp4Tag));

            if (mp4tag_begin_str == null || !mp4tag_begin_str.contains("\"main_url\":\"")) {
                System.out.println("当前 url=" + url + "  获取到的网页源代码 htmlcode  找到 1080p 720p 480p  360p   mKeyMp4Tag = "
                        + mKeyMp4Tag + "  但解析出 main_url 失败!!");

                return jiami_main_uri;
            }

            if (mp4tag_begin_str == null || !mp4tag_begin_str.contains("\"backup_url_1\":\"")) {
                System.out.println("当前 url=" + url + "  获取到的网页源代码 htmlcode  找到 1080p 720p 480p  360p   mKeyMp4Tag = "
                        + mKeyMp4Tag + "  但解析出  backup_url_1;	 失败!!");

                System.out.println();
                System.out.println();
                System.out.println("mp4tag_begin_str = ");
                System.out.println(mp4tag_begin_str);

                System.out.println();
                System.out.println();

            }

            // "main_url":"...,"backup_url_1":...
            String main_url_begin = mp4tag_begin_str.substring(mp4tag_begin_str.indexOf(beginKeyStr));

            // 把 "main_url":" 去除 那么 起点 就是 我们 要找的 url
            // "backup_url_1":"
            String main_url_raw = main_url_begin.replace(beginKeyStr, "");

            // 第一个引号的位置 就是 结束 标示 main_url_fixed 就是我们 要找的 url_raw
            String main_url_fixed = main_url_raw.substring(0, main_url_raw.indexOf("\""));

            System.out.println("当前寻找到的 base64_url = " + main_url_fixed);

            return main_url_fixed;

        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // TODO Auto-generated method stub

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem = inputParamList.get(i);
                String paramItem_lower_trim = paramItem.toLowerCase().trim();
                System.out.println("paramItem[" + i + "] = " + paramItem_lower_trim);
                if (paramItem_lower_trim.startsWith("http")) {
                    searchHttpUrl = paramItem_lower_trim;
                }

            }

            if (searchHttpUrl == null) {
                System.out.println("当前输入的网页为空  请检查输入!!!");
                return false;
            }

            ChromeDriverFile = new File(zbinPath + File.separator + "G2_chromedriver_v91.exe");

            System.setProperty("webdriver.chrome.driver", ChromeDriverFile.getAbsolutePath());

            ChromeOptions CUR_CHROME_OPTIONS = new ChromeOptions();
            // 驱动位置
            CUR_CHROME_OPTIONS.addArguments("--start-fullscreen");

            CUR_CHROME_OPTIONS.setExperimentalOption("excludeSwitches", Collections.singletonList("enable-automation"));

            mChromeDriver = new ChromeDriver(CUR_CHROME_OPTIONS);

            return super.initParamsWithInputList(inputParamList);
        }

        void registerShutDownLister() {
            Runtime.getRuntime().addShutdownHook(new Thread() {
                public void run() {
                    try {
                        Thread.sleep(200);
                        System.out.println("════════ 监听到 Ctr+Z stop进程操作 将执行保存当前页面位置代码的操作 ════════");

                        writeContentToFile(G2_Temp_Text_File, curPositionHtmlCodeStr);
                        NotePadOpenTargetFile(G2_Temp_Text_File.getAbsolutePath());

                        System.out.println("获得【" + searchHttpUrl + "】 MainPage HtmlCode 突然终止 部分成功 !! ");
                        System.out.println("════════" + "════════");
                        // some cleaning up code...

                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            });

        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            // TODO Auto-generated method stub

            registerShutDownLister();
            if (searchHttpUrl.startsWith("https://profile.zjurl.cn/rogue/ugc/profile")
                    && searchHttpUrl.contains("user_id")) {
                String user_id_raw = searchHttpUrl.substring(searchHttpUrl.indexOf("user_id="));
                String user_id = user_id_raw.substring(0, user_id_raw.indexOf("&")).replace("&", "").replace("user_id=",
                        "");
                // https://www.ixigua.com/home/3346556174218692
                System.out.println(" profile searchHttpUrl=" + searchHttpUrl);
                System.out.println(" profile  user_id_raw=" + user_id_raw);
                System.out.println(" profile  user_id=" + user_id);
                searchHttpUrl = "https://www.ixigua.com/home/" + user_id.trim();
            }

            String httpPageCode = BrowserOperation_WithRootUrl(searchHttpUrl);

            // 对页面的链接 href 进行分析
            String mHrefLog = TryHrefAnalysis(httpPageCode);

            if (httpPageCode != null) {

                curPositionHtmlCodeStr = httpPageCode + "\n" + "════════════════════ Href-Log ════════════════════\n"
                        + mHrefLog;

                writeContentToFile(G2_Temp_Text_File,
                        httpPageCode + "\n" + "════════════════════ Href-Log ════════════════════\n" + mHrefLog);
                NotePadOpenTargetFile(G2_Temp_Text_File.getAbsolutePath());
                System.out.println("获得【" + searchHttpUrl + "】 MainPage HtmlCode 成功!! ");
            } else {
                System.out.println("获得【" + searchHttpUrl + "】 MainPage HtmlCode 失败!! ");

            }

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        String TryHrefAnalysis(String mPageHtmlCode) {
            StringBuilder mLogSB = new StringBuilder();

            if (mPageHtmlCode == null || "".equals(mPageHtmlCode)) {

                System.out.println("当前获取到的 页面 代码 为 空  执行失败!  ");
                return "当前获取到的 页面 代码 为 空  执行失败!";
            }

            // 以 href="
            String[] rawHrefArr = mPageHtmlCode.split("href=\"");

            if (rawHrefArr == null) {
                System.out.println("当前获取到的 页面 代码  不包含关键字  rawHrefArr");
                return "当前获取到的 页面 代码  不包含关键字  rawHrefArr";

            }

            for (int i = 0; i < rawHrefArr.length; i++) {
                String rawHrefItem = rawHrefArr[i];
                System.out.println("rawHref[" + i + "] = " + rawHrefItem);
                mLogSB.append("rawHref[" + i + "] = " + rawHrefItem + "\n");
                if (rawHrefItem.contains("\"")) {
                    String realHref = rawHrefItem.substring(0, rawHrefItem.indexOf("\""));
                    allHrefList.add(realHref);

                }
            }

            for (int i = 0; i < allHrefList.size(); i++) {
                String realHref = allHrefList.get(i);

                System.out.println("realHref[" + i + "] = " + realHref);
                mLogSB.append("realHref[" + i + "] = " + realHref + "\n");
                String clearTagHref = realHref.replace("/", "").replace("?logTag=", "").trim();

                if (isNumeric(clearTagHref) && !allNumberHrefList.contains(clearTagHref)) {

                    allNumberHrefList.add(clearTagHref);
                }

            }

            for (int i = 0; i < allNumberHrefList.size(); i++) {

                String realNumHref = allNumberHrefList.get(i);

                System.out.println("realNumHref[" + i + "] = " + realNumHref);
                mLogSB.append("realNumHref[" + i + "] = " + realNumHref + "\n");
                allNumberHttpLinkList.add("https://www.ixigua.com/" + realNumHref.trim());
            }

            String downlodLog = tryDownLoadXiGuaVideo(allNumberHttpLinkList);
            mLogSB.append(downlodLog);

            return mLogSB.toString();

        }

        @Override
        String simpleDesc() {

            // 输入参数有空格 导致 无法直接传递从 shell 传递到 java执行代码 所以这里 注释掉 直接使用 textrule就不存在这样的情况
//			return "\n" + Cur_Bat_Name + " #_" + rule_index+"  https://www.ixigua.com/home/3346556174218692   ###  给定一个 西瓜视频 主页 下载 该页面内的所有视频文件   " +
//		"\n"+	 Cur_Bat_Name + " #_" + rule_index+"  https://profile.zjurl.cn/rogue/ugc/profile/?version_code=851&version_name=80501&user_id=100443303952   ###  给定一个 头条新闻用户主页 下载该页面内的所有视频文件   ";

            return "\n" + Cur_Bat_Name + " #_" + rule_index
                    + "  https://www.ixigua.com/home/3346556174218692   ###  给定一个 西瓜视频 主页 下载 该页面内的所有视频文件   ";

//			https://profile.zjurl.cn/rogue/ugc/profile/?version_code=851&version_name=80501&user_id=100443303952
        }

        String BrowserOperation_WithRootUrl(String mMainUrl) {

            String mainPageHtmlStr = null;
            File ChromeDriverFile = new File(zbinPath + File.separator + "G2_chromedriver_v91.exe");

            System.setProperty("webdriver.chrome.driver", ChromeDriverFile.getAbsolutePath());

            ChromeDriver driver = mChromeDriver;
            int loop_index = 0;
            try {
                long waitTime = 1000;
                long timeout = 60_000; // 15 秒 // 给他 1分钟

                driver.get(mMainUrl);
                String title = driver.getTitle();
                System.out.printf("loop_index[" + loop_index + "] = " + title);

                System.out.printf("A now accesss %s \n", driver.getCurrentUrl());

//				 long waitTime = Double.valueOf(Math.max(3, Math.random() * 5) * 1000).longValue();
                TimeUnit.MILLISECONDS.sleep(waitTime);

                // 循环下拉，直到全部加载完成或者超时
                do {
                    new Actions(driver).sendKeys(Keys.END).perform();
                    TimeUnit.MILLISECONDS.sleep(waitTime);

                    timeout -= waitTime;
                    loop_index++;
                    curPositionHtmlCodeStr = driver.getPageSource();
                } while (!driver.getPageSource().contains("已经到底部，没有新的内容啦") && timeout > 0);
                System.out.println("BrowserOperation_WithRootUrl 已经到底部，没有新的内容啦");
                mainPageHtmlStr = driver.getPageSource();
                curPositionHtmlCodeStr = driver.getPageSource();
            } catch (Exception e) {
                // TODO: handle exception
                System.out.println("获取网页源码的时候出错  mMainUrl = " + mMainUrl);
                e.printStackTrace();

            }

            if (mainPageHtmlStr != null) {

                System.out.println("当前已经得到网页Html代码如下:\n" + mainPageHtmlStr);

            } else {
                System.out.println("rootUrl.mHtmlStr  ==== null ");
            }

            return mainPageHtmlStr;
        }

    }

// 3038年 5 月 3 日

    class ShowJpgTagContent_To_Image_Rule_46 extends Basic_Rule {

        File outJpgFile; // 当前目录的产出目录
        boolean is_jpgharddir; // 目录是否 固定

        boolean is_model_show;
        boolean is_manufacturer_show;
        boolean is_artist_show;
        boolean is_copyright_show;
        boolean is_description_show;
        boolean is_comment_show;

        ShowJpgTagContent_To_Image_Rule_46() {
            super("#", 46, 4);
            is_model_show = false;
            is_manufacturer_show = false;
            is_artist_show = false;
            is_copyright_show = false;
            is_description_show = false;
            is_comment_show = false;
            is_jpgharddir = false;
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // mdname_true // kaoyan_true gaokao_true

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem = inputParamList.get(i);
                String paramItem_lower_trim = paramItem.toLowerCase().trim();

                if ("model_show".equals(paramItem_lower_trim)) {
                    is_model_show = true;
                }

                if ("manufacturer_show".equals(paramItem_lower_trim)) {
                    is_manufacturer_show = true;
                }

                if ("artist_show".equals(paramItem_lower_trim)) {
                    is_artist_show = true;
                }

                if ("copyright_show".equals(paramItem_lower_trim)) {
                    is_copyright_show = true;
                }

                if ("description_show".equals(paramItem_lower_trim)) {
                    is_description_show = true;
                }

                if ("comment_show".equals(paramItem_lower_trim)) {
                    is_comment_show = true;
                }

                if ("harddir_true".equals(paramItem_lower_trim)) {
                    is_jpgharddir = true;
                }

            }

            System.out.println("is_model_show=" + is_model_show + "  is_manufacturer_show=" + is_manufacturer_show
                    + " is_artist_show =" + is_artist_show + "  is_copyright_show=" + is_copyright_show
                    + " is_description_show=" + is_description_show + " is_comment_show=" + is_comment_show);

            // 只要有一个是 true 才能执行
            if (is_comment_show || is_manufacturer_show || is_artist_show || is_copyright_show || is_description_show
                    || is_comment_show) {

                System.out.println("将执行程序生成 携带JPG属性显示在图片中的图片集合  ");

            } else {

                System.out.println(" 输入参数列表必须要有一个参数才能执行 否则没有意义 ");
                return false;

            }

            if (is_jpgharddir) {
                outJpgFile = new File(curDirFile.getAbsolutePath() + File.separator + "jpg_tag_dir");

            } else {
                outJpgFile = new File(curDirFile.getAbsolutePath() + File.separator + "jpg_tag_" + getTimeStamp());

            }

            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_" + rule_index + "    // 把当前的 jpg 和 png 文件转为一个 PDF文件  (不操作 孙文件 孙文件夹 )  \n"
                    + Cur_Bat_Name + "  #_" + rule_index
                    + "  model_show  ### 把当前的 jpg 和 png  并在图片显示 model属性  放到 jpg_tag_timestamp目录   \n" + Cur_Bat_Name
                    + "  #_" + rule_index + "  manufacturer_show  ### 把当前的 jpg 和 png   放到 jpg_tag_timestamp目录   \n"
                    + Cur_Bat_Name + "  #_" + rule_index
                    + "  artist_show  ### 把当前的 jpg 和 png  放到 jpg_tag_timestamp目录   \n" + Cur_Bat_Name + "  #_"
                    + rule_index + "  copyright_show  ### 把当前的 jpg 和 png   放到 jpg_tag_timestamp目录   \n" + Cur_Bat_Name
                    + "  #_" + rule_index + "  description_show  ### 把当前的 jpg 和 png  放到 jpg_tag_timestamp目录  \n"
                    + Cur_Bat_Name + "  #_" + rule_index
                    + "  comment_show  ### 把当前的 jpg 和 png   放到 jpg_tag_timestamp目录   \n" + Cur_Bat_Name + "  #_"
                    + rule_index
                    + "  copyright_show  harddir_true  ### 把当前的 jpg 和 png   放到 固定的 jpg_tag_dir目录 方便批处理   \n"
                    + Cur_Bat_Name + "  #_" + rule_index + "  copyright_show  harddir_true && cd ./jpg_tag_dir && "
                    + Cur_Bat_Name + " #_32 " + "  #### 对 jpg_yan_land 把 md写入图片并生成 pdf文件" + ""
//			zrule_apply_G2.bat  #_46  copyright_show  harddir_true
                    ;
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
// TODO Auto-generated method stub
            ArrayList<File> jpgFileList = getAllSubFile(curDirFile, ".jpg");

            if (jpgFileList.size() == 0) {
                System.out.println(" 当前目录 curDirFile=[" + curDirFile.getAbsolutePath() + "] 内没有 jpg文件!!  请检查后再次执行!! ");
                return null;
            }

            for (int i = 0; i < jpgFileList.size(); i++) {
//		Jpg_Exif
                File jpgFile = jpgFileList.get(i);
                String jpgName = jpgFile.getName();
                JPGExifInfo mStockExifJpg = new JPGExifInfo(jpgFile);
                StringBuilder rawLineSB = new StringBuilder();
                if (is_model_show) {
                    if (mStockExifJpg.mImageModel_Utf8 != null) {
                        rawLineSB.append("model:" + mStockExifJpg.mImageModel_Utf8 + "\n");
                    }

                }

                if (is_manufacturer_show) {
                    if (mStockExifJpg.mImageMake_Utf8 != null) {
                        rawLineSB.append("manufacturer:" + mStockExifJpg.mImageMake_Utf8 + "\n");
                    }

                }

                if (is_artist_show) {
                    if (mStockExifJpg.mImageArtist_Utf8 != null) {
                        rawLineSB.append("artist:" + mStockExifJpg.mImageArtist_Utf8 + "\n");
                    }

                }

                if (is_copyright_show) {
                    if (mStockExifJpg.mImageCopyright_Utf8 != null) {
                        rawLineSB.append("copyright:" + mStockExifJpg.mImageCopyright_Utf8 + "\n");
                    }

                }

                if (is_description_show) {
                    if (mStockExifJpg.mImageDescription_Utf8 != null) {
                        rawLineSB.append("description:" + mStockExifJpg.mImageDescription_Utf8 + "\n");
                    }

                }

                if (is_comment_show) {
                    if (mStockExifJpg.mPhotoUserComment_Utf8 != null) {
                        rawLineSB.append("comment:" + mStockExifJpg.mPhotoUserComment_Utf8 + "\n");
                    }

                }

                File srcJpgFile = jpgFile;
                File targetJpg = new File(outJpgFile.getAbsolutePath() + File.separator + jpgName);
                String drawLine = rawLineSB.toString();

                System.out.println("File[" + i + "] srcJpgFile=" + srcJpgFile.getAbsolutePath() + "  targetJpg="
                        + targetJpg.getAbsolutePath() + " drawLine=" + drawLine);
                drawTagJpg(srcJpgFile, targetJpg, drawLine);

            }

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);

        }

        void drawTagJpg(File srcJpgFile, File dstJpgFile, String drawText) {

            if (!dstJpgFile.getParentFile().exists()) {
                dstJpgFile.getParentFile().mkdirs();
            }

            fileCopy(srcJpgFile, dstJpgFile);
            File mCurFile = srcJpgFile;

            ImageIcon imageIcon = new ImageIcon(dstJpgFile.getAbsolutePath());

            BufferedImage bi = getBufferedImage(dstJpgFile);
            int heigh = bi.getHeight();
            int width = bi.getWidth();
            int jpg_width = width;
            int jpg_hight = heigh;

//				BufferedImage bi = new BufferedImage(width, heigh, BufferedImage.TYPE_INT_RGB);// INT精确度达到一定,RGB三原色，高度70,宽度150
            // 得到它的绘制环境(这张图片的笔)
            Graphics2D g2 = (Graphics2D) bi.getGraphics();
//				g2.fillRect(0, 0, jpg_width, jpg_width);// 填充一个矩形 左上角坐标(0,0),宽500,高500;填充整张图片
            g2.setColor(new Color(0, 0, 0));// 设置颜色
//				g2.fillRect(0, 0, width, heigh);// 填充整张图片(其实就是设置背景颜色)
            int frontSize = 16;
            int centerx = jpg_width / 2;
            int centery = jpg_hight / 2;

            int centery_20 = jpg_hight / 20;
            int centerx_20 = (jpg_width / 20) * 19;

            Font f = new Font("宋体", Font.BOLD, frontSize);
            g2.setFont(f); // 设置字体:字体、字号、大小
            FontRenderContext context = g2.getFontRenderContext();
            Rectangle2D bounds = f.getStringBounds(drawText + "", context);

            g2.drawString(drawText + "", (float) (jpg_width - 2 * bounds.getCenterX() - 30),
                    (float) (jpg_hight - 2 * bounds.getCenterY() - 30)); // 向图片上写字符串

//				g2.drawString(drawText + "", (float) (centerx - bounds.getCenterX()),	(float) (centery - bounds.getCenterY())); // 向图片上写字符串

            try {
//					dstJpgFile.createNewFile();
                ImageIO.write(bi, "jpg", new FileOutputStream(dstJpgFile));// 保存图片 JPEG表示保存格式
                System.out.println("创建文件[" + dstJpgFile.getName() + "]  = " + dstJpgFile.getAbsolutePath() + "成功");
            } catch (Exception e) {
                System.out.println("复制图片格式出现异常！");
            }

        }





    }

    class JPGExifInfo {
        File rawFile;

        public String mImageModel_Utf8; // 股票名称
        public String mImageMake_Utf8; // ts代码
        public String mImageArtist_Utf8; // 股票名称
        public String mImageCopyright_Utf8; // ts代码
        public String mImageDescription_Utf8; // 股票名称
        public String mPhotoUserComment_Utf8; // ts代码

        JPGExifInfo(File mFile) {
            rawFile = mFile;
            initTagProp(rawFile);
        }

        void initTagProp(File jpgFile) {
            String fileName = jpgFile.getAbsolutePath().toLowerCase().trim();
            if (!fileName.endsWith(".jpg")) {
                return;
            }
            initExifInfo(jpgFile);

            System.out.println("mImageModel_Utf8=" + mImageModel_Utf8 + "  mImageMake_Utf8=" + mImageMake_Utf8
                    + "  mImageArtist_Utf8=" + mImageArtist_Utf8 + "  mImageCopyright_Utf8=" + mImageCopyright_Utf8
                    + "  mImageDescription_Utf8=" + mImageDescription_Utf8 + " mPhotoUserComment_Utf8="
                    + mPhotoUserComment_Utf8);

        }

        void initExifInfo(File file) {

            mImageDescription_Utf8 = null;
            mImageMake_Utf8 = null;
            mImageModel_Utf8 = null;
            mImageArtist_Utf8 = null;
            mImageCopyright_Utf8 = null;
            mPhotoUserComment_Utf8 = null;

            int angel = 0;
            Metadata metadata;

            try {
                metadata = JpegMetadataReader.readMetadata(file);
                metadata.getDirectories();

                // zukgit_directory [Exif IFD0] - Orientation = Right side, top (Rotate 90 CW)
                for (Directory directory : metadata.getDirectories()) {
                    for (Tag tag : directory.getTags()) {
                        // 格式化输出[directory.getName()] - tag.getTagName() = tag.getDescription()
//						System.out.format("zukgit_directory  [%s] - %s = %s\n", directory.getName(), tag.getTagName(),tag.getDescription());

                        if ("Exif IFD0".equals(directory.getName())) {

                            String mImageDescription = directory.getString(ExifIFD0Directory.TAG_IMAGE_DESCRIPTION);
                            if (mImageDescription != null)
                                mImageDescription_Utf8 = new String(mImageDescription.getBytes(), "UTF-8");

                            String mImageMake = directory.getString(ExifIFD0Directory.TAG_MAKE);
                            if (mImageMake != null)
                                mImageMake_Utf8 = new String(mImageMake.getBytes(), "UTF-8");

                            String mImageModel = directory.getString(ExifIFD0Directory.TAG_MODEL);
                            if (mImageModel != null)
                                mImageModel_Utf8 = new String(mImageModel.getBytes(), "UTF-8");

                            String mImageArtist = directory.getString(ExifIFD0Directory.TAG_ARTIST);
                            if (mImageArtist != null)
                                mImageArtist_Utf8 = new String(mImageArtist.getBytes(), "UTF-8");

                            String mImageCopyright = directory.getString(ExifIFD0Directory.TAG_COPYRIGHT);
                            if (mImageCopyright != null)
                                mImageCopyright_Utf8 = new String(mImageCopyright.getBytes(), "UTF-8");

//							System.out.println("XXmImageDescription=["+mImageDescription+"]  Utf8["+mImageDescription_Utf8+"]");
//							System.out.println("XXmImageMake=["+mImageMake+"]  Utf8["+mImageMake_Utf8+"]");
//							System.out.println("XXmImageModel=["+mImageModel+"]  Utf8["+mImageModel_Utf8+"]");
//							System.out.println("XXmImageArtist=["+mImageArtist+"]  Utf8["+mImageArtist_Utf8+"]");
//							System.out.println("XXmImageCopyright=["+mImageCopyright+"]  Utf8["+mImageCopyright_Utf8+"]");

                        }

                        if ("Exif SubIFD".equals(directory.getName())) {

                            if ("User Comment".equals(tag.getTagName())) {
                                String mPhotoUserComment = tag.getDescription();
//						System.out.println("AZ_User_Comment=["+tag.getDescription()+"]");
                                if (mPhotoUserComment != null)
                                    mPhotoUserComment_Utf8 = new String(mPhotoUserComment.getBytes(), "utf-8");
//						System.out.println("AZXXmPhotoUserComment=["+mPhotoUserComment+"]   mPhotoUserComment_Utf8=["+mPhotoUserComment_Utf8+"]" );

                            }

                        }
                    }

                }

            } catch (JpegProcessingException e) {
                e.printStackTrace();
                System.out.println("JpegProcessingException  异常事件发生 ");
            } catch (IOException e) {
                System.out.println("IOException  异常事件发生 ");
                e.printStackTrace();
            }

//			String mImageArtist_CategoryStr= null;
//			String mImageCopyright_VideoMD = null;
//		    String mImageDescription_SelfDesc = null;
//
//
//		String mImageMake_Utf8 = null;     // 待定
//		String mImageModel_Utf8 = null;     // 待定
//		String mPhotoUserComment_Utf8 = null;   // 待定

            if (mImageArtist_Utf8 != null) {
                System.out.println(" mImageArtist_Utf8 = " + mImageArtist_Utf8);

            } else {
                System.out.println("当前文件 [" + file.getName() + "] 没有读取到 mImageArtist_CategoryStr !! ");
            }

            if (mImageDescription_Utf8 != null) {
                System.out.println(" mImageDescription_Utf8 = " + mImageArtist_Utf8);

            } else {
                System.out.println("当前文件 [" + file.getName() + "] 没有读取到 mImageDescription_SelfDesc !! ");
            }

            if (mImageCopyright_Utf8 != null) {

                System.out.println(" mImageCopyright_Utf8 = " + mImageCopyright_Utf8);

            } else {
                System.out.println("当前文件 [" + file.getName() + "] 没有读取到 mImageCopyright_VideoMD !! ");
            }

            if (mImageMake_Utf8 != null) {
                System.out.println(" mImageMake_Utf8 = " + mImageMake_Utf8);
            } else {
                System.out.println("当前文件 [" + file.getName() + "] 没有读取到 mImageMake_Utf8 !! ");
            }

            if (mImageModel_Utf8 != null) {
                System.out.println(" mImageModel_Utf8 = " + mImageModel_Utf8);
            } else {
                System.out.println("当前文件 [" + file.getName() + "] 没有读取到 mImageModel_Utf8 !! ");
            }

            if (mPhotoUserComment_Utf8 != null) {
                System.out.println(" mPhotoUserComment_Utf8 = " + mPhotoUserComment_Utf8);
            } else {
                System.out.println("当前文件 [" + file.getName() + "] 没有读取到 mPhotoUserComment_Utf8 !! ");
            }

        }

    }

    class Jpg_Stock_Port_To_MD_Rule_45 extends Basic_Rule {

        ArrayList<File> jpgFileList; // 当前目录下的 jpg 文件
        ArrayList<StockExifJpg> jpgExifList; // 当前从 jpg读取信息后生成的原始数据

        boolean is_stock; // 考研 类型

        Jpg_Stock_Port_To_MD_Rule_45() {
            super("#", 45, 4); //
            jpgFileList = new ArrayList<File>();
            jpgExifList = new ArrayList<StockExifJpg>();

        }

        @Override
        boolean allowEmptyDirFileList() {
            // TODO Auto-generated method stub
            return true;
        }

        @Override
        String simpleDesc() {

            return "\n" + Cur_Bat_Name + " #_" + rule_index
                    + "  stock_true  ###   生成 股票吐槽相关 的.md 读取当前文件夹下的jpg文件的exif信息 生成 这些 jpg_stock_port 中的 创建日期 初始资金 股票列表 用户评论信息    ";

        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // mdname_true // kaoyan_true gaokao_true

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem = inputParamList.get(i);
                String paramItem_lower_trim = paramItem.toLowerCase().trim();

                if ("stock_true".equals(paramItem_lower_trim)) {
                    is_stock = true;
                }

            }

            if (!is_stock) {
                System.out.println("当前输入的参数 没有包含 stock_true  参数 请检查! ");
                return false;
            }

            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
// TODO Auto-generated method stub
            jpgFileList = getAllSubFile(curDirFile, ".jpg");

            if (jpgFileList.size() == 0) {
                System.out.println(" 当前目录 curDirFile=[" + curDirFile.getAbsolutePath() + "] 内没有 jpg文件!!  请检查后再次执行!! ");
                return null;
            }

            for (int i = 0; i < jpgFileList.size(); i++) {
//		Jpg_Exif
                File jpgFile = jpgFileList.get(i);
                StockExifJpg mStockExifJpg = new StockExifJpg(jpgFile);

                if (mStockExifJpg.isImageEnable) {
                    jpgExifList.add(mStockExifJpg);
                }

            }

            if (jpgExifList.size() == 0) {

                System.out.println(" 当前目录 curDirFile=[" + curDirFile.getAbsolutePath() + "]  存在[" + jpgFileList.size()
                        + "]个jpg " + " 但无法正常读取到 stock_ exif 信息  请检查后再次执行!! ");

                return null;
            }

            jpgExifList.sort(new Comparator<StockExifJpg>() {
                @Override
                public int compare(StockExifJpg o1, StockExifJpg o2) {
                    return o2.createDateStr.trim().compareTo(o1.createDateStr.trim());
                }

            });

            ArrayList<String> mMdContentList = BuildStockMDContent(jpgExifList);

// 对 MD文件 进行分隔处理
            ArrayList<String> segerate_MdContentList = new ArrayList<String>();

//			---
//			layout: post
//			title: 年月里【First When See When Listen When Happen When Do】
//			category: 生活
//			tags: Life
//			keywords: 生活 感想
//			typora-root-url: ..\..\
//			typora-copy-images-to: ..\..\public\zimage
//			---
//
//
//			## 简介
//			 * TOC
//			 {:toc}

            segerate_MdContentList.add("---");
            if (is_stock) {
                segerate_MdContentList.add("layout: post");
                segerate_MdContentList.add("title: 股票吐槽汇");
                segerate_MdContentList.add("category: 生活");
                segerate_MdContentList.add("tags: Life");
                segerate_MdContentList.add("keywords: 生活 股票");
                segerate_MdContentList.add("typora-root-url: ..\\..\\");
                segerate_MdContentList.add("typora-copy-images-to: ..\\..\\public\\zimage\\jpg_stock_port");

            }
            segerate_MdContentList.add("---");
            segerate_MdContentList.add("\n");

            segerate_MdContentList.add("## 简介_UserBean(" + jpgExifList.size() + ")");
            segerate_MdContentList.add(" * TOC");
            segerate_MdContentList.add(" {:toc}");
            segerate_MdContentList.add("\n");

            for (int i = 0; i < mMdContentList.size(); i++) {
                String contentLine = mMdContentList.get(i);
                segerate_MdContentList.add("\n" + contentLine);

            }

            writeContentToFile(G2_Temp_Text_File, segerate_MdContentList);
            NotePadOpenTargetFile(G2_Temp_Text_File.getAbsolutePath());

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);

        }

        ArrayList<String> BuildStockMDContent(ArrayList<StockExifJpg> jpgExifList) {
            ArrayList<String> stockMDList = new ArrayList<String>();

            // 1. 首先对 jpg 进行 改名

            // 读取 每一个 jpgStockExif 生成 MD 文件

            for (int i = 0; i < jpgExifList.size(); i++) {
                StockExifJpg jpgExifitem = jpgExifList.get(i);
//				System.out.println("jpg_exif[" + i + "] = " + jpgExifitem.toString());
                jpgExifitem.renameOperation();

                ArrayList<String> exifMDList = jpgExifitem.buildStockContent();

                if (exifMDList != null && exifMDList.size() > 0) {
                    stockMDList.addAll(exifMDList);
                }

            }

            return stockMDList;

        }

        class StockExifJpg { // 在 JPG 中 读取到的 exif 相关的股票信息

            @Override
            public String toString() {
                return "StockExifJpg [jpgFile=" + jpgFile + ", createDateStr=" + createDateStr + ", initMoneyDouble="
                        + initMoneyDouble + ", stockMatchRawList=" + stockMatchRawList + ", isImageEnable="
                        + isImageEnable + ", rawExifStr=" + rawExifStr + ", userCommentStr=" + userCommentStr
                        + ", stockItemList=" + stockItemList + "]";
            }

            File jpgFile; // 对应的 jpg 文件

            String image_url_prefix; // 初始资金
            File reNameFile; // 重命名后的那个文件
            String createDateStr; // 创建日期
            String initMoneyDouble; // 初始资金

            ArrayList<String> stockMatchRawList; // 【万科A:000002:20:10000】 这样的字符串的集合

            boolean isImageEnable; // 图片是否 符合 exif 条件
            String rawExifStr; // 从文件读取到的 exif 信息的 集合 组成一句话

            String userCommentStr; // 用户评论字符串 把初始资金 创建日期 股票列表都去除后 剩下的
            ArrayList<StockItemExifInfo> stockItemList; // 从 exif 中 读取到的 股票信息

//			### 2021.12.12_20,000,000
//
//			#### biyadi_20_20000
//
//			#### wankeA_21.22_30000
//			<img src="xxxx"/>
//
//
//			```
//			尼玛 在8.21 买入 在8.20 卖出不就好了  记录 一笔 comment
//
//			```

            public ArrayList<String> buildStockContent() {
                ArrayList<String> stockMDList = new ArrayList<String>();
                DecimalFormat decimalFormat_A = new DecimalFormat(",#00");
                DecimalFormat decimalFormat_B = new DecimalFormat("#00.00");
                // 创建 自身的 MD文件的 内容

                String reNameFileName = reNameFile.getName();

                stockMDList.add(
                        "### " + createDateStr + "_" + decimalFormat_A.format(Double.parseDouble(initMoneyDouble)));

                for (int i = 0; i < stockItemList.size(); i++) {

                    StockItemExifInfo stockExif = stockItemList.get(i);

                    stockMDList.add("#### " + stockExif.stockName + "_"
                            + (decimalFormat_B.format(stockExif.costPriceForOne)) + "_" + stockExif.stockKeepCount);

                }

                stockMDList.add("```");
                stockMDList.add(userCommentStr);
                stockMDList.add("```");

                stockMDList.add(
                        "<img src=\"" + (image_url_prefix + reNameFileName) + "\"  height=\"33%\" width=\"33%\"  >");

                stockMDList.add("");

                stockMDList.add("");
                return stockMDList;

            }

            public void renameOperation() {

                String originFileName = jpgFile.getName();
                String parentPath = jpgFile.getParentFile().getAbsolutePath();
                String dynamicFileName = getMatchFileName();

                if (dynamicFileName != null && !dynamicFileName.equals(originFileName)) {

                    if (tryReName(jpgFile, dynamicFileName)) {

                        System.out.println(
                                "当前 jpgFile 文件名[" + originFileName + "]已经 改为 动态计算的名字[" + dynamicFileName + "]  改名成功");
                        reNameFile = new File(parentPath + File.separator + dynamicFileName);
                    } else {

                        System.out.println(
                                "当前 jpgFile 文件名[" + originFileName + "] 改为 动态计算的名字[" + dynamicFileName + "] 改名失败 ");
                        reNameFile = jpgFile;
                    }

                } else {

                    System.out.println("当前 jpgFile 文件名已经是 动态计算的结果不需要改名");
                    reNameFile = jpgFile;
                }

            }

            // 读取 exif 后 匹配到的
            public String getMatchFileName() {
                StringBuilder sb = new StringBuilder();

//				2021.11.11_福田汽车-21.21-2131_格力电器-31.41-3141_10000000.jpg

                if (stockItemList == null) {
                    return jpgFile.getName();
                }
                DecimalFormat decimalFormat_A = new DecimalFormat(",#00");
                DecimalFormat decimalFormat_B = new DecimalFormat("#00.00");

                sb.append(createDateStr);
                sb.append("_");

                for (int i = 0; i < stockItemList.size(); i++) {
                    StockItemExifInfo stockItem = stockItemList.get(i);
                    String stockName = stockItem.stockName;
                    sb.append(stockName);
                    sb.append("-");
                    sb.append(decimalFormat_B.format(stockItem.costPriceForOne));
                    sb.append("-");
                    sb.append(stockItem.stockKeepCount);
                    sb.append("_");
                }
                sb.append(initMoneyDouble);
                sb.append(".jpg");
                return sb.toString();

            }

            StockExifJpg(File rawFile) {
                jpgFile = rawFile;
                isImageEnable = true;
                if (!jpgFile.exists() || !jpgFile.getName().toLowerCase().endsWith(".jpg")) {
                    isImageEnable = false;
                    return;
                }

                rawExifStr = getAllExifStr(jpgFile);
                image_url_prefix = "/public/zimage/jpg_stock_port/";
                if (rawExifStr == null || "".equals(rawExifStr)) {
                    System.out.println("jpg_stock_port  imageFile[" + jpgFile.getAbsolutePath() + "] 无法读取到 exif信息");
                    isImageEnable = false;
                    return;
                }

                String initMoneyStr = calculStringMiddleForOne(rawExifStr, "【初始资金:", "】");
                String createDateStrTemp = calculStringMiddleForOne(rawExifStr, "【创建日期:", "】");

                print(" 【createDateStrTemp [" + createDateStrTemp + "]】");
                if (initMoneyStr == null || "".equals(initMoneyStr) || createDateStrTemp == null
                        || "".equals(createDateStrTemp)) {
                    System.out.println("无法读取到 初始资金 创建日期 exif 信息 ");
                    isImageEnable = false;
                    return;
                }

                createDateStr = createDateStrTemp;
                if (!isNumeric(initMoneyStr)) {
                    System.out.println("无法读取到 初始资金 exif 信息 ");
                    isImageEnable = false;
                    return;
                }

                initMoneyDouble = initMoneyStr;

                String stockOnlyStr = rawExifStr.replace("【初始资金:" + initMoneyStr + "】", "");
                stockOnlyStr = stockOnlyStr.replace("【创建日期:" + createDateStr + "】", "");
                // 【福田汽车:600166:3.5:100000】
                ArrayList<String> matchStockStrList = calculExifStockTagList(stockOnlyStr);

                if (matchStockStrList == null && matchStockStrList.size() <= 0) {

                    System.out.println("无法读取到 股票信息 如【福田汽车:600166:3.5:100000】   exif 信息 ");
                    isImageEnable = false;
                    return;
                }

                stockMatchRawList = matchStockStrList;

                userCommentStr = calculUserComment(createDateStr, initMoneyStr, stockMatchRawList, rawExifStr);

                print("userCommentStr = [" + userCommentStr + "]");

                // 对 stockItemList 进行初始化
                stockItemList = new ArrayList<StockItemExifInfo>();

                // 对 【福田汽车:600166:3.5:100000】 这样的数据 解析
                for (int i = 0; i < stockMatchRawList.size(); i++) {
                    String oneStockStr = stockMatchRawList.get(i);
                    String[] stockArrTag = oneStockStr.split(":");
                    if (stockArrTag == null || stockArrTag.length != 4) {
                        continue;
                    }

                    String tsName = stockArrTag[0];
                    String tsCode = stockArrTag[1];
                    String buyPriceForOne = stockArrTag[2];
                    String buyCount = stockArrTag[3];

                    StockItemExifInfo stockItem = new StockItemExifInfo();
                    stockItem.setCostPriceForOne(Double.parseDouble(buyPriceForOne));
                    stockItem.setStockKeepCount(Long.parseLong(buyCount));
                    stockItem.setStockName(tsName);
                    stockItem.setTsCode(tsCode);

                    stockItemList.add(stockItem);

                }

            }

            // 去除 日期 去除 初始资金 去除 股票 剩下的 就是 comment
            public String calculUserComment(String dateStr, String moneyStr, ArrayList<String> stockTagList,
                                            String rawStr) {

                String reusltStr = rawStr.replace(" ", "");

                System.out.println(" 创建日期 = " + "【创建日期:" + dateStr + "】" + " reusltStr=" + reusltStr);
                reusltStr = reusltStr.replace("【创建日期:" + dateStr + "】", "");
                reusltStr = reusltStr.replace("【初始资金:" + moneyStr + "】", "");

                for (int i = 0; i < stockTagList.size(); i++) {
                    String stockTagItem = stockTagList.get(i);
                    reusltStr = reusltStr.replace(stockTagItem, "");

                }

                reusltStr = reusltStr.replace("【", "");
                reusltStr = reusltStr.replace("】", "");

                return reusltStr;

            }

            public ArrayList<String> calculExifStockTagList(String rawStr) {
                // 【初始资金:100000】【创建日期:2021.11.11】【福田汽车:600166:3.5:100000】
                ArrayList<String> stockMatchList = new ArrayList<String>();

                String[] stockArr = rawStr.split("】");
                for (int i = 0; i < stockArr.length; i++) {
                    String tagItem = stockArr[i].trim();
                    System.out.println("stockArr[" + i + "] = " + stockArr[i]);
                    if (tagItem.startsWith("【初始资金:") || tagItem.startsWith("【创建日期:")) {
                        continue;
                    }
                    String clearBlank = tagItem.replace("【", "").replace("】", "");
                    if (!clearBlank.contains(":")) {
                        System.out.println("当前 ImageUserBean 不包含 分隔符:引号");
                        continue;
                    }
                    String[] oneStockArr = clearBlank.split(":");
                    if (oneStockArr == null || oneStockArr.length != 4) {
                        System.out.println("当前 ImageStockBean 【名称:代码:买入价格:买入数量】 格式不对请检查");
                        continue;
                    }

                    for (int j = 0; j < oneStockArr.length; j++) {
                        System.out.println("oneStockArr[" + j + "] = " + oneStockArr[j]);
                    }

                    stockMatchList.add(clearBlank);

                }

                return stockMatchList;

            }

            public void print(String log) {

                System.out.println(log);
            }

            public String calculStringMiddleForOne(String rawStr, String preStr, String endStr) {
                String matchStr = null;
                String tempStrA = rawStr.substring(rawStr.indexOf(preStr) + preStr.length());
                System.out.println(
                        " 读取到  imageUser 的 exif 信息 ImageUser_exifInfo = " + rawStr + "   tempStrA=" + tempStrA);
                String tempStrB = tempStrA.substring(0, tempStrA.indexOf(endStr));
                System.out.println(
                        " 读取到  imageUser 的 exif 信息 ImageUser_exifInfo = " + rawStr + "   tempStrB=" + tempStrB);
                return tempStrB;

            }

            public String getAllExifStr(File imageFile) {
                String mMatchStr = null;

                String mImageDescription_Utf8 = null;
                String mImageMake_Utf8 = null;
                String mImageModel_Utf8 = null;
                String mImageArtist_Utf8 = null;
                String mImageCopyright_Utf8 = null;
                String mPhotoUserComment_Utf8 = null;
                int angel = 0;
                Metadata metadata;

                try {
                    metadata = JpegMetadataReader.readMetadata(imageFile);
                    metadata.getDirectories();

                    // zukgit_directory [Exif IFD0] - Orientation = Right side, top (Rotate 90 CW)
                    for (Directory directory : metadata.getDirectories()) {
                        for (Tag tag : directory.getTags()) {
                            // 格式化输出[directory.getName()] - tag.getTagName() = tag.getDescription()
//									System.out.format("zukgit_directory  [%s] - %s = %s\n", directory.getName(), tag.getTagName(),tag.getDescription());

                            if ("Exif IFD0".equals(directory.getName())) {

                                String mImageDescription = directory.getString(ExifIFD0Directory.TAG_IMAGE_DESCRIPTION);
                                if (mImageDescription != null)
                                    mImageDescription_Utf8 = new String(mImageDescription.getBytes(), "UTF-8");

                                String mImageMake = directory.getString(ExifIFD0Directory.TAG_MAKE);
                                if (mImageMake != null)
                                    mImageMake_Utf8 = new String(mImageMake.getBytes(), "UTF-8");

                                String mImageModel = directory.getString(ExifIFD0Directory.TAG_MODEL);
                                if (mImageModel != null)
                                    mImageModel_Utf8 = new String(mImageModel.getBytes(), "UTF-8");

                                String mImageArtist = directory.getString(ExifIFD0Directory.TAG_ARTIST);
                                if (mImageArtist != null)
                                    mImageArtist_Utf8 = new String(mImageArtist.getBytes(), "UTF-8");

                                String mImageCopyright = directory.getString(ExifIFD0Directory.TAG_COPYRIGHT);
                                if (mImageCopyright != null)
                                    mImageCopyright_Utf8 = new String(mImageCopyright.getBytes(), "UTF-8");

//										System.out.println("XXmImageDescription=["+mImageDescription+"]  Utf8["+mImageDescription_Utf8+"]");
//										System.out.println("XXmImageMake=["+mImageMake+"]  Utf8["+mImageMake_Utf8+"]");
//										System.out.println("XXmImageModel=["+mImageModel+"]  Utf8["+mImageModel_Utf8+"]");
//										System.out.println("XXmImageArtist=["+mImageArtist+"]  Utf8["+mImageArtist_Utf8+"]");
//										System.out.println("XXmImageCopyright=["+mImageCopyright+"]  Utf8["+mImageCopyright_Utf8+"]");

                            }

                            if ("Exif SubIFD".equals(directory.getName())) {

                                if ("User Comment".equals(tag.getTagName())) {
                                    String mPhotoUserComment = tag.getDescription();
//									System.out.println("AZ_User_Comment=["+tag.getDescription()+"]");
                                    if (mPhotoUserComment != null)
                                        mPhotoUserComment_Utf8 = new String(mPhotoUserComment.getBytes(), "utf-8");
//									System.out.println("AZXXmPhotoUserComment=["+mPhotoUserComment+"]   mPhotoUserComment_Utf8=["+mPhotoUserComment_Utf8+"]" );

                                }

                            }
                        }

                    }

                    mMatchStr = getExifInfoAsOneStr(mImageModel_Utf8, mImageMake_Utf8, mImageArtist_Utf8,
                            mImageCopyright_Utf8, mImageDescription_Utf8, mPhotoUserComment_Utf8);

                } catch (JpegProcessingException e) {
                    e.printStackTrace();
                    System.out.println("JpegProcessingException  异常事件发生 ");
                } catch (IOException e) {
                    System.out.println("IOException  异常事件发生 ");
                    e.printStackTrace();
                }

                if (mMatchStr == null || "".equals(mMatchStr)) {
                    System.out.println(" 没有读取到  imageUser 的 exif 信息 ");
                    return null;
                }
                System.out.println(" 读取到  imageUser 的 exif 信息 ImageUser_exifInfo = " + mMatchStr);
                return mMatchStr;

            }

            public String getExifInfoAsOneStr(String A1, String B2, String C3, String D4, String E5, String F6) {
                StringBuilder sb = new StringBuilder();
                sb.append(A1 != null ? A1.trim() : "");
                sb.append(B2 != null ? B2.trim() : "");
                sb.append(C3 != null ? C3.trim() : "");
                sb.append(D4 != null ? D4.trim() : "");
                sb.append(E5 != null ? E5.trim() : "");
                sb.append(F6 != null ? F6.trim() : "");

                return sb.toString();

            }

        }

        class StockItemExifInfo {

            public String stockName; // 股票名称
            public String tsCode; // ts代码
            public double costPriceForOne; // 成本
            public long stockKeepCount; // 持有数量

            public String getStockName() {
                return stockName;
            }

            public void setStockName(String stockName) {
                this.stockName = stockName;
            }

            public String getTsCode() {
                return tsCode;
            }

            public void setTsCode(String tsCode) {
                this.tsCode = tsCode;
            }

            public double getCostPriceForOne() {
                return costPriceForOne;
            }

            public void setCostPriceForOne(double costPriceForOne) {
                this.costPriceForOne = costPriceForOne;
            }

            public long getStockKeepCount() {
                return stockKeepCount;
            }

            public void setStockKeepCount(long stockKeepCount) {
                this.stockKeepCount = stockKeepCount;
            }

            public double getSrockAllCost() {

                return costPriceForOne * stockKeepCount;
            }

        }

    }

    // operation_type 操作类型 1--读取文件内容字符串 进行修改 2--对文件对文件内容(字节)--进行修改 3.对全体子文件进行的随性的操作
    // 属性进行修改(文件名称)
//     // 4.对当前子文件(包括子目录 子文件 --不包含孙目录 孙文件) 5. 从shell 中获取到的路径 去对某一个文件进行操作

    class Land_Port_Mp4Rename_Rule_44 extends Basic_Rule {

        Land_Port_Mp4Rename_Rule_44() {
            super("#", 44, 4); //

            mSrcMP4FileList = new ArrayList<File>();

            mLandMP4FileList = new ArrayList<File>();

            mPortMP4FileList = new ArrayList<File>();

        }

        File mSouTuDir; // 当前视频的缩略图文件夹

        ArrayList<File> mSrcMP4FileList; // Shell 目录下原始文件目录
        ArrayList<File> mLandMP4FileList; // Shell/Land_Port_TimeStamp/Land/ 文件夹下的文件
        ArrayList<File> mPortMP4FileList; // Shell/Land_Port_TimeStamp/Land/ 文件夹下的文件

        // 在缩图中的名称对应的 是否是 isport的属性
        Map<String, Boolean> notypeFileName_IsPort_Map_InSuotu;

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // TODO Auto-generated method stub

            File[] listFile = curDirFile.listFiles();
            if (listFile == null || listFile.length == 0) {
                System.out.println("当前执行目录文件为空 无法执行程序 请检查!!  ");
                return false;
            }

            for (int i = 0; i < listFile.length; i++) {
                File curFile = listFile[i];
                String fileName = curFile.getName();
                if (curFile.isDirectory() && fileName.startsWith("SuoTu_MP4_")) {
                    mSouTuDir = curFile;

                }
            }

            if (mSouTuDir == null || !mSouTuDir.exists() || mSouTuDir.listFiles() == null
                    || mSouTuDir.listFiles().length == 0) {

                System.out.println("当前缩略图文件夹为空 请检查:  mSouTuDir = " + mSouTuDir);
                System.out.println("Tip: ");
                System.out.println("当前程序需要先执行zmpeg_ffmpeg_G8.bat 9     ## 把当前目录下的 Mp4 生成缩略图");
                System.out.println(" 当前程序依赖 软件  ffmpeg.exe ");
                return false;

            }

            initMapWithSuoTuDir(mSouTuDir);

            return super.initParamsWithInputList(inputParamList);
        }

        void initMapWithSuoTuDir(File suotuDir) {
            notypeFileName_IsPort_Map_InSuotu = new HashMap<String, Boolean>();
            File[] fileList = suotuDir.listFiles();

            for (int i = 0; i < fileList.length; i++) {
                File curFile = fileList[i];
                String type = getFileTypeWithPoint(curFile.getName());
                String fileNameNoPoint = getFileNameNoPoint(curFile.getName());
                if (".jpg".equals(type)) {
                    ImageIcon imageIcon = new ImageIcon(curFile.getAbsolutePath());
                    int high = imageIcon.getIconHeight();
                    int width = imageIcon.getIconWidth();
                    boolean isPort = true;
                    if (width > high) {
                        isPort = false;
                    } else {
                        isPort = true;
                    }

                    notypeFileName_IsPort_Map_InSuotu.put(fileNameNoPoint, isPort);

                }

            }

            deleteDirectory(suotuDir.getAbsolutePath());

            System.out.println("notypeFileName_IsPort_Map Size[" + notypeFileName_IsPort_Map_InSuotu.size() + "]");

        }

        boolean isVideoPort_MP4Parser(File videoFile) {
            boolean isport = true;
            try {
                IsoFile isoFile = new IsoFile(new FileInputStream(videoFile).getChannel());

                MovieBox movieBox = org.mp4parser.tools.Path.getPath(isoFile, "moov");
// 可以打印这个 movieBox  toString 看看里面有啥
                List<org.mp4parser.Box> boxes = movieBox.getBoxes();
// 宽高时长获取
                long duration = movieBox.getMovieHeaderBox().getDuration();
                int width = 0;
                int height = 0;
                for (org.mp4parser.Box box : boxes) {
                    if (box instanceof TrackBox) {
                        TrackBox tBbx = (TrackBox) box;
                        width = (int) tBbx.getTrackHeaderBox().getWidth();
                        height = (int) tBbx.getTrackHeaderBox().getHeight();

                        if (width > height) {

                            isport = false;
                        }

                        System.out.println(
                                "filename[" + videoFile.getName() + "]" + "   width[" + width + "]" + "  hight["
                                        + height + "]" + "   isport[" + isport + "]" + "  duration[" + duration + "]");

                        break;
                    }
                }

                isoFile.close();
            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
                System.out.println("异常发生 e=" + e);
            }

            return isport;

        }

        boolean isVideoPort_MultimediaInfo(File mp4File) {
            boolean isport = true;

            Encoder encoder = new Encoder();

            try {
                MultimediaInfo m = encoder.getInfo(mp4File);

                VideoSize size = m.getVideo().getSize();

                long duration = m.getDuration();

                int lastsecond = (int) duration / 1000 - 1;

                int height = size.getHeight();
                int width = size.getWidth();
                if (height < width) {
                    isport = false;
                }
                System.out.println("filename[" + mp4File.getName() + "]" + "   width[" + width + "]" + "    hight["
                        + height + "]" + "   isport[" + isport + "]   duration[" + duration + "]  lastsecond["
                        + lastsecond + "]");

            } catch (Exception e) {
                e.printStackTrace();
            }

            return isport;

        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            for (int i = 0; i < curRealFileList.size(); i++) {
                File fileItem = curRealFileList.get(i);
                String fileName = fileItem.getName();
                String fileName_lower = fileName.toLowerCase();

                if (fileName_lower.endsWith(".mp4") || fileName_lower.endsWith(".MP4")) {
                    mSrcMP4FileList.add(fileItem);
                }

            }

            for (int i = 0; i < mSrcMP4FileList.size(); i++) {
                File mp4File = mSrcMP4FileList.get(i);
                String mp4NameNoType = getFileNameNoPoint(mp4File.getName());

                if (notypeFileName_IsPort_Map_InSuotu.containsKey(mp4NameNoType)) {
                    Boolean isPort = notypeFileName_IsPort_Map_InSuotu.get(mp4NameNoType);
                    if (isPort) {
                        mPortMP4FileList.add(mp4File);
                    } else {
                        mLandMP4FileList.add(mp4File);
                    }

                } else {

                    System.out.println(
                            "当前文件 mp4File=" + mp4File.getName() + " 无法在缩略图文件夹 " + mSouTuDir + " 找到对应的缩略图!! 无法判断");

                }

            }

            int allOperationFileCount = mSrcMP4FileList.size() + mPortMP4FileList.size();

            for (int i = 0; i < mPortMP4FileList.size(); i++) {
                File mp4File = mPortMP4FileList.get(i);
                String fileName = mp4File.getName();
                if (fileName.startsWith("Port_")) { // 已经有分类 cintinue
                    continue;
                }
                String new_name = "Port_" + fileName;

                System.out.println("Port[" + i + "] AllPort[" + mPortMP4FileList.size() + "]  AllMP4["
                        + allOperationFileCount + "]  OldName[" + fileName + "]  newName[" + new_name + "]");
                tryReName(mp4File, new_name);

            }

            for (int i = 0; i < mLandMP4FileList.size(); i++) {
                File mp4File = mLandMP4FileList.get(i);
                String fileName = mp4File.getName();
                if (fileName.startsWith("Land_")) { // 已经有分类 cintinue
                    continue;
                }
                String new_name = "Land_" + fileName;
                System.out.println();
                System.out.println("Land[" + i + "] AllLand[" + mLandMP4FileList.size() + "]  AllMP4["
                        + allOperationFileCount + "]  OldName[" + fileName + "]  newName[" + new_name + "]");

                tryReName(mp4File, new_name);

            }

            System.out.println("" + rule_index + " 对Video 进行 Port_ 和 Land_ 的重命名完成!");

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        @Override
        String simpleDesc() {

            return "\n" + "zmpeg_ffmpeg_G8.bat 9 && " + Cur_Bat_Name + " #_" + rule_index
                    + "   ###  对当前的目录中的MP4文件 先生成动态 缩略图文件夹 获取正确宽高后 以 Port_ 和 Land_前缀来重命名MP4文件名称   ";
        }

    }

    class SqlitTxt_Return_FirstBlankStr_Rule_43 extends Basic_Rule {

        File operationFile; // 不能为空
        String sqlitstr_tag; // 从外输入的 对txt文件进行切割的 标示 不能为空

        SqlitTxt_Return_FirstBlankStr_Rule_43() {
            super("#", 43, 4); //

        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            // TODO Auto-generated method stub

            String Tag = ReadFileContent(operationFile);
            String[] tagArr = Tag.split(sqlitstr_tag);

            ArrayList<String> matchStrList = new ArrayList<String>();
            matchStrList.add("════════════════════" + "切割Tag=" + sqlitstr_tag + " ════════════════════");
            for (int i = 0; i < tagArr.length; i++) {
                String stritem = tagArr[i];

                // 为了 获取 分隔后的每行, 每行包含一些空格，所以 这里取到每行空格之前的字符串
                String[] blankArr = stritem.split(" ");
                if (blankArr != null) {
                    String oneBlankStr = blankArr[0];
                    oneBlankStr = oneBlankStr.replace("\"", ""); // 去除引号
                    if (oneBlankStr.equals("")) {
                        continue;
                    }

//					System.out.println("index["+i+"]:oneBlank【"+oneBlankStr+"】");
                    matchStrList.add(oneBlankStr);
//					System.out.println("index["+i+"]:oneBlank【"+oneBlankStr+"】:["+tagArr[i]+"]");

                }

            }

            matchStrList.sort(new Comparator<String>() {
                @Override
                public int compare(String o1, String o2) {
                    return o1.compareTo(o2);
                }

            });

            ArrayList<String> resultStrList = new ArrayList<String>();
            resultStrList.add("输入参数已经结果:  sqlitstr[" + sqlitstr_tag + "]" + "  operationFile["
                    + operationFile.getAbsolutePath() + "]");

            resultStrList.addAll(matchStrList);

            writeContentToFile(G2_Temp_Text_File, resultStrList);
            NotePadOpenTargetFile(G2_Temp_Text_File.getAbsolutePath());

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // TODO Auto-generated method stub

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem = inputParamList.get(i);

                if (paramItem.contains("sqlitstr_")) {
                    sqlitstr_tag = paramItem.replace("sqlitstr_", "");
                    continue;

                }

                File targetFile = new File(curDirPath + File.separator + paramItem);

                if (targetFile.exists()) {

                    operationFile = targetFile;
                }

            }

            if (operationFile == null || !operationFile.exists()) {

                System.out.println("当前 规则:" + rule_index + " 需要输入的文件为空, 请检查输入！！");
                return false;
            }

            if (sqlitstr_tag == null || sqlitstr_tag.equals("")) {

                System.out.println("当前 规则:" + rule_index + " 需要输入切割字符串 sqlitstr_XXX 为空！！, 请检查输入！！");
                return false;
            }

            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        String simpleDesc() {

            return "\n" + Cur_Bat_Name + " #_" + rule_index
                    + "  2.txt sqlitstr_href     ### 一个本地操作文件以及一个切割符,返回切割后的每行的第一个空格前的字符串 ";
        }

    }

    class GetHttpCode_Rule_42 extends Basic_Rule {

        boolean html2md_flag; // html2md_true // 把当前的 html 转为 md的操作

        // 必须以 http 开头
        String searchHttpUrl; // 从输入传入的 需要得到 的 http 源码的 网页的地址
        ChromeDriver mChromeDriver;
        String curPositionHtmlCodeStr; // 每次得到的 html代码的值 用于突然用户终止程序时 使用

        GetHttpCode_Rule_42() {
            super("#", 42, 4); //
            html2md_flag = false;
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // TODO Auto-generated method stub

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem = inputParamList.get(i);
                String paramItem_lower_trim = paramItem.toLowerCase().trim();
                System.out.println("paramItem[" + i + "] = " + paramItem_lower_trim);
                if (paramItem_lower_trim.startsWith("http")) {
                    searchHttpUrl = paramItem;
                }

                if (paramItem_lower_trim.startsWith("html2md_true")) {
                    html2md_flag = true;
                }

            }

            if (searchHttpUrl == null) {
                System.out.println("当前输入的网页为空  请检查输入!!!");
                return false;
            }

            File ChromeDriverFile = new File(zbinPath + File.separator + "G2_chromedriver_v91.exe");

            System.setProperty("webdriver.chrome.driver", ChromeDriverFile.getAbsolutePath());

            ChromeOptions CUR_CHROME_OPTIONS = new ChromeOptions();
            // 驱动位置
            CUR_CHROME_OPTIONS.addArguments("--start-fullscreen");

            CUR_CHROME_OPTIONS.setExperimentalOption("excludeSwitches", Collections.singletonList("enable-automation"));

            mChromeDriver = new ChromeDriver(CUR_CHROME_OPTIONS);

            System.out.println("searchHttpUrl=【" + searchHttpUrl + "】  html2md_flag=【" + html2md_flag + "】");

            return super.initParamsWithInputList(inputParamList);
        }

        void registerShutDownLister() {
            Runtime.getRuntime().addShutdownHook(new Thread() {
                public void run() {
                    try {
                        Thread.sleep(200);
                        System.out.println("════════ 监听到 Ctr+Z stop进程操作 将执行保存当前页面位置代码的操作 ════════");

                        writeContentToFile(G2_Temp_Text_File, curPositionHtmlCodeStr);
                        NotePadOpenTargetFile(G2_Temp_Text_File.getAbsolutePath());

                        System.out.println("获得【" + searchHttpUrl + "】 MainPage HtmlCode 突然终止 部分成功 !! ");
                        System.out.println("════════" + "════════");
                        // some cleaning up code...

                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
            });

        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            // TODO Auto-generated method stub

            if (!html2md_flag) { // 确保 html2md 时 不打开 G2_Temp
                registerShutDownLister();
            }

            String httpPageCode = BrowserOperation_WithRootUrl(searchHttpUrl);

            if (httpPageCode != null) {

                if (html2md_flag) {
                    System.out.println("开始 进行 Html 转 MD 的文件的操作! ");

                    Html_2_MD_Operation(G2_Temp_Text_File);
                    System.out.println("执行  Html 转 MD 的文件的操作 成功! ! ");
                    return null;
                } else {

                    writeContentToFile(G2_Temp_Text_File, httpPageCode);
                    NotePadOpenTargetFile(G2_Temp_Text_File.getAbsolutePath());
                    System.out.println("获得【" + searchHttpUrl + "】 MainPage HtmlCode 成功!! ");

                }
            } else {
                System.out.println("获得【" + searchHttpUrl + "】 MainPage HtmlCode 失败!! ");

            }

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name + " #_" + rule_index
                    + " https://www.baidu.com   ### 传递一个http路径打开它的html源码(tip:有些页面浏览器另存为的html由于某些html页面) "

                    + "\n" + Cur_Bat_Name + " #_" + rule_index
                    + " https://zhou-yuxin.github.io/articles/2016/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9CWPA2%E5%8A%A0%E5%AF%86%E7%9A%84%E7%A0%B4%E8%A7%A3/index.html  html2md_true   ### 传递一个http路径打开它的html源码 并解析到 MD文件(以github.io工程的文件夹格式) ";
        }

        // html2md ====================begin==========================

        // 模拟主页
//		String rootUrl = "https://zhou-yuxin.github.io/articles/2016/%E6%97%A0%E7%BA%BF%E7%BD%91%E7%BB%9CWPA2%E5%8A%A0%E5%AF%86%E7%9A%84%E7%A0%B4%E8%A7%A3/";

        String rootUrl = "https://qiankunli.github.io";
        String rootUrl_possible_url1 = "https://qiankunli.github.io";
        // https://qiankunli.github.io/2022/03/20/xxxx资源

        // 当前的主页 https://qiankunli.github.io/2022/03/20/flink.html
        //

        // <p><img src="/public/upload/compute/flink_design.png" alt="" /></p>
        // https://qiankunli.github.io/ public/upload/compute/flink_design.png
        // https://qiankunli.github.io/ 资源的主页
        // <img src="x.jpg"> 中的 x.jpg 对应的 src的 绝对的路径

        HashMap<String, String> srcImageUrl_ZimageUrl_Map; // <img src="x.jpg">【key】 <img src="x.jpg"> 【value】<img
        // src="//../zimage/architect/01_sorttable.jpg">
        HashMap<String, String> srcImageUrl_AbsUrl_Map; // <img src="x.jpg">【key】 https://www.baidu.com/x.jpg【value】
        HashMap<String, String> srcImageUrl_AbsUrl_Possibale1_Map; // <img src="x.jpg">【key】
        // https://www.baidu.com/x.jpg【value】

        HashMap<String, File> srcImageUrl_LocalFile_Map; // 1.jpg 对应的 本地的 public/zimage/html2md/1.jpg

        ArrayList<String> srcImageUrl_List; // <img src="x.jpg"> 的原始 内容为了最终方便 替换
        ArrayList<String> innderHtmlTag; // 需要去除的 tag

        File curMDShellDir; // 本地的shell执行的路径
        // html_2_md_timestemp
        File html_md_timestamp_dir; // html_2_md_20220818_192012/ 当前目录下 生成的 html_2_md_timestamp
        String html_md_timestamp_dirname; // html_2_md_20220818_192012

        File html_zimage_dir; // html_2_md_20220818_192012/zukgit.github.io/public/zimage/html2md/
        File html_2_mdfile_dir; // html_2_md_20220818_192012/zukgit.github.io/_posts/Technology/html2md/
        // html_2_md_20220818_192012/zukgit.github.io
        // html_2_md_20220818_192012/zukgit.github.io/public/zimage/html2md/
        // 【html_zimage_dir】
        // html_2_md_20220818_192012/zukgit.github.io/public/zimage/html2md/xxxx.jpg
        // html_2_md_20220818_192012/zukgit.github.io/_posts/Technology/html2md/
        // html_2_md_20220818_192012/zukgit.github.io/_posts/Technology/html2md/{title}.md

        String md_title; // 当前html的 title 属性 当做 md 文件的名称
        File md_file; // 目标的 md 文件

        String time_stamp_str; // 日期格式

        // md 文件的头部
        ArrayList<String> mdHeadList;

        void init_http_url() {
            String inputUrl = searchHttpUrl;

            rootUrl = searchHttpUrl;
            rootUrl_possible_url1 = searchHttpUrl;
            if (inputUrl.endsWith(".html")) {
                // /
                rootUrl = inputUrl.substring(0, inputUrl.lastIndexOf("/"));

            }

            // https://qiankunli.github.io
            if (searchHttpUrl.contains("github.io")) {
                rootUrl_possible_url1 = searchHttpUrl.substring(0,
                        searchHttpUrl.indexOf("github.io") + "github.io".length());

            }

            System.out.println("searchHttpUrl=【" + searchHttpUrl + "】   rootUrl=【" + rootUrl
                    + "】   rootUrl_possible_url1=" + rootUrl_possible_url1);

        }

        void Html_2_MD_Operation(File httpCodeFile) {
            init_html2md_value();
            init_http_url();
            String httpCodeFileName = time_stamp_str + "_" + httpCodeFile.getName();
            File curShell_TxtFile = new File(curDirFile.getAbsolutePath() + File.separator + httpCodeFileName);
            fileCopy(httpCodeFile, curShell_TxtFile);

            Html_2_MD(curShell_TxtFile);

        }

        void Html_2_MD(File fileItem) {

            curMDShellDir = fileItem.getParentFile();
            System.out.println("curShellDir = " + curMDShellDir);

            initHtml2MD_Dir(curMDShellDir); // 初始化 那些 需要用到的目录

            ArrayList<String> allMD_StrList = new ArrayList<String>();
            ArrayList<String> fixedMD_StrList = new ArrayList<String>();
            ArrayList<String> rawHtml_StrList = ReadFileContentAsList(fileItem);

            // 0. <h1> 转为 # <h6> 转为 ######

            // 1. <p> 转为 空 去除掉
            // 1.1 <img src="1.png"> 转为 相对路径 需要计算 src的绝对路径 所以需要依据参数得到 这里假设有 保留
// 下载到本地 并命名为 	20220818_3142.png
//				<img src="//../zimage/html2md/20220818_3142.png">
            // 1.2 <a> </a> 可保留

            // 2. <pre> 转为 "\n```\n" <pre> 转为 "\n```\n"

            // 3. 最后处理
            // 去除 <body class="p" > 给定参数 body 去除 <body 开头 以及 在它之后的 > 的这段内容
            // <div id="main"> <article id=" <article id= <\ 开头的 以及之后的> 去除

            for (int j = 0; j < rawHtml_StrList.size(); j++) {
                String oneLineStr = rawHtml_StrList.get(j);
                String fixedLineStr = new String(oneLineStr);
                ;

                // 0. <h1> 转为 # <h6> 转为 ######
                fixedLineStr = title_to_jing(oneLineStr);
                // 1. <p> operation
                fixedLineStr = clear_p_br_tag(fixedLineStr);

                // 2. <pre> operation
                fixedLineStr = clear_pre_tag(fixedLineStr);

                // 3. 去除 <body class="p" >
                fixedLineStr = clear_inner_tag(fixedLineStr);

                // &lt;==< &gt;==> 的转换
                fixedLineStr = clear_lt_gt_tag(fixedLineStr);

                // amp; 转为 空格
                fixedLineStr = clear_amp_tag(fixedLineStr);

                fixedMD_StrList.add(fixedLineStr);
            }

            // 2022-09-13-
            md_file = new File(html_2_mdfile_dir + File.separator + getYear_Month_Day() + "-" + md_title + ".md");

            initHeadList(md_title); // 初始化 mdHeadList

            // allMD_StrList = mdHeadList + fixedMD_StrList

            System.out.println("srcImageUrl_List.size() = " + srcImageUrl_List.size());

//					HashMap<String,String> srcImageUrl_ZimageUrl_Map;  //<img src="x.jpg">【key】 <img src="x.jpg">    【value】<img src="//../zimage/architect/01_sorttable.jpg">
//					HashMap<String,String> srcImageUrl_AbsUrl_Map;  //<img src="x.jpg">【key】   https://www.baidu.com/x.jpg【value】
//					HashMap<String,File> srcImageUrl_LocalFile_Map;

            for (int j = 0; j < srcImageUrl_List.size(); j++) {
                String imageUrlItem = srcImageUrl_List.get(j);
                String networkAbsUrl = srcImageUrl_AbsUrl_Map.get(imageUrlItem);
                String networkAbsUrl_Possible1 = srcImageUrl_AbsUrl_Map.get(imageUrlItem);
                String publicImage_Src_Url = srcImageUrl_ZimageUrl_Map.get(imageUrlItem);
                File localImgFile = srcImageUrl_LocalFile_Map.get(imageUrlItem);

                System.out.println("image[" + j + "][" + srcImageUrl_List.size() + "]  MD_File="
                        + md_file.getAbsolutePath() + "   showUrl=" + imageUrlItem + "  networkUrl:" + networkAbsUrl
                        + " publicSrc:" + publicImage_Src_Url + "  localFile:" + localImgFile.getAbsolutePath()
                        + " possible_url1=【" + networkAbsUrl_Possible1 + "】");

                if (!downloadImage(localImgFile, networkAbsUrl)) {
                    System.out.println("mainUrl:" + networkAbsUrl + "  没有下载成功 尝试使用备用路径 networkAbsUrl_Possible1="
                            + networkAbsUrl_Possible1);

                    if (!downloadImage(localImgFile, networkAbsUrl_Possible1)) {
                        System.out.println(" FUCK 主路径和配用路径都下载失败!! " + "mainUrl:" + networkAbsUrl
                                + "  没有下载成功 尝试使用备用路径 networkAbsUrl_Possible1=" + networkAbsUrl_Possible1);

                    }

                }
            }

            allMD_StrList.addAll(mdHeadList);

            // 去除 占用多行的 注释 <!-- --> 和 <script> 以及 </script>
            ArrayList<String> clearScriptMDList = clearMultiZhuShi_clearMultiScript(fixedMD_StrList);

            // 多行空格转为 一行 空格 使得 整体 看起来紧凑
            ArrayList<String> clear_MultiBlankMDList = clearMultiBlank(clearScriptMDList);
            allMD_StrList.addAll(clear_MultiBlankMDList);

//				writeContentToFile(I9_Temp_Text_File, fixedMD_StrList);
//				NotePadOpenTargetFile(I9_Temp_Text_File.getAbsolutePath());

            writeContentToFile(md_file, allMD_StrList);
            NotePadOpenTargetFile(md_file.getAbsolutePath());

        }

        void init_html2md_value() {
            srcImageUrl_ZimageUrl_Map = new HashMap<String, String>();
            srcImageUrl_AbsUrl_Map = new HashMap<String, String>();
            srcImageUrl_AbsUrl_Possibale1_Map = new HashMap<String, String>();
            srcImageUrl_List = new ArrayList<String>();
            srcImageUrl_LocalFile_Map = new HashMap<String, File>();
            mdHeadList = new ArrayList<String>();
            time_stamp_str = getTimeStampyyyyMMdd_HHmmss();
            init_innerTag_List();

        }

        void init_innerTag_List() {
            innderHtmlTag = new ArrayList<String>();
            innderHtmlTag.add("html");
            innderHtmlTag.add("head");
//			innderHtmlTag.add("title");
            innderHtmlTag.add("link");
            innderHtmlTag.add("body");
            innderHtmlTag.add("header");
            innderHtmlTag.add("meta");
            innderHtmlTag.add("div");
            innderHtmlTag.add("article");

            innderHtmlTag.add("i");
            innderHtmlTag.add("!doctype html");
            innderHtmlTag.add("br");
            innderHtmlTag.add("li");
            innderHtmlTag.add("ul");
            innderHtmlTag.add("table");

            innderHtmlTag.add("tr");

            innderHtmlTag.add("td");
            innderHtmlTag.add("button");
            innderHtmlTag.add("ol");

            innderHtmlTag.add("hr");
            innderHtmlTag.add("thead");

            innderHtmlTag.add("th");

            innderHtmlTag.add("footer");
            innderHtmlTag.add("tbody");
            innderHtmlTag.add("code");
            innderHtmlTag.add("span");
//			innderHtmlTag.add("!--");
//			innderHtmlTag.add("script");

        }

//		---
//		layout: post
//		title: {title}
//		category: html2md
//		tags: html2md
//		keywords:
//		typora-root-url:..\..\..\
//		typora-copy-images-to:..\..\..\public\zimage\html2md
//		---

        void initHeadList(String title) {

            mdHeadList.add("---");
            mdHeadList.add("layout: post");
            if (title == null || title.startsWith("unknow")) {
                mdHeadList.add("title: " + "unknow");

            } else {
                mdHeadList.add("title: " + title);
            }
            mdHeadList.add("category: html2md");
            mdHeadList.add("tags: html2md");
            mdHeadList.add("keywords: ");
            mdHeadList.add("typora-root-url: ..\\..\\..\\");
            mdHeadList.add("typora-copy-images-to: ..\\..\\..\\public\\zimage\\html2md");
            mdHeadList.add("---");

            mdHeadList.add("\n");

            mdHeadList.add("## 简介");
            mdHeadList.add(" * TOC");
            mdHeadList.add(" {:toc}");

            mdHeadList.add("\n");
            mdHeadList.add("\n");

        }

        void initHtml2MD_Dir(File shellDirFile) {
            String shellPath = shellDirFile.getAbsolutePath();

            html_md_timestamp_dirname = "html_2_md" + "_" + time_stamp_str;
            md_title = "unknow" + time_stamp_str;

            html_md_timestamp_dir = new File(shellPath + File.separator + html_md_timestamp_dirname);
            html_zimage_dir = new File(
                    html_md_timestamp_dir.getAbsolutePath() + File.separator + "zukgit.github.io" + File.separator
                            + "public" + File.separator + "zimage" + File.separator + "html2md" + File.separator);
            html_2_mdfile_dir = new File(
                    html_md_timestamp_dir.getAbsolutePath() + File.separator + "zukgit.github.io" + File.separator
                            + "_posts" + File.separator + "Technology" + File.separator + "html2md" + File.separator);

        }

        ArrayList<String> clearMultiBlank(ArrayList<String> rawMDList) {
            ArrayList<String> clearMultiBlankList = new ArrayList<String>();

            boolean is_preline_blank = false;
            for (int i = 0; i < rawMDList.size(); i++) {
                String oneLine = rawMDList.get(i);
                String clear_blank_str = oneLine.replace("    ", "").replace(" ", "").trim();

                if ("".equals(clear_blank_str)) {
                    if (!is_preline_blank) {
                        clearMultiBlankList.add("");
                    }
                    is_preline_blank = true;

                    continue;
                } else {
                    is_preline_blank = false;
                    // 缩进 必须是 2 6 之间 不能是 4 否则会影响后面的 空格
                    if (oneLine.startsWith("    ") && !oneLine.startsWith("     ")) {
                        oneLine = oneLine.replace("    ", "  ");

                    }
                    clearMultiBlankList.add(oneLine);
                }

            }

            return clearMultiBlankList;
        }

        ArrayList<String> clearMultiZhuShi_clearMultiScript(ArrayList<String> rawMDList) {
            ArrayList<String> fixedMDList = new ArrayList<String>();

            boolean isEmptyLine_ZhuShi = false; // 是否包含在多行注释内 是否包含在 多行 script 内

            boolean isEmptyLine_Script = false; // 是否包含在多行注释内 是否包含在 多行 script 内

            int isInCodeCount = 0; // 在 code 中的 代码是 不需要 去除的
            for (int i = 0; i < rawMDList.size(); i++) {
                String rawLine = rawMDList.get(i);
                String fixedLine = new String(rawLine);

                // <script 和 </script> 在同一行 那么 去除 这些
                if (rawLine.contains("<script") && rawLine.contains("</script>")) {
                    String matchStr = getSubString_WithPre_WithEnd(rawLine, "<script", "</script>");
                    if (matchStr != null) {
                        fixedLine = rawLine.replace(matchStr, "");
                        fixedLine = fixedLine.replace("<script", "");
                        fixedLine = fixedLine.replace("</script>", "");
                        fixedMDList.add(fixedLine);
                        continue;
                    }

                }

                if (rawLine.contains("<!--") && rawLine.contains("-->")) {
                    String matchStr = getSubString_WithPre_WithEnd(rawLine, "<!--", "-->");
                    if (matchStr != null) {
                        fixedLine = rawLine.replace(matchStr, "");
                        fixedLine = fixedLine.replace("<!--", "");
                        fixedLine = fixedLine.replace("-->", "");
                        fixedMDList.add(fixedLine);
                        continue;
                    }

                }

                // 多行 script
                if (rawLine.contains("<script") && !rawLine.contains("</script>")) {
                    isEmptyLine_Script = true;
                }

                if (!rawLine.contains("<script") && rawLine.contains("</script>")) {
                    isEmptyLine_Script = false;
                    continue; // 这一行 也不要了
                }

                // 多行 script
                if (rawLine.contains("<!--") && !rawLine.contains("-->")) {
                    isEmptyLine_ZhuShi = true;
                }

                if (!rawLine.contains("<!--") && rawLine.contains("-->")) {
                    isEmptyLine_ZhuShi = false;
                    continue; // 这一行 也不要了
                }

                if (rawLine.startsWith("```")) {
                    isInCodeCount++;
                }

                // isInCodeCount%2 != 1 &&说明是在 code 中
                if (!isEmptyLine_Script && !isEmptyLine_ZhuShi && (isInCodeCount % 2 != 1)) {
                    fixedMDList.add(fixedLine);
                }

            }

            return fixedMDList;

        }
        // &lt;==< &gt;==> 的转换
//		fixedLineStr = clear_lt_gt_tag(fixedLineStr);

        // 特殊字符串的处理
        String clear_amp_tag(String rawLine) {
            String fixedLineStr = new String(rawLine);
            fixedLineStr = fixedLineStr.replace("amp;", "");

            return fixedLineStr;
        }

        // 特殊字符串的处理
        String clear_lt_gt_tag(String rawLine) {
            String fixedLineStr = new String(rawLine);
            fixedLineStr = fixedLineStr.replace("&lt;", "<");
            fixedLineStr = fixedLineStr.replace("&gt;", ">");

            if (fixedLineStr.contains("[") && !fixedLineStr.contains("]") && isContainChinese(fixedLineStr)) {
                fixedLineStr = fixedLineStr.replace("[", "【");

            }

            return fixedLineStr;
        }

        boolean downloadImage(File targetImgFile, String networkUrl) {
            boolean downFlag = false;
            int byteRead;

            try {
                // 写入文件
                File fileSavePath = new File(targetImgFile.getAbsolutePath());
                // 注:如果保存文件夹不存在,那么则创建该文件夹
                File fileParent = fileSavePath.getParentFile();
                if (!fileParent.exists()) {
                    fileParent.mkdirs();
                }

                URL url = new URL(networkUrl);
                URLConnection conn = url.openConnection();

                InputStream inStream = conn.getInputStream();

                FileOutputStream fs = new FileOutputStream(fileSavePath);
                byte[] buffer = new byte[1024];
                long beginTimeStamp = System.currentTimeMillis();
                System.out.println("FileOutputStream.write  写入本地文件  Begin   比较 downRawVideo_耗时_B ");
                while ((byteRead = inStream.read(buffer)) != -1) {
                    fs.write(buffer, 0, byteRead);
                }
                long endTimeStamp = System.currentTimeMillis();
                long distance_second = (endTimeStamp - beginTimeStamp) / 1000;

                System.out.println(
                        "FileOutputStream.write  写入本地文件  End ( downRawVideo_耗时_B【" + distance_second + " 秒】 耗时得很)");

                inStream.close();
                fs.close();

            } catch (Exception e) {
                // TODO: handle exception
                System.out.println("下载 " + networkUrl + " 图片失败: e=" + e);
            }

            if (targetImgFile.exists() && targetImgFile.length() > 10) {
                downFlag = true;
            }

            return downFlag;

        }

        String clear_inner_tag(String rawLine) {
            String fixed_LineStr = new String(rawLine);
            for (int i = 0; i < innderHtmlTag.size(); i++) {
                String tag = innderHtmlTag.get(i);
                String beginTag = "<" + tag + ">";
                String beginTag_Innder = "<" + tag + " ";
                String EndTag = "</" + tag + ">";

                // <head> </head> 同在一行
                if (fixed_LineStr.contains(beginTag) && fixed_LineStr.contains(EndTag)) {
                    fixed_LineStr = fixed_LineStr.replace(beginTag, "");
                    fixed_LineStr = fixed_LineStr.replace(EndTag, "");
                } else if (fixed_LineStr.contains(beginTag) && !fixed_LineStr.contains(EndTag)) {
                    // 只包含 <head> 没有 </head> 的 字样
                    fixed_LineStr = fixed_LineStr.replace(beginTag, "");
                } else if (!fixed_LineStr.contains(beginTag) && fixed_LineStr.contains(EndTag)) {
                    // 只包含 </head> 没有 <head> 的 字样
                    fixed_LineStr = fixed_LineStr.replace(EndTag, "");
                }

                // da <link rel="stylesheet" type="text/css" media="all"
                // href="../../../style.css"> dada // <div class="highlight">
                if (fixed_LineStr.contains(beginTag_Innder)) {
                    String indderStr = getSubString_WithPre_WithEnd(fixed_LineStr, beginTag_Innder, ">");

                    if (indderStr != null) {

                        fixed_LineStr = fixed_LineStr.replace(indderStr, "");

                        while (fixed_LineStr.contains(beginTag_Innder)) {
                            String step_place_str = getSubString_WithPre_WithEnd(fixed_LineStr, beginTag_Innder, ">");
                            if (step_place_str != null) {
                                fixed_LineStr = fixed_LineStr.replace(step_place_str, "");
                            }

                        }

                    }

                }

            }

            if (fixed_LineStr.contains("<title>") && fixed_LineStr.contains("</title>")) {

                md_title = fixed_LineStr.replace("<title>", "").replace("</title>", "").replace("	", "")
                        .replace("=", "").replace(" ", "").replace("!", "").replace("&", "").replace("#", "")
                        .replace("@", "").replace("|", "").replace("%", "").replace("&", "").trim();
            }

            return fixed_LineStr;

        }

        String clear_strong_tag(String rawLine) {
            String fixedLineStr = new String(rawLine);
            fixedLineStr = fixedLineStr.replace("<strong>", "!");
            fixedLineStr = fixedLineStr.replace("</strong>", "!");
            return fixedLineStr;
        }

        String clear_pre_tag(String rawLine) {
            String fixedLineStr = new String(rawLine);

            fixedLineStr = fixedLineStr.replace("<pre>", "\n```\n");
            fixedLineStr = fixedLineStr.replace("</pre>", "\n```\n");

            // <pre class="highlight"> 也要 改成 ```
            if (fixedLineStr.contains("<pre ")) { //
                String match_Inner_Pre_Tag = getSubString_WithPre_WithEnd(fixedLineStr, "<pre ", ">");

                if (match_Inner_Pre_Tag != null) {
                    fixedLineStr = fixedLineStr.replace(match_Inner_Pre_Tag, "\n```\n");

                }

            }
            return fixedLineStr;
        }

        // 获得 第一个匹配到的 前缀 和 后缀的 字符串
        String getSubString_WithPre_WithEnd(String oldExp, String pre, String end) {
            String result = oldExp;
            int matchIndex = 0;
            int end_FirstIndex = result.indexOf(end, matchIndex);

            int begin_ExpIndex = calculNearPairIndex(result, end_FirstIndex, pre); //

            while (begin_ExpIndex == -1) {
                matchIndex++;
                end_FirstIndex = result.indexOf(end, matchIndex);

                begin_ExpIndex = calculNearPairIndex(result, end_FirstIndex, pre); //

                if (matchIndex > 100) {
                    System.out.println("无法匹配到A " + " begin_ExpIndex = " + begin_ExpIndex + " end_FirstIndex="
                            + end_FirstIndex + "  oldExp=【" + oldExp + "】     pre=【" + pre + "】  end=【" + end + "】");

                    return null;
                }
            }
// begin_ExpIndex = -1 end_FirstIndex=34  oldExp=【      <a class="pjaxlink" href="/"><img src="/public/upload/gavatar/gavatar.jpg" class="img-rounded avatar"></a>】     pre=【<img】  end=【>】
            if (end_FirstIndex == -1) {
                System.out.println("无法匹配到B " + " begin_ExpIndex = " + begin_ExpIndex + " end_FirstIndex="
                        + end_FirstIndex + "  oldExp=【" + oldExp + "】     pre=【" + pre + "】  end=【" + end + "】");

                return null;
            }

            String targetExpNoOut = result.substring(begin_ExpIndex + 1, end_FirstIndex); // 包前 不包后
            String targetExpWithOut = result.substring(begin_ExpIndex, end_FirstIndex + end.length()); // 包前 包后 加上 后缀的长度
            // System.out.println(" oldExp = " + oldExp);
            // System.out.println(" targetExpWithOut = " + targetExpWithOut);
            // System.out.println(" targetExpNoOut = " + targetExpNoOut);
            // System.out.println(" begin_ExpIndex = " + begin_ExpIndex + " end_FirstIndex
            // =" + end_FirstIndex);
            System.out.println(" begin_ExpIndex = " + begin_ExpIndex + " end_FirstIndex=" + end_FirstIndex
                    + "  oldExp=【" + oldExp + "】     pre=【" + pre + "】  end=【" + end + "】" + " targetExpWithOut=【"
                    + targetExpWithOut + "】");

            return targetExpWithOut;
        }

        // 计算 在 字符串 originStr 中 在位置 endIndex 之前 最近的那个 匹配上的 matchStr的 索引
        int calculNearPairIndex(String originStr, int endIndex, String matchStr) {
            int beginIndex = 0;
            String subStr = originStr.substring(0, endIndex);
            beginIndex = subStr.lastIndexOf(matchStr);
            return beginIndex;

        }

        String clear_p_br_tag(String rawLine) {
            String fixedLineStr = new String(rawLine);
            fixedLineStr = fixedLineStr.replace("<p>", "");
            fixedLineStr = fixedLineStr.replace("</p>", "");
            fixedLineStr = fixedLineStr.replace("<br>", "");

            // <img src="2.jpeg">
            if (fixedLineStr.contains("<img") && fixedLineStr.contains(">")) {
                // 类似从 <p> faa <img src="2.jpeg"> fafa</p> 计算得到 <img src="2.jpeg">
                String imageNamePre = time_stamp_str;

                // <img src="1.png">
                // 转为 <img src="/public/zimage/html2md/"+time"1.png">
                System.out.println("当前的 <p> 中包含 链接<img >   fixedLineStr=" + fixedLineStr);

                String fixedmatchImgCode = getSubString_WithPre_WithEnd(fixedLineStr, "<img", ">");

//				int whileCount = 0 ;
//				while(fixedmatchImgCode == null) {
//					String fixed_ImageCode_temp = getSubString_WithPre_WithEnd(fixedLineStr,"<img",">");
//					if(fixed_ImageCode_temp != null) {
//						fixedmatchImgCode = fixed_ImageCode_temp;
//					}else {
//						if(whileCount > 10) {
//							break;
//						}
//
//					}
//					whileCount++;
//				}

                String matchImgCode = fixedmatchImgCode;

                matchImgCode = matchImgCode.replace("<img", "").replace("/>", "").replace(">", "").replace("src=", "")
                        .replace("\"", "").replace(" ", "");
//				srcImageUrl_ZimageUrl_Map= new HashMap<String,String>();
//				srcImageUrl_AbsUrl_Map= new HashMap<String,String>();
//				srcImageUrl_List = new ArrayList<String> ();
                System.out.println("matchImgCode = " + matchImgCode);
                if (!srcImageUrl_List.contains(matchImgCode)) {

                    // 动态计算 绝对路径的 url
                    String match_abs_imgsrc = rootUrl + "/" + matchImgCode;
                    String match_abs_imgsrc_possible1 = rootUrl_possible_url1 + "/" + matchImgCode;

                    String oneName_NoSep_FileName = matchImgCode.replace("/", "_");
                    String match_relative_imgsrc = "/public/zimage/html2md/" + time_stamp_str + "_"
                            + oneName_NoSep_FileName;

//
                    File match_relative_img_file = new File(html_zimage_dir.getAbsolutePath() + File.separator
                            + time_stamp_str + "_" + oneName_NoSep_FileName);

                    srcImageUrl_List.add(matchImgCode);
                    srcImageUrl_LocalFile_Map.put(matchImgCode, match_relative_img_file);
                    srcImageUrl_AbsUrl_Map.put(matchImgCode, match_abs_imgsrc);
                    srcImageUrl_AbsUrl_Possibale1_Map.put(matchImgCode, match_abs_imgsrc_possible1);
                    srcImageUrl_ZimageUrl_Map.put(matchImgCode, match_relative_imgsrc);

//				    String match_relative_imagecode = "<img src=\""+match_relative_imgsrc+"\">";

                    // <img src="1.png">
                    // 转为 <img src="/public/zimage/html2md/"+time"1.png">
                    fixedLineStr = fixedLineStr.replace(matchImgCode, match_relative_imgsrc);

                    // zimage/html_to_md/timestamp.jpg
                }

            }

            if (fixedLineStr.contains("<a") && fixedLineStr.contains(">")) {

                System.out.println("当前的 <p> 中包含 链接<a> 保留  fixedLineStr=" + fixedLineStr);

            }

            return fixedLineStr;
        }

        String title_to_jing(String rawLine) {
            String fixedLineStr = new String(rawLine);
            // 0. <h1> 转为 # <h6> 转为 ######
            // <h1 class="entry-title">无线网络WPA2加密的破解</h1>

            fixedLineStr = fixedLineStr.replace("	", "");
            if (fixedLineStr.contains("<h1") && fixedLineStr.contains("</h1>")) {
                String h_tag_innder = getSubString_WithPre_WithEnd(fixedLineStr, "<h1", ">");

                fixedLineStr = fixedLineStr.replace(h_tag_innder, "");
                fixedLineStr = fixedLineStr.replace("</h1>", "");
                fixedLineStr = "## " + fixedLineStr;
            }

            if (fixedLineStr.contains("<h2") && fixedLineStr.contains("</h2>")) {
                String h_tag_innder = getSubString_WithPre_WithEnd(fixedLineStr, "<h2", ">");

                fixedLineStr = fixedLineStr.replace(h_tag_innder, "");
                fixedLineStr = fixedLineStr.replace("</h2>", "");
                fixedLineStr = "### " + fixedLineStr;
            }

            if (fixedLineStr.contains("<h3") && fixedLineStr.contains("</h3>")) {
                String h_tag_innder = getSubString_WithPre_WithEnd(fixedLineStr, "<h3", ">");

                fixedLineStr = fixedLineStr.replace(h_tag_innder, "");
                fixedLineStr = fixedLineStr.replace("</h3>", "");
                fixedLineStr = "#### " + fixedLineStr;
            }

            if (fixedLineStr.contains("<h4") && fixedLineStr.contains("</h4>")) {
                String h_tag_innder = getSubString_WithPre_WithEnd(fixedLineStr, "<h4", ">");

                fixedLineStr = fixedLineStr.replace(h_tag_innder, "");
                fixedLineStr = fixedLineStr.replace("</h4>", "");
                fixedLineStr = "##### " + fixedLineStr;
            }

            if (fixedLineStr.contains("<h5") && fixedLineStr.contains("</h5>")) {
                String h_tag_innder = getSubString_WithPre_WithEnd(fixedLineStr, "<h5", ">");

                fixedLineStr = fixedLineStr.replace(h_tag_innder, "");
                fixedLineStr = fixedLineStr.replace("</h5>", "");
                fixedLineStr = "###### " + fixedLineStr;
            }

            if (fixedLineStr.contains("<h6") && fixedLineStr.contains("</h6>")) {
                String h_tag_innder = getSubString_WithPre_WithEnd(fixedLineStr, "<h6", ">");

                fixedLineStr = fixedLineStr.replace(h_tag_innder, "");
                fixedLineStr = fixedLineStr.replace("</h6>", "");
                fixedLineStr = "###### " + fixedLineStr;
            }

            return fixedLineStr;
        }

        // html2md ==================== end ==========================

        String BrowserOperation_WithRootUrl(String mMainUrl) {

            String mainPageHtmlStr = null;
            File ChromeDriverFile = new File(zbinPath + File.separator + "G2_chromedriver_v91.exe");

            System.setProperty("webdriver.chrome.driver", ChromeDriverFile.getAbsolutePath());

            ChromeDriver driver = mChromeDriver;
            int loop_index = 0;
            try {
                long waitTime = 1000;
                long timeout = 60_000; // 15 秒 // 给他 1分钟

                driver.get(mMainUrl);
                String title = driver.getTitle();
                System.out.printf("loop_index[" + loop_index + "] = " + title);

                System.out.printf("A now accesss %s \n", driver.getCurrentUrl());

//				 long waitTime = Double.valueOf(Math.max(3, Math.random() * 5) * 1000).longValue();
                TimeUnit.MILLISECONDS.sleep(waitTime);

                // 循环下拉，直到全部加载完成或者超时
                do {
                    new Actions(driver).sendKeys(Keys.END).perform();
                    TimeUnit.MILLISECONDS.sleep(waitTime);

                    timeout -= waitTime;
                    loop_index++;
                    curPositionHtmlCodeStr = driver.getPageSource();
                } while (!driver.getPageSource().contains("已经到底部，没有新的内容啦") && timeout > 0);
                System.out.println("BrowserOperation_WithRootUrl 已经到底部，没有新的内容啦");
                mainPageHtmlStr = driver.getPageSource();
                curPositionHtmlCodeStr = driver.getPageSource();
            } catch (Exception e) {
                // TODO: handle exception
                System.out.println("获取网页源码的时候出错  mMainUrl = " + mMainUrl);
                e.printStackTrace();

            }

            if (mainPageHtmlStr != null) {

                System.out.println("当前已经得到网页Html代码如下:\n" + mainPageHtmlStr);

            } else {
                System.out.println("rootUrl.mHtmlStr  ==== null ");
            }

            return mainPageHtmlStr;
        }

    }
// 规则:
//1.jpg 的 Copyright 放入对应的 video文件的 md值
//2. jpg  和 video  命名都是 以 md5 文件命名
//3. 所有的 artist  Desc  Make  Mode  Copyright UserComment  信息都以 _ 下划线 结束防止可能的乱码
//4. jpg 的 Artist 放入涉及的知识内容 作为分类的依据 以下划线_分开
//5. Desc  放入自己的对video 的个人见解 理解
// 6. Make  Mode  UserComment 这三项  还没想好放什么
// 7. 涉及初衷 是为了 把 学习过的video 作为 子项 在各个知识点类目下 显示 为了保存自己学习的过程 而设计的这个规则
//  zfilesearch_D6.bat .jpg    能查看到具体的填充项

    // 读取当前文件夹下的jpg文件(仅仅时当前目录) 然后 读取当前的jpg的 artist Desc Make Mode Copyright
    // UserComment 信息 来生成 .md文件

//	_______ type=[.jpg] index=[1] name=[2021-08-04_144330.jpg]  Exif Begin  _______
//			JpgIndex[1] == Artist[隔热_] Desc[个问题_] Make[疯玩五天_] Mode[废物废物_] Copyright[如果我问过我_] UserComment[问他我问过_]

    volatile int mCategory_JpgExif_Count_Rule_41 = 0;

    class Read_Jpg_Exif_Info_Create_MDContent_Rule_41 extends Basic_Rule {
        ArrayList<File> jpgFileList; // 当前目录下的 jpg 文件
        ArrayList<Jpg_Exif> jpgExifList; // 当前从 jpg读取信息后生成的原始数据
        String video_url_prefix; // video md文件中 video标签的前缀
        String image_url_prefix; // jpg md文件中 jpg标签的前缀

        boolean is_kaoyan; // 考研 类型
        boolean is_gaokao; // 高考 类型

        ArrayList<String> English_CharList; // A-Z 的 集合
        ArrayList<String> Chinese_CharList; // 中文的集合 "公式集合" "导式集合" "结尾叹"

        ArrayList<String> mCategoryItemList_In_Jpg; // 所有 分类 的 类型 二级分类的类型

        // key 为 jpg 中的 Category , List 为 符合 这个 category 的 Jpg_Exif
        Map<String, ArrayList<Jpg_Exif>> mCategory_JpgExifList_Map;

        // key 英语Englist OneWord , value 为 符合 这个 Key的 Category的集合

        Map<String, ArrayList<String>> mOneWord_CategoryArr_Map;
        //

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // mdname_true // kaoyan_true gaokao_true

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem = inputParamList.get(i);
                String paramItem_lower_trim = paramItem.toLowerCase().trim();

                if ("kaoyan_true".equals(paramItem_lower_trim)) {
                    is_kaoyan = true;

                }

                if ("gaokao_true".equals(paramItem_lower_trim)) {
                    is_gaokao = true;

                }

            }

            if (is_gaokao) {
                video_url_prefix = "D:/Git_Dir/zschool/zschool_media/mp4_gaokao_land/";
                image_url_prefix = "/public/zimage/zschool_media/jpg_gaokao_land/";
            } else {
                video_url_prefix = "D:/Git_Dir/zschool/zschool_media/mp4_kaoyan_land/";
                image_url_prefix = "/public/zimage/zschool_media/jpg_kaoyan_land/";
            }

            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }

        Read_Jpg_Exif_Info_Create_MDContent_Rule_41() {
            super("#", 41, 4); //
            jpgFileList = new ArrayList<File>();
            jpgExifList = new ArrayList<Jpg_Exif>();

            initEnglishChar();
            initChineseChar();
        }

        void initChineseChar() {
            Chinese_CharList = new ArrayList<String>();
            Chinese_CharList.add("公式集合");
            Chinese_CharList.add("导式集合");
            Chinese_CharList.add("结尾叹");

        }

        void initEnglishChar() {
            English_CharList = new ArrayList<String>();
            mCategoryItemList_In_Jpg = new ArrayList<String>();
            mOneWord_CategoryArr_Map = new HashMap<String, ArrayList<String>>();
            mCategory_JpgExifList_Map = new HashMap<String, ArrayList<Jpg_Exif>>();

            English_CharList.add("A");
            English_CharList.add("B");
            English_CharList.add("C");
            English_CharList.add("D");
            English_CharList.add("E");
            English_CharList.add("F");
            English_CharList.add("G");
            English_CharList.add("H");
            English_CharList.add("I");
            English_CharList.add("J");
            English_CharList.add("K");
            English_CharList.add("L");
            English_CharList.add("M");
            English_CharList.add("N");
            English_CharList.add("O");
            English_CharList.add("P");
            English_CharList.add("Q");
            English_CharList.add("R");
            English_CharList.add("S");
            English_CharList.add("T");
            English_CharList.add("U");
            English_CharList.add("V");
            English_CharList.add("W");
            English_CharList.add("X");
            English_CharList.add("Y");
            English_CharList.add("Z");
        }

        class Jpg_Exif {
            // key 是 对应的首字母的 英文 大写字母 , List 是这个 Jpg_Exif 对应的属于这个索引下的 当前的Category

            Map<String, ArrayList<String>> mEnglishChar_CategoryList_Map;
            ArrayList<String> mCategoryList; // 在 artist_category 中以_分隔的 各个项
            String mImageArtist_CategoryStr = null;
            String mImageCopyright_VideoMD = null;
            String mImageDescription_SelfDesc = null;
            String mImageMake_OriginSrc = null; // 图片的问题的出处 来源问题
            String mPhotoUserComment_KnowledgePoint = null; // 知识点 待定 KnowLedge 知识点

            String mImageModel_HttpUrl = null; // 待定 // 图片截图的网络地址

            File imageFile; // 从该 jpg 文件读取到的 exif 信息 原文件
            String videoName; // 从 jpg 读取到 Copyright 是对应的 video 的文件名称
            String videoUrl; // video 对应的 url 这个 .mp4 结尾 前缀 待定 可能需要从外部读取
            String imageUrl; // jpg 显示的 url

            @SuppressWarnings("unchecked")
            @Override
            public String toString() {
                StringBuilder sb = new StringBuilder();

                Map.Entry<String, ArrayList<String>> entry;

                if (mEnglishChar_CategoryList_Map != null) {
                    Iterator iterator = mEnglishChar_CategoryList_Map.entrySet().iterator();
                    while (iterator.hasNext()) {
                        entry = (Map.Entry<String, ArrayList<String>>) iterator.next();

                        // 获取 名称的 首字母
                        String oneWordStr = entry.getKey(); // Map的Value // 作者名称
                        ArrayList<String> categoryNameList = entry.getValue();
                        sb.append("mapKey(" + oneWordStr + "_" + categoryNameList.size() + ")【");
                        for (int i = 0; i < categoryNameList.size(); i++) {
                            String categoryItem = categoryNameList.get(i);
                            sb.append(categoryItem + ",");
                        }
                        sb.append("】");

                    }
                }

                return "ImageName[" + imageFile.getName() + "] category[" + mImageArtist_CategoryStr + "]  video["
                        + mImageCopyright_VideoMD + "] desc[" + mImageDescription_SelfDesc + "] Make["
                        + mImageMake_OriginSrc + "] Model[" + mImageModel_HttpUrl + "] usercomment["
                        + mPhotoUserComment_KnowledgePoint + "]  videoUrl[" + videoUrl + "] imageUrl[" + imageUrl
                        + "]  mCategoryList.size=[" + mCategoryList.size() + "] Map=" + sb.toString();
            }

            void init_Artist_Category() {
                mEnglishChar_CategoryList_Map = new HashMap<String, ArrayList<String>>();
                mCategoryList = new ArrayList<String>();

                if (mImageArtist_CategoryStr != null && !mImageArtist_CategoryStr.contains("_")) {

                    mCategoryList.add(mImageArtist_CategoryStr);
                    String itemStr = mImageArtist_CategoryStr.replace("_", "").replace(" ", "").trim();

                    String Alphabet_Word = getFirstZiMu(itemStr);

                    if (mEnglishChar_CategoryList_Map.get(Alphabet_Word) == null) {
                        ArrayList<String> category_word_list = new ArrayList<String>();
                        category_word_list.add(itemStr);
                        mEnglishChar_CategoryList_Map.put(Alphabet_Word, category_word_list);
                    } else {

                        ArrayList<String> category_word_list = mEnglishChar_CategoryList_Map.get(Alphabet_Word);
                        category_word_list.add(itemStr);
                    }

                    return;
                }

                if (mImageArtist_CategoryStr != null && mImageArtist_CategoryStr.contains("_")) {

                    String[] categoryItem = mImageArtist_CategoryStr.trim().split("_");

                    for (int i = 0; i < categoryItem.length; i++) {
                        String itemStr = categoryItem[i];
                        itemStr = itemStr.replace("_", "").replace(" ", "").trim();
                        mCategoryList.add(itemStr);

                        // zukgit
                        String Alphabet_Word = getFirstZiMu(itemStr);

                        if (mEnglishChar_CategoryList_Map.get(Alphabet_Word) == null) {
                            ArrayList<String> category_word_list = new ArrayList<String>();
                            category_word_list.add(itemStr);
                            mEnglishChar_CategoryList_Map.put(Alphabet_Word, category_word_list);
                        } else {

                            ArrayList<String> category_word_list = mEnglishChar_CategoryList_Map.get(Alphabet_Word);
                            category_word_list.add(itemStr);
                        }

                    }

                }

            }

            Jpg_Exif(File curImageFile) {
                imageFile = curImageFile;
                imageUrl = image_url_prefix + curImageFile.getName();
                initExifInfo(curImageFile);
                init_Artist_Category();

            }

            void initExifInfo(File file) {

                String mImageDescription_Utf8 = null;
                String mImageMake_Utf8 = null;
                String mImageModel_Utf8 = null;
                String mImageArtist_Utf8 = null;
                String mImageCopyright_Utf8 = null;
                String mPhotoUserComment_Utf8 = null;
                int angel = 0;
                Metadata metadata;

                try {
                    metadata = JpegMetadataReader.readMetadata(file);
                    metadata.getDirectories();

                    // zukgit_directory [Exif IFD0] - Orientation = Right side, top (Rotate 90 CW)
                    for (Directory directory : metadata.getDirectories()) {
                        for (Tag tag : directory.getTags()) {
                            // 格式化输出[directory.getName()] - tag.getTagName() = tag.getDescription()
//							System.out.format("zukgit_directory  [%s] - %s = %s\n", directory.getName(), tag.getTagName(),tag.getDescription());

                            if ("Exif IFD0".equals(directory.getName())) {

                                String mImageDescription = directory.getString(ExifIFD0Directory.TAG_IMAGE_DESCRIPTION);
                                if (mImageDescription != null)
                                    mImageDescription_Utf8 = new String(mImageDescription.getBytes(), "UTF-8");

                                String mImageMake = directory.getString(ExifIFD0Directory.TAG_MAKE);
                                if (mImageMake != null)
                                    mImageMake_Utf8 = new String(mImageMake.getBytes(), "UTF-8");

                                String mImageModel = directory.getString(ExifIFD0Directory.TAG_MODEL);
                                if (mImageModel != null)
                                    mImageModel_Utf8 = new String(mImageModel.getBytes(), "UTF-8");

                                String mImageArtist = directory.getString(ExifIFD0Directory.TAG_ARTIST);
                                if (mImageArtist != null)
                                    mImageArtist_Utf8 = new String(mImageArtist.getBytes(), "UTF-8");

                                String mImageCopyright = directory.getString(ExifIFD0Directory.TAG_COPYRIGHT);
                                if (mImageCopyright != null)
                                    mImageCopyright_Utf8 = new String(mImageCopyright.getBytes(), "UTF-8");

//								System.out.println("XXmImageDescription=["+mImageDescription+"]  Utf8["+mImageDescription_Utf8+"]");
//								System.out.println("XXmImageMake=["+mImageMake+"]  Utf8["+mImageMake_Utf8+"]");
//								System.out.println("XXmImageModel=["+mImageModel+"]  Utf8["+mImageModel_Utf8+"]");
//								System.out.println("XXmImageArtist=["+mImageArtist+"]  Utf8["+mImageArtist_Utf8+"]");
//								System.out.println("XXmImageCopyright=["+mImageCopyright+"]  Utf8["+mImageCopyright_Utf8+"]");

                            }

                            if ("Exif SubIFD".equals(directory.getName())) {

                                if ("User Comment".equals(tag.getTagName())) {
                                    String mPhotoUserComment = tag.getDescription();
//							System.out.println("AZ_User_Comment=["+tag.getDescription()+"]");
                                    if (mPhotoUserComment != null)
                                        mPhotoUserComment_Utf8 = new String(mPhotoUserComment.getBytes(), "utf-8");
//							System.out.println("AZXXmPhotoUserComment=["+mPhotoUserComment+"]   mPhotoUserComment_Utf8=["+mPhotoUserComment_Utf8+"]" );

                                }

                            }
                        }

                    }

                } catch (JpegProcessingException e) {
                    e.printStackTrace();
                    System.out.println("JpegProcessingException  异常事件发生 ");
                } catch (IOException e) {
                    System.out.println("IOException  异常事件发生 ");
                    e.printStackTrace();
                }

//				String mImageArtist_CategoryStr= null;
//				String mImageCopyright_VideoMD = null;
//			    String mImageDescription_SelfDesc = null;
//
//
//			String mImageMake_Utf8 = null;     // 待定
//			String mImageModel_Utf8 = null;     // 待定
//			String mPhotoUserComment_Utf8 = null;   // 待定

                if (mImageArtist_Utf8 != null) {
                    mImageArtist_CategoryStr = clear_end_xiahua_xian(mImageArtist_Utf8);

                } else {
                    System.out.println("当前文件 [" + file.getName() + "] 没有读取到 mImageArtist_CategoryStr !! ");
                }

                if (mImageDescription_Utf8 != null) {
                    mImageDescription_SelfDesc = fixed_number_point(clear_end_xiahua_xian(mImageDescription_Utf8));

                } else {
                    System.out.println("当前文件 [" + file.getName() + "] 没有读取到 mImageDescription_SelfDesc !! ");
                }

                if (mImageCopyright_Utf8 != null) {

                    mImageCopyright_VideoMD = clear_end_xiahua_xian(mImageCopyright_Utf8);
                    videoName = mImageCopyright_VideoMD;
                    videoUrl = video_url_prefix + videoName + ".mp4";
                } else {
                    System.out.println("当前文件 [" + file.getName() + "] 没有读取到 mImageCopyright_VideoMD !! ");
                }

                if (mImageMake_Utf8 != null) {
                    this.mImageMake_OriginSrc = clear_end_xiahua_xian(mImageMake_Utf8);
                } else {
                    System.out.println("当前文件 [" + file.getName() + "] 没有读取到 mImageMake_Utf8 !! ");
                }

                if (mImageModel_Utf8 != null) {
                    this.mImageModel_HttpUrl = clear_end_xiahua_xian(mImageModel_Utf8);
                } else {
                    System.out.println("当前文件 [" + file.getName() + "] 没有读取到 mImageModel_Utf8 !! ");
                }

                if (mPhotoUserComment_Utf8 != null) {
                    this.mPhotoUserComment_KnowledgePoint = fixed_number_point(
                            clear_end_xiahua_xian(mPhotoUserComment_Utf8));
                } else {
                    System.out.println("当前文件 [" + file.getName() + "] 没有读取到 mPhotoUserComment_Utf8 !! ");
                }

            }

        }

        //
        String fixed_number_point(String rawStr) {

            String tempStr = rawStr;
            tempStr = tempStr.replace("1.", "\n1.");
            tempStr = tempStr.replace("2.", "\n2.");
            tempStr = tempStr.replace("3.", "\n3.");
            tempStr = tempStr.replace("4.", "\n4.");
            tempStr = tempStr.replace("5.", "\n5.");
            tempStr = tempStr.replace("6.", "\n6.");
            tempStr = tempStr.replace("7.", "\n7.");
            tempStr = tempStr.replace("8.", "\n8.");
            tempStr = tempStr.replace("9.", "\n9.");
            tempStr = tempStr.replace("10.", "\n10.");

            tempStr = tempStr.trim();
            if (tempStr.startsWith("\n")) {
                tempStr = tempStr.substring(1);
            }
            return tempStr;

        }

        String clear_end_xiahua_xian(String rawStr) {

            String tempStr = rawStr;
            while (tempStr.endsWith("_")) {
                tempStr = tempStr.substring(0, tempStr.length() - 1);
            }

            return tempStr;

        }

        boolean isContainInChineseCategory(ArrayList<String> mChineseCategoryList, String matchStr) {

            for (int i = 0; i < mChineseCategoryList.size(); i++) {
                String chineseStr = mChineseCategoryList.get(i);
                if (matchStr.contains(chineseStr)) {
                    return true;
                }
            }
            return false;

        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
// TODO Auto-generated method stub
            jpgFileList = getAllSubFile(curDirFile, ".jpg");

            if (jpgFileList.size() == 0) {
                System.out.println(" 当前目录 curDirFile=[" + curDirFile.getAbsolutePath() + "] 内没有 jpg文件!!  请检查后再次执行!! ");
                return null;
            }

            for (int i = 0; i < jpgFileList.size(); i++) {
//		Jpg_Exif
                File jpgFile = jpgFileList.get(i);
                Jpg_Exif jpg_exif_item = new Jpg_Exif(jpgFile);

                jpgExifList.add(jpg_exif_item);

            }

            if (jpgExifList.size() == 0) {

                System.out.println(" 当前目录 curDirFile=[" + curDirFile.getAbsolutePath() + "]  存在[" + jpgFileList.size()
                        + "]个jpg " + " 但无法正常读取到 exif 信息  请检查后再次执行!! ");

                return null;
            }

            for (int i = 0; i < jpgExifList.size(); i++) {
                Jpg_Exif jpgExifitem = jpgExifList.get(i);
                System.out.println("jpg_exif[" + i + "] = " + jpgExifitem.toString());

                if (jpgExifitem.mCategoryList.size() > 0) {

                    for (int j = 0; j < jpgExifitem.mCategoryList.size(); j++) {
                        String exif_category_in_jpg = jpgExifitem.mCategoryList.get(j);

                        if (!mCategoryItemList_In_Jpg.contains(exif_category_in_jpg)) {

                            mCategoryItemList_In_Jpg.add(exif_category_in_jpg);
                        }

                        ArrayList<Jpg_Exif> matchJpgExifArr = mCategory_JpgExifList_Map.get(exif_category_in_jpg);
                        if (matchJpgExifArr == null) {
                            matchJpgExifArr = new ArrayList<Jpg_Exif>();
                            matchJpgExifArr.add(jpgExifitem);
                            mCategory_JpgExifList_Map.put(exif_category_in_jpg, matchJpgExifArr);

                        } else {
                            if (!matchJpgExifArr.contains(jpgExifitem)) {
                                matchJpgExifArr.add(jpgExifitem);
                            }
                        }

                    }
                }

            }

            // 初始化英语字母 A-B-C-D-E....-Z 的 Category
            for (int i = 0; i < mCategoryItemList_In_Jpg.size(); i++) {
                String categoryItem = mCategoryItemList_In_Jpg.get(i);
                boolean isContainInChineseCategory = isContainInChineseCategory(Chinese_CharList, categoryItem);
                if (isContainInChineseCategory) {
                    continue;
                }
                String firstCharName = getFirstZiMu(categoryItem);
                ArrayList<String> matchCategoryList = mOneWord_CategoryArr_Map.get(firstCharName);
                if (matchCategoryList == null) {
                    matchCategoryList = new ArrayList<String>();
                    matchCategoryList.add(categoryItem);
                    mOneWord_CategoryArr_Map.put(firstCharName, matchCategoryList);

                } else {
                    if (!matchCategoryList.contains(categoryItem)) {
                        matchCategoryList.add(categoryItem);
                    }

                }
                System.out.println("category[" + (i + 1) + "] == " + firstCharName + "   " + categoryItem);
            }

            // 初始化 中文的 "结尾叹" "公式集合" "导式集合" category 的
            for (int i = 0; i < mCategoryItemList_In_Jpg.size(); i++) {
                // 排查出符合逻辑的 categoryItem xx zukgit
                String categoryItem = mCategoryItemList_In_Jpg.get(i);
                for (int j = 0; j < Chinese_CharList.size(); j++) {
                    String chineseCategory = Chinese_CharList.get(j);
                    if (categoryItem.contains(chineseCategory)) {

                        ArrayList<String> matchCategoryList = mOneWord_CategoryArr_Map.get(chineseCategory);

                        if (matchCategoryList == null) {
                            matchCategoryList = new ArrayList<String>();
                            matchCategoryList.add(categoryItem);
                            mOneWord_CategoryArr_Map.put(chineseCategory, matchCategoryList);

                        } else {
                            if (!matchCategoryList.contains(categoryItem)) {
                                matchCategoryList.add(categoryItem);
                            }

                        }

                    }

                }

            }

            ArrayList<String> mMdContentList = BuildMDContent(English_CharList, Chinese_CharList,
                    mOneWord_CategoryArr_Map, mCategory_JpgExifList_Map);

// 对 MD文件 进行分隔处理
            ArrayList<String> segerate_MdContentList = new ArrayList<String>();

            segerate_MdContentList.add("---");
            if (is_gaokao) {
                segerate_MdContentList.add("title: 高考数学学习");
                segerate_MdContentList.add("category: 学习");
                segerate_MdContentList.add("tags: Math");
                segerate_MdContentList.add("keywords: 数学 高考");
                segerate_MdContentList.add("typora-root-url: ..\\..\\");
                segerate_MdContentList
                        .add("typora-copy-images-to: ..\\..\\public\\zimage\\zschool_media\\jpg_gaokao_land");

            } else if (is_kaoyan) {
                segerate_MdContentList.add("title: 研究考试学习");
                segerate_MdContentList.add("category: 学习");
                segerate_MdContentList.add("tags: Math");
                segerate_MdContentList.add("keywords: 数学 考研");
                segerate_MdContentList.add("typora-root-url: ..\\..\\");
                segerate_MdContentList
                        .add("typora-copy-images-to: ..\\..\\public\\zimage\\zschool_media\\jpg_kaoyan_land");

                // 追加 到mMdContentList 后面的 一些信息
                ArrayList<String> appendForKaoYanList = new ArrayList<String>();

            }
            segerate_MdContentList.add("---");
            segerate_MdContentList.add("\n");

            segerate_MdContentList.add("## 简介_项式量(" + mCategory_JpgExif_Count_Rule_41 + ")");
            segerate_MdContentList.add(" * TOC");
            segerate_MdContentList.add(" {:toc}");
            segerate_MdContentList.add("\n");

            for (int i = 0; i < mMdContentList.size(); i++) {
                String contentLine = mMdContentList.get(i);
                segerate_MdContentList.add("\n" + contentLine);

            }

            writeContentToFile(G2_Temp_Text_File, segerate_MdContentList);
            NotePadOpenTargetFile(G2_Temp_Text_File.getAbsolutePath());

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        ArrayList<String> BuildMDContent(ArrayList<String> mEnglishCharList, ArrayList<String> mChineseCharList,
                                         Map<String, ArrayList<String>> xOneWord_CategoryArr_Map,
                                         Map<String, ArrayList<Jpg_Exif>> mCategory_JpgExifList_Map) {

//	StringBuilder mMDContentSB = new StringBuilder();

            ArrayList<String> mMDContentStrList = new ArrayList<String>();

            // 添加 英语 Category
            for (int i = 0; i < mEnglishCharList.size(); i++) {
                String charWord = mEnglishCharList.get(i);
                mMDContentStrList.add("## " + charWord);

                ArrayList<String> matchCategoryList = xOneWord_CategoryArr_Map.get(charWord);

                if (matchCategoryList != null) {

                    matchCategoryList.sort(new Comparator<String>() {
                        @Override
                        public int compare(String o1, String o2) {
                            return o1.compareTo(o2);
                        }

                    });

                    for (int j = 0; j < matchCategoryList.size(); j++) {
                        String categoryStrItem = matchCategoryList.get(j);

                        mMDContentStrList.add("### " + (j + 1) + "_" + categoryStrItem);
                        mCategory_JpgExif_Count_Rule_41++;
                        ArrayList<Jpg_Exif> matchExifJpgArr = mCategory_JpgExifList_Map.get(categoryStrItem);

                        if (matchExifJpgArr != null) {

                            for (int k = 0; k < matchExifJpgArr.size(); k++) {
                                Jpg_Exif jpgExif = matchExifJpgArr.get(k);

                                String httpUrl = jpgExif.mImageModel_HttpUrl;
                                String imageurl = jpgExif.imageUrl;
                                String videourl = jpgExif.videoUrl;
                                String videoName = jpgExif.videoName;
                                String knowledgeComment = jpgExif.mPhotoUserComment_KnowledgePoint;
                                String imageDescString = jpgExif.mImageDescription_SelfDesc;
                                String originBirthPlaceInfo = jpgExif.mImageMake_OriginSrc == null ? "网络"
                                        : jpgExif.mImageMake_OriginSrc;

                                // <img src="/public/zimage/tool/graphviz/digraph16.jpg">
                                // /public/zimage/zschool/kaoyan/
                                mMDContentStrList.add("<img src=\"" + imageurl + "\">");

                                mMDContentStrList.add("**涉及知识点:**  ");
                                mMDContentStrList.add("```\n" + knowledgeComment + "\n````");

                                mMDContentStrList.add("**个人解题想法思路:**  ");
                                mMDContentStrList.add("```\n" + imageDescString + "\n````");

                                mMDContentStrList.add(
                                        "**视频网络链接:**  " + "[" + httpUrl + "](" + httpUrl + "){:target=\"_blank\"}");

                                mMDContentStrList.add(
                                        "**视频本地链接:**  " + "[" + videoName + "](" + videourl + "){:target=\"_blank\"}");

                                mMDContentStrList.add("**视频链接文件MD值:**  ");
                                mMDContentStrList.add("```\n" + videoName + "\n````");
                                mMDContentStrList.add("**图片名称:**  ");
                                mMDContentStrList.add("```\n" + jpgExif.imageFile.getName() + "\n````");

                                mMDContentStrList.add("**题目源信息:**  ");
                                mMDContentStrList.add("```\n" + originBirthPlaceInfo + "\n````");

                            }

                        }

                    }

                }
            }

            // 添加 中文 Category
            for (int i = 0; i < mChineseCharList.size(); i++) {

                String ChineseCategoryWord = mChineseCharList.get(i);
                mMDContentStrList.add("## " + ChineseCategoryWord);

                if (ChineseCategoryWord.equals("结尾叹")) {

                    mMDContentStrList.add("**涉及知识点**  ");
                    mMDContentStrList.add("```\n" + "为后辈们做些能遗留的东西,莫望无前吾辈自强......" + "\n````");

                    continue;
                }

                ArrayList<String> matchCategoryList = xOneWord_CategoryArr_Map.get(ChineseCategoryWord);

                if (matchCategoryList != null) {

                    matchCategoryList.sort(new Comparator<String>() {
                        @Override
                        public int compare(String o1, String o2) {
                            return o1.compareTo(o2);
                        }

                    });

                    for (int j = 0; j < matchCategoryList.size(); j++) {
                        String categoryStrItem = matchCategoryList.get(j);

                        mMDContentStrList.add("### " + (j + 1) + "_" + categoryStrItem);
                        mCategory_JpgExif_Count_Rule_41++;
                        ArrayList<Jpg_Exif> matchExifJpgArr = mCategory_JpgExifList_Map.get(categoryStrItem);

                        if (matchExifJpgArr != null) {

                            for (int k = 0; k < matchExifJpgArr.size(); k++) {
                                Jpg_Exif jpgExif = matchExifJpgArr.get(k);

                                String httpUrl = jpgExif.mImageModel_HttpUrl;
                                String imageurl = jpgExif.imageUrl;
                                String videourl = jpgExif.videoUrl;
                                String videoName = jpgExif.videoName;
                                String knowledgeComment = jpgExif.mPhotoUserComment_KnowledgePoint;
                                String imageDescString = jpgExif.mImageDescription_SelfDesc;
                                String originBirthPlaceInfo = jpgExif.mImageMake_OriginSrc == null ? "网络"
                                        : jpgExif.mImageMake_OriginSrc;

                                // <img src="/public/zimage/tool/graphviz/digraph16.jpg">
                                // /public/zimage/zschool/kaoyan/
                                mMDContentStrList.add("<img src=\"" + imageurl + "\">");
                                /*
                                 * mMDContentStrList.add("**涉及知识点:**  "); mMDContentStrList.add("```\n" +
                                 * knowledgeComment + "\n````");
                                 *
                                 * mMDContentStrList.add("**个人解题想法思路:**  "); mMDContentStrList.add("```\n" +
                                 * imageDescString + "\n````");
                                 *
                                 * mMDContentStrList.add( "**视频网络链接:**  " + "[" + httpUrl + "](" + httpUrl +
                                 * "){:target=\"_blank\"}");
                                 *
                                 * mMDContentStrList.add( "**视频本地链接:**  " + "[" + videoName + "](" + videourl +
                                 * "){:target=\"_blank\"}");
                                 *
                                 * mMDContentStrList.add("**视频链接文件MD值:**  "); mMDContentStrList.add("```\n" +
                                 * videoName + "\n````"); mMDContentStrList.add("**图片名称:**  ");
                                 * mMDContentStrList.add("```\n" + jpgExif.imageFile.getName() + "\n````");
                                 *
                                 * mMDContentStrList.add("**题目源信息:**  "); mMDContentStrList.add("```\n" +
                                 * originBirthPlaceInfo + "\n````");
                                 */

                            }

                        }

                    }

                }
            }

            System.out.println(" ============== 打印 MD 内容  Begin ============== ");
            for (int i = 0; i < mMDContentStrList.size(); i++) {
                String oneLine = mMDContentStrList.get(i);
                System.out.println(oneLine);
            }

            return mMDContentStrList;
        }

        @Override
        boolean allowEmptyDirFileList() {
            // TODO Auto-generated method stub
            return true;
        }

        @Override
        String simpleDesc() {

            return "\n" + Cur_Bat_Name + " #_" + rule_index
                    + "  ###  默认生成 考研类型的.md 读取当前文件夹下的jpg文件的exif信息 artist  Desc  Make  Mode  Copyright UserComment 并以此生成 .md文件  "
                    + "\n" + Cur_Bat_Name + " #_" + rule_index
                    + " kaoyan_true  ###  生成考研类型的md  读取当前文件夹下的jpg文件的exif信息 artist  Desc  Make  Mode  Copyright UserComment 并以此生成 .md文件 \n"
                    + "\n" + Cur_Bat_Name + " #_" + rule_index
                    + " gaokao_true   ###  生成高考类型的md  读取当前文件夹下的jpg文件的exif信息 artist  Desc  Make  Mode  Copyright UserComment 并以此生成 .md文件 \n";

        }

    }

    class Monitor_Browser_ForWindows_Rule_40 extends Basic_Rule {
        // 1-----详细 下载路径 2----详细下载路径 3-----详细下载路径
        Map<String, Integer> mDisplayUrl_Index_Map;

        File ImageDownloadDir;
        // 详细下载路径-----路径中要下载的内容
        HashMap<String, ArrayList<String>> mDisplayUrl_ImageUrlList_Map;

        // 所有的下载路径 用于避免重复下载
        ArrayList<String> allDownloadedUrlList;

        ChromeDriver mChromeDriver;

        // ------------- 输入类型A -------------
        String mainurl_InputValue; // 查询的主页面
        ArrayList<String> mCategoryNameList_InputValue; // 查询的分类名称

        // ------------- 输入类型B -------------
        int mPageSize_InputValue; // 查询页数
        String beginurl_InputValue; // 查询页数
        ArrayList<String> keynameList_InputValue; // category页面关键词

        @Override
        boolean allowEmptyDirFileList() {
            // TODO Auto-generated method stub
            return true;
        }

        Monitor_Browser_ForWindows_Rule_40() {
            super("#", 40, 3); // 不包括
            allDownloadedUrlList = new ArrayList<String>();
            mDisplayUrl_ImageUrlList_Map = new HashMap<String, ArrayList<String>>(5000);
            mDisplayUrl_Index_Map = Maps.newLinkedHashMap();
            mCategoryNameList_InputValue = new ArrayList<String>();
            keynameList_InputValue = new ArrayList<String>();
            mPageSize_InputValue = 10; // 默认是10 页
        }

        // mainurl_https://www.52pojie.cn
        // categoryname_还洗论坛AAAB_CategoryABB

        // pagesize_100
        // beginurl_https://www.52pojie.cn/forum-2-1.html
        // keyname_你好我好_大家好_都不好

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // TODO Auto-generated method stub
            ImageDownloadDir = new File(
                    curDirPath + File.separator + "Rule" + rule_index + "_Download_" + getTimeStamp());

            ImageDownloadDir.mkdirs();
            ImageDownloadDir.mkdirs();

            for (int i = 0; i < inputParamList.size(); i++) {
                String inputStrItem = inputParamList.get(i);
                if (inputStrItem.startsWith("mainurl_")) {
                    String mainUrl = inputStrItem.replace("mainurl_", "").trim();
                    mainurl_InputValue = mainUrl;

                } else if (inputStrItem.startsWith("categoryname_")) {

                    String categoryListStr = inputStrItem.replace("categoryname_", "").trim();

                    String[] categoryNameArr = categoryListStr.split("_");
                    if (categoryNameArr == null) {
                        continue;

                    }
                    for (int j = 0; j < categoryNameArr.length; j++) {
                        mCategoryNameList_InputValue.add(categoryNameArr[j].trim());
                    }
                } else if (inputStrItem.startsWith("beginurl_")) {
                    String beginurl = inputStrItem.replace("beginurl_", "").trim();
                    beginurl_InputValue = beginurl;

                } else if (inputStrItem.startsWith("pagesize_")) {
                    String pagesizeStr = inputStrItem.replace("pagesize_", "").trim();
                    if (isNumeric(pagesizeStr)) {
                        mPageSize_InputValue = Integer.parseInt(pagesizeStr);
                    }

                } else if (inputStrItem.startsWith("keyname_")) {

                    String keynameListStr = inputStrItem.replace("keyname_", "").trim();

                    String[] keyNameArr = keynameListStr.split("_");
                    if (keyNameArr == null) {
                        continue;

                    }
                    for (int j = 0; j < keyNameArr.length; j++) {
                        keynameList_InputValue.add(keyNameArr[j].trim());
                    }
                }

            }
            System.out.println("输入参数详情如下:\n");
            System.out.println("输入类型A:");
            System.out.println("mainurl_InputValue=[" + mainurl_InputValue + "]");
            if (mCategoryNameList_InputValue.size() > 0) {
                for (int i = 0; i < mCategoryNameList_InputValue.size(); i++) {
                    System.out.println(
                            "mCategoryNameList_InputValue[" + i + "] = " + mCategoryNameList_InputValue.get(i));
                }
            } else {
                System.out.println("mCategoryNameList_InputValue=[ null ]");
            }
            if (keynameList_InputValue.size() > 0) {
                for (int i = 0; i < keynameList_InputValue.size(); i++) {
                    System.out.println("keynameList_InputValue[" + i + "] = " + keynameList_InputValue.get(i));
                }
            } else {
                System.out.println("keynameList_InputValue=[ null ]");
            }

            System.out.println("pagesize=[" + mPageSize_InputValue + "]");

            System.out.println("输入类型B:");

            System.out.println("pagesize=[" + mPageSize_InputValue + "]");
            System.out.println("beginurl=[" + beginurl_InputValue + "]");

            if (keynameList_InputValue.size() > 0) {
                for (int i = 0; i < keynameList_InputValue.size(); i++) {
                    System.out.println("keynameList_InputValue[" + i + "] = " + keynameList_InputValue.get(i));
                }
            } else {
                System.out.println("keynameList_InputValue=[ null ]");
            }

            if (mainurl_InputValue == null && keynameList_InputValue.size() == 0 && beginurl_InputValue == null) {

                System.out.println("当前输入的 mainurl  beginurl keynameList_InputValue 为 空! 请检查输入参数!!");
                return false;

            }

            if (!ImageDownloadDir.exists()) {
                System.out
                        .println("当前下载文件的保存目录 不存在 程序无法执行下去:  ImageDownloadDir = " + ImageDownloadDir.getAbsolutePath());
                return false;
            }

            File ChromeDriverFile = new File(zbinPath + File.separator + "G2_chromedriver_v91.exe");

            System.setProperty("webdriver.chrome.driver", ChromeDriverFile.getAbsolutePath());

            ChromeOptions CUR_CHROME_OPTIONS = new ChromeOptions();
            // 驱动位置
            CUR_CHROME_OPTIONS.addArguments("--start-fullscreen");

            CUR_CHROME_OPTIONS.setExperimentalOption("excludeSwitches", Collections.singletonList("enable-automation"));

            mChromeDriver = new ChromeDriver(CUR_CHROME_OPTIONS);

            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        String simpleDesc() {

            return "\n" + Cur_Bat_Name + " #_" + rule_index
                    + "  mainurl_https://www.52pojie.cn/  categoryname_『原创发布区』 keyname_小工具  pagesize_5  ### 对网站进行抓取资源到本地  "
                    + "\n" + Cur_Bat_Name + " #_" + rule_index
                    + "  beginurl_https://www.douban.com/group/explore/culture    keyname_水  pagesize_3  ### 对网站进行抓取资源到本地   \n";

        }

        void TestOperationBrowser() {

            ArrayList<RootUrl_A> mSearchWebList = new ArrayList<RootUrl_A>();
            RootUrl_A pojie_52_A = new RootUrl_A(mainurl_InputValue);

            if (mCategoryNameList_InputValue.size() != 0) {
                for (int i = 0; i < mCategoryNameList_InputValue.size(); i++) {
                    String catetegoryName = mCategoryNameList_InputValue.get(i);
                    if ("".equals(catetegoryName)) {
                        continue;
                    }
                    CategoryUrl_B category_B = new CategoryUrl_B(catetegoryName);
                    pojie_52_A.addCategory(category_B);
                    category_B.searchPageSize = mPageSize_InputValue;
                    category_B.beginCategoryUrl = beginurl_InputValue;

                    for (int j = 0; j < keynameList_InputValue.size(); j++) {
                        String keyname = keynameList_InputValue.get(j);
                        if ("".equals(keyname)) {
                            continue;
                        }

                        category_B.addKeyWord(keyname);
                    }
                }

            } else { // 没有输入 mCategoryNameList_InputValue
                if (mainurl_InputValue == null) {
                    pojie_52_A.mRootUrl = beginurl_InputValue;
                }

                CategoryUrl_B category_B = new CategoryUrl_B(beginurl_InputValue, mPageSize_InputValue);
                pojie_52_A.addCategory(category_B);
                for (int j = 0; j < keynameList_InputValue.size(); j++) {
                    String keyname = keynameList_InputValue.get(j);
                    if ("".equals(keyname)) {
                        continue;
                    }

                    category_B.addKeyWord(keyname);
                }

            }

            System.out.println("pojie_52_A.mCategoryUrlList.size() = " + pojie_52_A.mCategoryUrlList.size());

            mSearchWebList.add(pojie_52_A);

            for (int i = 0; i < mSearchWebList.size(); i++) {
                RootUrl_A rootItem = mSearchWebList.get(i);
                BrowserOperation_WithRootUrl(rootItem);
            }

//	System.out.println("mainPageHtmlStr = \n"+ mainPageHtmlStr);

        }

        @SuppressWarnings("unchecked")
        void ShowDisplayUrl() {

            ArrayList<String> urlLog = new ArrayList<String>();

            Map.Entry<String, Integer> entry;

            if (mDisplayUrl_Index_Map != null) {
                Iterator iterator = mDisplayUrl_Index_Map.entrySet().iterator();
                while (iterator.hasNext()) {
                    entry = (Map.Entry<String, Integer>) iterator.next();

                    // 获取 名称的 首字母
                    String url = entry.getKey(); // Map的Value // 作者名称
                    Integer index = entry.getValue();
                    urlLog.add("index[" + index + "]  url=[ " + url + " ]");
                }
            }

            if (urlLog.size() > 0) {

                String txtLogFileAbsPath = ImageDownloadDir.getAbsolutePath() + File.separator + "0_url.txt";
                File txtLogFile = new File(txtLogFileAbsPath);

                System.out.println("____________ DisplayUrlList Begin ____________ ");
                for (int i = 0; i < urlLog.size(); i++) {
                    String oneLine = urlLog.get(i);
                    System.out.println(oneLine);
                }
                System.out.println("____________ DisplayUrlList End ____________ ");
                urlLog.sort(mStringComparion);

                writeContentToFile(txtLogFile, urlLog);
                System.out.println("写入Log信息到文件:  txtLogFile=" + txtLogFile.getAbsolutePath());
            } else {
                System.out.println("当前没有打开过 DisplayUrl ");
            }

        }

        void BrowserOperation_WithRootUrl(RootUrl_A rootUrl) {

            String mMainUrl = rootUrl.mRootUrl;
            String mainPageHtmlStr = null;
            File ChromeDriverFile = new File(zbinPath + File.separator + "G2_chromedriver_v91.exe");

            System.setProperty("webdriver.chrome.driver", ChromeDriverFile.getAbsolutePath());

//			ChromeOptions CUR_CHROME_OPTIONS = new ChromeOptions();
//			// 驱动位置
//			CUR_CHROME_OPTIONS.addArguments("--start-fullscreen");
//			CUR_CHROME_OPTIONS.setExperimentalOption("excludeSwitches", Collections.singletonList("enable-automation"));

//			ChromeDriver driver = new ChromeDriver(CUR_CHROME_OPTIONS);

            ChromeDriver driver = mChromeDriver;
            int loop_index = 0;
            try {
                long waitTime = 2000;
                long timeout = 15_000;

                driver.get(mMainUrl);
                String title = driver.getTitle();
                System.out.printf("loop_index[" + loop_index + "] = " + title);

                System.out.printf("A now accesss %s \n", driver.getCurrentUrl());

//				 long waitTime = Double.valueOf(Math.max(3, Math.random() * 5) * 1000).longValue();
                TimeUnit.MILLISECONDS.sleep(waitTime);

                // 循环下拉，直到全部加载完成或者超时
                do {
                    new Actions(driver).sendKeys(Keys.END).perform();
                    TimeUnit.MILLISECONDS.sleep(waitTime);

                    timeout -= waitTime;
                    loop_index++;
                } while (!driver.getPageSource().contains("已经到底部，没有新的内容啦") && timeout > 0);
                System.out.println("BrowserOperation_WithRootUrl 已经到底部，没有新的内容啦");
                rootUrl.mHtmlStr = driver.getPageSource();
            } catch (Exception e) {
                // TODO: handle exception
                System.out.println("获取网页源码的时候出错  mMainUrl = " + mMainUrl);
                e.printStackTrace();

            }

            int next_index = 1;

            if (rootUrl.mHtmlStr != null) {
                System.out.println("rootUrl.mCategoryUrlList.size() = " + rootUrl.mCategoryUrlList.size());

                for (int i = 0; i < rootUrl.mCategoryUrlList.size(); i++) {
                    CategoryUrl_B categoryValueB = rootUrl.mCategoryUrlList.get(i);
//					String keyName =  categoryValueB.mCategoryKeyName;
                    ArrayList<String> keyNameList = categoryValueB.mKeyWordList;

                    String mCategoryKeyName = rootUrl.mCategoryUrlList.get(i).mCategoryKeyName;
                    String begin_categury_url = null;

                    // <a href="forum-2-1.html" style="color: #F30012;">『原创发布区』</a>
                    // 从 mHtmlStr 代码的 所有的 <a> 标签的 text 中找到 包含 keyName 的 那个 a 连接的 href属性
                    if (mCategoryKeyName != null && !"".equals(mCategoryKeyName)) {
                        begin_categury_url = calcul_categoryurl_from_html_RoouUrlA(rootUrl, mCategoryKeyName);
                        System.out.println("getCategotyUrl   begin_categury_url=" + begin_categury_url
                                + "   mCategoryKeyName=" + mCategoryKeyName);
                    } else {
                        begin_categury_url = rootUrl.getCategoryList().get(i).beginCategoryUrl;
                        System.out.println("DefineCategotyUrl  begin_categury_url = " + begin_categury_url
                                + "  mCategoryKeyName=" + mCategoryKeyName);
                    }

                    String a_href = begin_categury_url;

                    System.out.println("keyName[" + mCategoryKeyName + "]  a_href[" + a_href + "]");

                    if (a_href != null) {
//							categoryValueB.mCategoryUrl = a_href;
                        // a_href 分类的主页面的 url
                        categoryValueB.beginCategoryUrl = a_href; // 搜索到的 url 作为 默认的 起始 url

                        if (!categoryValueB.mCategoryPageUrlList.contains(a_href)) {

                            categoryValueB.mCategoryPageUrlList.add(a_href);
                            BrowserOperation_WithCategoryUrl(rootUrl, categoryValueB, a_href);

                        }
                    }

                    while (categoryValueB.nextPageUrl != null
                            && categoryValueB.nextPageUrl.equals(categoryValueB.mCategoryPageUrlList
                            .get(categoryValueB.mCategoryPageUrlList.size() - 1))
                            && categoryValueB.mCategoryPageUrlList.size() <= categoryValueB.searchPageSize) {
                        System.out.println("nextPageUrl[" + categoryValueB.nextPageUrl + "]  next_index[" + next_index
                                + "]   categoryValueB.mCategoryPageUrlList.size()["
                                + categoryValueB.mCategoryPageUrlList.size() + "]");
                        BrowserOperation_WithCategoryUrl(rootUrl, categoryValueB, categoryValueB.nextPageUrl);
                        next_index++;
                    }

                }

            } else {
                System.out.println("rootUrl.mHtmlStr  ==== null ");
            }

        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {
            // TODO Auto-generated method stub

            TestOperationBrowser();
            ShowDisplayUrl();

            if (mChromeDriver != null) {
                mChromeDriver.close();
            }
            System.out.println("════════════════════ Rule_" + rule_index + "  Game Over!! ════════════════════");

            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        class RootUrl_A {
            String mRootUrl; // 主目录地址
            String mHtmlStr; // 主目录的页面代码
            ArrayList<CategoryUrl_B> mCategoryUrlList; // 分类目录

            RootUrl_A(String rootUrl) {
                mRootUrl = rootUrl;
                mCategoryUrlList = new ArrayList<CategoryUrl_B>();

            }

            ArrayList<CategoryUrl_B> getCategoryList() {
                return mCategoryUrlList;
            }

            void addCategory(CategoryUrl_B categort) {
                mCategoryUrlList.add(categort);
            }

        }

        class CategoryUrl_B {
            String mCategoryKeyName; // 分类url的名称
            boolean isPageUrlInit; // PageUrl 是否已经完成 搜索 页面 对应的 url
            ArrayList<String> mCategoryPageUrlList; // category源码的url的路径的集合
            String nextPageUrl; // 下一页的地址
            int searchPageSize; // 需要搜索的页面的数量
            String beginCategoryUrl; // 起始的搜索页面

//			String mCategoryUrl_FirstPage; // 分类url的地址  分类首页地址
//			ArrayList<DisplayUrl_C> mDisplayUrlList_FirstPage;  // 展示的详细的地址
//			String mHtmlStr_FirstPage;

            ArrayList<String> mKeyWordList; // 要搜索的 关键词 列表

            Map<String, ArrayList<DisplayUrl_C>> mPageUrl_DisplayUrlList_Map; // 页面url--该页详情的url列表对应的map
            Map<String, String> mPageUrl_HtmlStr_Map; // 对应category 第一页的源码 第二页的源码 第三页的源码.....

            CategoryUrl_B(String beginUrl, int pageSize) {
                mCategoryKeyName = "";
                mPageUrl_DisplayUrlList_Map = Maps.newConcurrentMap();
                mPageUrl_HtmlStr_Map = Maps.newConcurrentMap();
                mCategoryPageUrlList = new ArrayList<String>();
                mKeyWordList = new ArrayList<String>();
                searchPageSize = pageSize;
                beginCategoryUrl = beginUrl;

            }

            CategoryUrl_B(String keyName) {
                mCategoryKeyName = keyName;
                mPageUrl_DisplayUrlList_Map = Maps.newConcurrentMap();
                mPageUrl_HtmlStr_Map = Maps.newConcurrentMap();
                mCategoryPageUrlList = new ArrayList<String>();
                mKeyWordList = new ArrayList<String>();
                searchPageSize = 10;

            }

            void addKeyWord(String keyWord) {
                if (!mKeyWordList.contains(keyWord)) {
                    mKeyWordList.add(keyWord);
                }

            }

            void addDisPlayUrl(String pageurl, DisplayUrl_C displayUrl) {
                if (mPageUrl_DisplayUrlList_Map.get(pageurl) == null) {
                    ArrayList<DisplayUrl_C> displayUrl_C_item = new ArrayList<DisplayUrl_C>();
                    displayUrl_C_item.add(displayUrl);
                    mPageUrl_DisplayUrlList_Map.put(pageurl, displayUrl_C_item);
                } else {

                    ArrayList<DisplayUrl_C> displayUrl_C_item = mPageUrl_DisplayUrlList_Map.get(pageurl);
                    displayUrl_C_item.add(displayUrl);
                }

            }

        }

        class DisplayUrl_C {
            String mHtmlStr;
            String mDisplayName; // 需要在 Category 中 过滤显示的 关键字
            ArrayList<String> mDownloadUrlList;

            DisplayUrl_C(String keyName) {
                mDisplayName = keyName;
                mDownloadUrlList = new ArrayList<String>();
            }

        }

        void BrowserOperation_WithCategoryUrl(RootUrl_A rootUrl_A, CategoryUrl_B categoryUrl_B,
                                              String href_categoryUrl) {

            String firstPageHtml_InCategory = null;
//			for (int i = 0; i < categoryUrl_B.mKeyWordList.size(); i++) {
//				String keyword_InPage = categoryUrl_B.mKeyWordList.get(i);

            String mCategoryPageHtmlStr = null;
            File ChromeDriverFile = new File(zbinPath + File.separator + "G2_chromedriver_v91.exe");

//				System.setProperty("webdriver.chrome.driver", ChromeDriverFile.getAbsolutePath());
//
//
//				ChromeOptions CUR_CHROME_OPTIONS = new ChromeOptions();
//				// 驱动位置
//				ChromeDriver driver = new ChromeDriver(CUR_CHROME_OPTIONS);

            ChromeDriver driver = mChromeDriver;

            int loop_index = 0;
            try {
                long waitTime = 2000;
                long timeout = 15_000;

                driver.get(href_categoryUrl);
                String title = driver.getTitle();
                System.out.printf("loop_index[" + loop_index + "] = " + title);

                System.out.printf("A now accesss %s \n", driver.getCurrentUrl());

//					 long waitTime = Double.valueOf(Math.max(3, Math.random() * 5) * 1000).longValue();
                TimeUnit.MILLISECONDS.sleep(waitTime);

                // 循环下拉，直到全部加载完成或者超时
                do {
                    new Actions(driver).sendKeys(Keys.END).perform();
                    TimeUnit.MILLISECONDS.sleep(waitTime);

                    timeout -= waitTime;
                    loop_index++;
                } while (!driver.getPageSource().contains("已经到底部，没有新的内容啦") && timeout > 0);
                System.out.println("BrowserOperation_WithCategoryUrl 已经到底部，没有新的内容啦");
                String pageHtmlStr = driver.getPageSource();
                categoryUrl_B.mPageUrl_HtmlStr_Map.put(href_categoryUrl, pageHtmlStr);
                firstPageHtml_InCategory = pageHtmlStr; // 保存该页的内容 推到出第二页的 url
            } catch (Exception e) {
                // TODO: handle exception
                System.out.println("获取网页源码的时候出错  href_categoryUrl = " + href_categoryUrl);
                e.printStackTrace();

            } finally {
//					driver.close();

            }

            if (!categoryUrl_B.isPageUrlInit) {

                initCategoryPageUrl(rootUrl_A, categoryUrl_B, firstPageHtml_InCategory);
            }

            if (categoryUrl_B.mPageUrl_HtmlStr_Map.get(href_categoryUrl) != null) {

                System.out.println("categoryUrl_B.mKeyWordList.size() = " + categoryUrl_B.mKeyWordList.size());
                for (int i = 0; i < categoryUrl_B.mKeyWordList.size(); i++) {

                    String displayKeyName = categoryUrl_B.mKeyWordList.get(i);
                    DisplayUrl_C displayUrl_C = new DisplayUrl_C(displayKeyName);
//						String displayKeyName = displayUrl.mDisplayName;
                    System.out.println("displayKeyName-A = " + displayKeyName);
                    ArrayList<String> a_href_Display_UrlList = calcul_categoryurl_from_html_CategoryB(rootUrl_A,
                            categoryUrl_B, displayKeyName, firstPageHtml_InCategory);
                    System.out.println("displayKeyName-B = " + displayKeyName + "  a_href_Display_UrlList=="
                            + a_href_Display_UrlList);

                    if (a_href_Display_UrlList == null) {
                        continue;
                    }
                    System.out.println("displayKeyName-C = " + displayKeyName);
                    displayUrl_C.mDownloadUrlList.addAll(a_href_Display_UrlList);
                    System.out.println("displayKeyName-D = " + displayKeyName
                            + "  displayUrl_C.mDownloadUrlList.size()=" + displayUrl_C.mDownloadUrlList.size());

                    for (int j = 0; j < a_href_Display_UrlList.size(); j++) {
                        String href_url = a_href_Display_UrlList.get(j);
                        System.out.println("Catagery[" + categoryUrl_B.mCategoryKeyName + "]  DisplayUrlIndex[" + i
                                + "] DisplyUrlCount[" + categoryUrl_B.mKeyWordList.size() + "]  A[" + j + "]  ACount["
                                + a_href_Display_UrlList.size() + "] href=" + href_url);

                        // 分析 详细 download show 内容url中的
                        // href=https://www.52pojie.cn/thread-1467500-1-1.html 对应的页面

                        TryAnalysisHrefForDisplayUrl(rootUrl_A, categoryUrl_B, displayUrl_C, href_url);
                    }

                }

            } else {
                System.out.println("categoryUrl_B.mPageUrl_HtmlStr_Map.get(href_categoryUrl)  === null   没有解析到html源码?");

            }
//			}

        }

        boolean isInnerHtmlContainNextTip(String innerHtml, ArrayList<String> nextUrlTipList) {
            boolean containFlag = false;
            for (int i = 0; i < nextUrlTipList.size(); i++) {
                String tipitem = nextUrlTipList.get(i);

                if (innerHtml.contains(tipitem)) {
                    return true;
                }

            }

            return containFlag;

        }

        // 从首页中 推导 出 第二页 第三页的 地址
        void initCategoryPageUrl(RootUrl_A rootUrl_A, CategoryUrl_B categoryUrl_B, String firstPageHtml) {

            org.jsoup.nodes.Document curDocument = Jsoup.parse(firstPageHtml);

            String rawHtmlStr = curDocument.html();
            ArrayList<String> nextUrlTipList = new ArrayList<String>();
            nextUrlTipList.add("下一页");
            nextUrlTipList.add("后页");
            nextUrlTipList.add("下页");
            Elements mElements = curDocument.getElementsByTag("a");

            if (isInnerHtmlContainNextTip(rawHtmlStr, nextUrlTipList)) {

//			Elements  mElements =  curDocument.select("a[href]");
// a class="bm_h" href="javascript:;" rel="forum.php?mod=forumdisplay&fid=2&page=3" curpage="2" id="autopbn" totalpage="204" picstyle="0" forumdefstyle="">下一页 &raquo;</a>
// <a href="forum-2-3.html" class="nxt">下一页</a>

                if (mElements != null && mElements.size() > 0) {

                    System.out.println("a[href] mElements.size()  = " + mElements.size());
                    Iterator<org.jsoup.nodes.Element> nextpage_element_iterator = mElements.iterator();
                    while (nextpage_element_iterator.hasNext()) {
                        org.jsoup.nodes.Element curElement = nextpage_element_iterator.next();
                        String innerHtml = curElement.html();
                        String href = curElement.attr("href");
                        System.out.println("nexttip_innerHtml = " + innerHtml + "   href[" + href + "]");
                        if (isInnerHtmlContainNextTip(innerHtml, nextUrlTipList)) {

                            if (href == null || "".equals(href.trim()) || href.contains("javascript")) {
                                continue;
                            }

                            if (!href.startsWith("http")) {
                                String fixed_href = rootUrl_A.mRootUrl + "/" + href;
                                fixed_href = fixed_href.replace("//", "/");
                                if (!categoryUrl_B.mCategoryPageUrlList.contains(fixed_href)) {
                                    categoryUrl_B.nextPageUrl = fixed_href;
                                    categoryUrl_B.mCategoryPageUrlList.add(fixed_href);
                                    System.out.println("a[href]_Next_Tip  nextPageUrl=[" + fixed_href
                                            + "]  innerHtml = " + innerHtml + "   href[" + href + "]");

                                    return;
                                }

                            }

                        }

                    }

                }

            } else { // 当前 页面 并不包括 下一页 下页 等 标签

                // <a> 数字 <a> 的 标签的 url的 集合
                ArrayList<String> digital_inner_linkA_hrefList = new ArrayList<String>();

                // 当前已经保存了的 url 列表的 集合 如果不再里面 那么就 加入
                ArrayList<String> curPageUrlList = categoryUrl_B.mCategoryPageUrlList;
                if (mElements != null && mElements.size() > 0) {
                    System.out.println("a[href]_No_Next_Tip mElements.size()  = " + mElements.size());
                    Iterator<org.jsoup.nodes.Element> nextpage_element_iterator = mElements.iterator();
                    while (nextpage_element_iterator.hasNext()) {
                        org.jsoup.nodes.Element curElement = nextpage_element_iterator.next();
                        String innerHtml = curElement.html();
                        String href = curElement.attr("href");
                        System.out.println("a[href]_No_Next_Tip  innerHtml = " + innerHtml + "   href[" + href + "]");
                        if (isNumeric(innerHtml)) {

                            if (href == null || "".equals(href.trim()) || href.contains("javascript")) {
                                continue;
                            }

                            if (!href.startsWith("http")) {
                                String fixed_href = rootUrl_A.mRootUrl + "/" + href;
                                fixed_href = fixed_href.replace("//", "/");
                                if (!categoryUrl_B.mCategoryPageUrlList.contains(fixed_href)) {
                                    categoryUrl_B.nextPageUrl = fixed_href;
                                    categoryUrl_B.mCategoryPageUrlList.add(fixed_href);
                                    System.out.println("a[href]_No_Next_Tip  nextPageUrl=[" + fixed_href
                                            + "]  innerHtml = " + innerHtml + "   href[" + href + "]");

                                    return;
                                }

                            }

                        }

                    }

                }

            }

        }

        void TryAnalysisHrefForDisplayUrl(RootUrl_A rootUrl_A, CategoryUrl_B categpryUrl_B, DisplayUrl_C displayUrl_C,
                                          String hrefUrl) {

            // 1_1_kcafalm.jpg 第一个详情页面的第1个照片 第一个1 一定对应了一个详情的地址
            // 1_2_xafafma.jpg
            // 打开 对应的 a href 获取 源码
            String detailContentHtmlCode = getHtmlSource(hrefUrl);
            if (detailContentHtmlCode == null) {
                System.out.println("当前内容详情页面 中的 hrefUrl= " + hrefUrl + " 解析出来的源文件为空!! ");
                return;
            }
            org.jsoup.nodes.Document curDocument = Jsoup.parse(detailContentHtmlCode);

//		Elements  mElements = 	curDocument.getElementsByTag("img");
            Elements mElements = curDocument.select("img[src]");

            if (mElements != null && mElements.size() > 0) {

                System.out.println("img[src] mElements.size()  = " + mElements.size());
                Iterator<org.jsoup.nodes.Element> element_iterator = mElements.iterator();
                int index_image_In_Detailurl = 1;
                while (element_iterator.hasNext()) {
                    org.jsoup.nodes.Element curElement = element_iterator.next();
                    String src = curElement.attr("abs:src");
                    System.out.println("img[" + index_image_In_Detailurl + "] all[" + mElements.size() + "] src=[ "
                            + src + " ] href=[ " + hrefUrl + " ]");

                    if (!allDownloadedUrlList.contains(src)) { // 避免 重复下载 url

                        allDownloadedUrlList.add(src); // 怎么实现 url 和 它的 下载的页面 对应?
                        addImgSrcToDetailMap(hrefUrl, src);
                        index_image_In_Detailurl++;
                    }

                }

                // 开始执行下载操作
                TryDownloadImageOperation(hrefUrl);
            }

        }

        int mDisplayUrl_ID = 0;

        int getNextDisplayUrl_ID() {
            mDisplayUrl_ID++;
            return mDisplayUrl_ID;

        }

        // 开始执行下载操作
        void TryDownloadImageOperation(String hrefUrl) {
            ArrayList<String> mImageUrlList = mDisplayUrl_ImageUrlList_Map.get(hrefUrl);
            if (mImageUrlList == null || mImageUrlList.size() == 0) {
                System.out.println("当前 详情页面 url=" + hrefUrl + "   解析到的图片资源数量 为0 !!! ");
                return;
            }

            int urlIndex = -1;
            if (mDisplayUrl_Index_Map.containsValue(hrefUrl)) {
                urlIndex = (Integer) mDisplayUrl_Index_Map.get(hrefUrl);
            } else {
                int DisplayID = getNextDisplayUrl_ID();
                mDisplayUrl_Index_Map.put(hrefUrl, DisplayID);
                urlIndex = DisplayID;
            }
            System.out.println("hrefUrl[" + hrefUrl + "]  mImageUrlList.size()=" + mImageUrlList.size());

            for (int i = 0; i < mImageUrlList.size(); i++) {
                String urlItem = mImageUrlList.get(i);
                int imageIndex_InDetail = i;
                int Detail_Index = urlIndex;
                String imageName_Pre = Detail_Index + "_" + imageIndex_InDetail + "_";
                String urlType = urlItem.substring(urlItem.lastIndexOf("."));
                if (urlType == null) {
                    urlType = ".jpg"; // 默认为 .jpg
                }
                String fileName_NoType_ABS = ImageDownloadDir.getAbsolutePath() + File.separator + imageName_Pre
                        + getTimeStamp() + urlType;
                fileName_NoType_ABS = fileName_NoType_ABS.replace("?", "").replace("&", "");

                File imageFile = new File(fileName_NoType_ABS);
                downloadOperation(urlItem, imageFile, 1);

            }

        }

        // 视频的保存 目录 不能是 当前文件 否则 就会执行 同步操作 影响网速 repeatTimes 下载失败重复的次数
        @SuppressWarnings("unchecked")
        public void downloadOperation(String httpUrl, File localFile, int repeatTimes) {
            String fileAddress = localFile.getAbsolutePath();
//			String fileAddress = mDownloadedMonthDir.getAbsolutePath() + File.separator
//					+ (source == null || "".equals(source) ? "" : source + "_") + (fileNameNoPoint.replace(" ", ""))
//					+ "_" + index + "_" + getTimeStamp() + ".mp4";

            System.out.println("下载操作:[ " + httpUrl + " ]   \n fileAddress:" + fileAddress);
            int byteRead;
            try {
                URL url = new URL(httpUrl);
                // 获取链接
                URLConnection conn = url.openConnection();
                // 输入流
                InputStream inStream = conn.getInputStream();
                // 封装一个保存文件的路径对象
                File fileSavePath = new File(fileAddress);
                // 注:如果保存文件夹不存在,那么则创建该文件夹
                File fileParent = fileSavePath.getParentFile();
                if (!fileParent.exists()) {
                    fileParent.mkdirs();
                }
                // 写入文件
                FileOutputStream fs = new FileOutputStream(fileSavePath);
                byte[] buffer = new byte[1024];
                while ((byteRead = inStream.read(buffer)) != -1) {
                    fs.write(buffer, 0, byteRead);
                }
                inStream.close();
                fs.close();
                System.out.println("\n-----url[ " + httpUrl + " ]下载完成-----\n" + fileSavePath.getAbsolutePath());

            } catch (FileNotFoundException e) {
                System.out.println("ZFileNotFoundException==" + e.getMessage());
            } catch (IOException e) {
                System.out.println("ZIOException:" + e.getMessage());
                if (repeatTimes <= 3) {
                    downloadOperation(httpUrl, localFile, repeatTimes + 1); // 再次执行 下载操作

                }
            }
        }

        void addImgSrcToDetailMap(String keyurl, String valueUrl) {
            ArrayList<String> mImageUrlList = mDisplayUrl_ImageUrlList_Map.get(keyurl);
            if (mImageUrlList == null) {
                ArrayList<String> mImageUrlList_filled = new ArrayList<String>();
                mImageUrlList_filled.add(valueUrl);
                mDisplayUrl_ImageUrlList_Map.put(keyurl, mImageUrlList_filled);
            } else {
                if (!mImageUrlList.contains(valueUrl)) {
                    mImageUrlList.add(valueUrl);
                }

            }

        }

        String getHtmlSource(String url) {
            String htmlSource = null;
            if (url == null || "".equals(url)) {
                return null;
            }

            File ChromeDriverFile = new File(zbinPath + File.separator + "G2_chromedriver_v91.exe");

            System.setProperty("webdriver.chrome.driver", ChromeDriverFile.getAbsolutePath());

//			ChromeOptions CUR_CHROME_OPTIONS = new ChromeOptions();
//			// 驱动位置
//			CUR_CHROME_OPTIONS.addArguments("--start-fullscreen");
//			CUR_CHROME_OPTIONS.setExperimentalOption("excludeSwitches", Collections.singletonList("enable-automation"));
//			ChromeDriver driver = new ChromeDriver(CUR_CHROME_OPTIONS);

            ChromeDriver driver = mChromeDriver;

            int loop_index = 0;
            try {
                long waitTime = 2000;
                long timeout = 12_000;

                driver.get(url);

//				 long waitTime = Double.valueOf(Math.max(3, Math.random() * 5) * 1000).longValue();
                TimeUnit.MILLISECONDS.sleep(waitTime);

                // 循环下拉，直到全部加载完成或者超时
                do {
                    new Actions(driver).sendKeys(Keys.END).perform();
                    TimeUnit.MILLISECONDS.sleep(waitTime);

                    timeout -= waitTime;
                    loop_index++;
                } while (!driver.getPageSource().contains("已经到底部，没有新的内容啦") && timeout > 0);
                System.out.println("getHtmlSource 已经到底部，没有新的内容啦");
                htmlSource = driver.getPageSource();
            } catch (Exception e) {
                // TODO: handle exception
                System.out.println("getHtmlSource 获取网页源码的时候出错  url = " + url);
                e.printStackTrace();

            } finally {
//				driver.close();

            }

            return htmlSource;

        }

        ArrayList<String> calcul_categoryurl_from_html_CategoryB(RootUrl_A mRootUrl_A, CategoryUrl_B mCategoryUrl_B,
                                                                 String linkA_text, String categoryFirstPageHtmlCode) {
            ArrayList<String> result_href_List = null;

            ArrayList<String> fixed_href_List = new ArrayList<String>();
            // 6.Jsoup解析html
            org.jsoup.nodes.Document document = Jsoup.parse(categoryFirstPageHtmlCode);

            Elements mElements = document.getElementsByTag("a");
            if (mElements != null && mElements.size() > 0) {

                System.out.println("a_link mElements.size()  = " + mElements.size());
                Iterator<org.jsoup.nodes.Element> element_iterator = mElements.iterator();
                int index_a_link = 1;
                while (element_iterator.hasNext()) {
                    org.jsoup.nodes.Element curElement = element_iterator.next();
                    String mHtml = curElement.outerHtml();
                    // 当前的 a 的标签 应该 包含 关键词 a 以及 href

                    System.out.println("_____CategoryUrlB_____a[" + index_a_link + "] all[" + mElements.size()
                            + "]   mHtml=" + mHtml);

                    index_a_link++;

                    if (mHtml.contains(linkA_text) && mHtml.contains("href")) {
                        String hrefValue_RawStr = mHtml.substring(mHtml.indexOf("href=\""));
                        hrefValue_RawStr = hrefValue_RawStr.replace("href=\"", "");
                        hrefValue_RawStr = hrefValue_RawStr.replace("href=", "");
                        String hrefValue_Fixed = hrefValue_RawStr.substring(0, hrefValue_RawStr.indexOf("\""));
                        // 把 amp; 转为 空
                        hrefValue_Fixed = hrefValue_Fixed.replace("amp;", "");

                        if (!hrefValue_Fixed.startsWith("http")) {
                            hrefValue_Fixed = mRootUrl_A.mRootUrl + "/" + hrefValue_Fixed;
                        }
                        fixed_href_List.add(hrefValue_Fixed);

                    }

                }

            } else {
                System.out.println("当前的 url " + mRootUrl_A.mRootUrl + " 的源码中 没有找到 标签<a> 的 内容");
                System.out.println("源码htmlCode Begin _________________________________");
                System.out.println(mCategoryUrl_B.mPageUrl_HtmlStr_Map.size());
                System.out.println("源码htmlCode Endxx _________________________________");
            }

            if (fixed_href_List.size() > 0) {
                System.out.println("fixed_href_List  = " + fixed_href_List.size());
                return fixed_href_List;
            } else {
                System.out.println("fixed_href_List  = 0");
                return result_href_List;
            }

        }

        String calcul_categoryurl_from_html_RoouUrlA(RootUrl_A mRootUrl_A, String linkA_text) {
            String result_href = null;

            // 6.Jsoup解析html
            org.jsoup.nodes.Document document = Jsoup.parse(mRootUrl_A.mHtmlStr);

            Elements mElements = document.getElementsByTag("a");
            if (mElements != null && mElements.size() > 0) {

                System.out.println("getElementsByTag[a]   mElements.size()  = " + mElements.size() + " linkA_text["
                        + linkA_text + "]");
                Iterator<org.jsoup.nodes.Element> element_iterator = mElements.iterator();
                int index_a_link = 1;
                while (element_iterator.hasNext()) {
                    org.jsoup.nodes.Element curElement = element_iterator.next();
                    String mHtml = curElement.outerHtml();
                    // 当前的 a 的标签 应该 包含 关键词 a 以及 href

                    System.out.println(
                            "___RootUrlA___a[" + index_a_link + "] all[" + mElements.size() + "]   mHtml=" + mHtml);

                    index_a_link++;

                    if (mHtml.contains(linkA_text) && mHtml.contains("href")) {
                        String hrefValue_RawStr = mHtml.substring(mHtml.indexOf("href=\""));
                        hrefValue_RawStr = hrefValue_RawStr.replace("href=\"", "");
                        String hrefValue_Fixed = hrefValue_RawStr.substring(0, hrefValue_RawStr.indexOf("\""));
                        // 把 amp; 转为 空
                        hrefValue_Fixed = hrefValue_Fixed.replace("amp;", "");

                        if (!hrefValue_Fixed.startsWith("http")) {
                            hrefValue_Fixed = mRootUrl_A.mRootUrl + "/" + hrefValue_Fixed;
                        }

                        // 最后一个匹配的 符合条件
                        result_href = hrefValue_Fixed;
//					return hrefValue_Fixed;
                    }

                }

            } else {
                System.out.println("当前的 url " + mRootUrl_A.mRootUrl + " 的源码中 没有找到 标签<a> 的 内容");
                System.out.println("源码htmlCode Begin _________________________________");
                System.out.println(mRootUrl_A.mHtmlStr);
                System.out.println("源码htmlCode Endxx _________________________________");
            }

            return result_href;

        }

    }

    // operation_type 操作类型 1--读取文件内容字符串 进行修改 2--对文件对文件内容(字节)--进行修改 3.对全体子文件进行的随性的操作
    // 属性进行修改(文件名称)
//     // 4.对当前子文件(包括子目录 子文件 --不包含孙目录 孙文件) 5. 从shell 中获取到的路径 去对某一个文件进行操作

    public static class TwitterVideo {
        public long duration;
        public long size;
        public String url;

        @Override
        public String toString() {
            // TODO Auto-generated method stub
            return "[url]=[ " + url + " ]" + "  [size]=[" + size + "]" + "  [duration]=[" + duration + "]";
        }
    }

    public static int download_failed_time = 0;

    public enum EmailTypeEnum {
        NEW_EMAIL, REPLY
    }

    static class EmailInfo {
        private String subject;
        private String sender;
        private String senderName;
        private Date sendAt;
        private String body;
        private String messageId;
        private String replyMessageId;
        private String sourceFileKey;
        private String ticketId;
        private String ticketTableName;
        private EmailTypeEnum emailTypeEnum;
        private ArrayList<File> attachments;

        public String getSubject() {
            return subject;
        }

        public void setSubject(String subject) {
            this.subject = subject;
        }

        public String getSender() {
            return sender;
        }

        public void setSender(String sender) {
            this.sender = sender;
        }

        public String getSenderName() {
            return senderName;
        }

        public void setSenderName(String senderName) {
            this.senderName = senderName;
        }

        public Date getSendAt() {
            return sendAt;
        }

        public void setSendAt(Date sendAt) {
            this.sendAt = sendAt;
        }

        public String getBody() {
            return body;
        }

        public void setBody(String body) {
            this.body = body;
        }

        public List<File> getAttachments() {
            return attachments;
        }

        public void setAttachments(ArrayList<File> attachments) {
            this.attachments = attachments;
        }

        public String getMessageId() {
            return messageId;
        }

        public void setMessageId(String messageId) {
            this.messageId = messageId;
        }

        public String getSourceFileKey() {
            return sourceFileKey;
        }

        public void setSourceFileKey(String sourceFileKey) {
            this.sourceFileKey = sourceFileKey;
        }

        public String getReplyMessageId() {
            return replyMessageId;
        }

        public void setReplyMessageId(String replyMessageId) {
            this.replyMessageId = replyMessageId;
        }

        public String getTicketId() {
            return ticketId;
        }

        public void setTicketId(String ticketId) {
            this.ticketId = ticketId;
        }

        public String getTicketTableName() {
            return ticketTableName;
        }

        public void setTicketTableName(String ticketTableName) {
            this.ticketTableName = ticketTableName;
        }

        public EmailTypeEnum getEmailTypeEnum() {
            return emailTypeEnum;
        }

        public void setEmailTypeEnum(EmailTypeEnum emailTypeEnum) {
            this.emailTypeEnum = emailTypeEnum;
        }

        @Override
        public String toString() {
            return "EmailInfo [subject=" + subject + ", sender=" + sender + ", senderName=" + senderName + ", sendAt="
                    + sendAt + ", body=" + body + ", messageId=" + messageId + ", replyMessageId=" + replyMessageId
                    + ", sourceFileKey=" + sourceFileKey + ", ticketId=" + ticketId + ", ticketTableName="
                    + ticketTableName + ", emailTypeEnum=" + emailTypeEnum + ", attachments=" + attachments + "]";
        }

    }

    public static class EmailContext {
        private List<EmailInfo> emailInfos;
        private javax.mail.Message[] messages;
        private javax.mail.Folder folder;

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();

            for (int i = 0; i < messages.length; i++) {
                sb.append(messages[i].toString());
            }
            return "EmailContext [emailInfos=" + emailInfos + ", messages=[" + sb.toString() + "]" + ", folder="
                    + folder + "]";
        }

        public List<EmailInfo> getEmailInfos() {
            return emailInfos;
        }

        public void setEmailInfos(List<EmailInfo> emailInfos) {
            this.emailInfos = emailInfos;
        }

        public javax.mail.Folder getFolder() {
            return folder;
        }

        public void setFolder(javax.mail.Folder folder) {
            this.folder = folder;
        }

        public javax.mail.Message[] getMessages() {
            return messages;
        }

        public void setMessages(javax.mail.Message[] messages) {
            this.messages = messages;
        }
    }

    class Monitor_WeChatFile_ForWindows_Rule_39 extends Basic_Rule {
// C:\Users\zukgit\Documents\WeChat Files\xxxx\FileStorage\File\2021-07

        ArrayList<File> searchRootFileList; // 存放要搜索的 txt文件的 根目录 目前只有 \WeChat Files\和\Tencent Files\
        File mWeChatRootFile; // C:\Users\xx\Documents\WeChat Files\ 目录 微信使用
        File mTencentRootFile; // C:\Users\xx\Documents\Tencent Files\ 目录 QQ使用
        File mLastTxtFile; // 最新的 TXT 文件
        ArrayList<String> urlStrList; // url 字符串列表


        //
        int mMailFirstMinute = 3;
        int mMailInteval = 300;  // 300 分钟间隔发送 
        int last_email_count = 0; // 最新的 email的数量
        HashMap<Integer, ArrayList<EmailInfo>> minute_mailListMap; // key 是当前的分钟的值 value 是当前接收到 cmdermail cmdmail 邮件的集合

        File mDownloadedRootFile;
        File mDownloadedMonthDir; // 在 G2_Monitor_Download/YYYYMM/ 年年年年月月的 目录文件

        File ChromeDriverFile; // G2_chromedriver_v91.exe 下载头条视频时会用到

        ArrayList<File> curAlredyDoTxtFileList; // 当前已经执行了 检测处理的 txt文件 列表 持续增加

        // 下载的视频 是否 以 MD5 进行命名
        boolean isMDName = false;

        boolean isBootUp_VBS_Start = false; // 是否是开机 vbs 启动的进程

        boolean isLogFile = false;
        StringBuilder mLogSB;

        int sendMailCount = 1 ;   // 发送  mail的 数量

        ArrayList<String> mOneTimeLogList; // 一次运行的Log

        File mLogFile;

        // zcmd_run_[]//
        ArrayList<String> zcmdRunCommandList; // 在 文件中 识别出的 zcmd_run_的命令的集合

        ArrayList<String> zMailCmdRunCommandList; //  在 邮件中 读取到的 执行的命令的集合
        ArrayList<EmailInfo> zAlreadRunMailCommandList; //  执行的命令的集合 以及 时间戳  执行过的 就不执行了


        File cmderExePath; // cmder.exe 文件的绝对路径 使得程序 能再 cmder.exe上执行程序 有环境变量的优势
        // 写入的 需要 cmder.exe 需要执行的 命令的 集合 使用 && 来串连
        File cmder_prexe_bat_file; // C:\Users\zhuzj5\Desktop\zbin\win_zbin\zcmder_prexe_G2.bat

        Monitor_WeChatFile_ForWindows_Rule_39() {
            super("#", 39, 3); // 不包括
            urlStrList = new ArrayList<String>();
            mDownloadedRootFile = new File(zbinPath + File.separator + "G2_Monitor_Download");
            mDownloadedMonthDir = new File(
                    mDownloadedRootFile.getAbsolutePath() + File.separator + getTimeStamp_YYYYMM());
            ChromeDriverFile = new File(zbinPath + File.separator + "G2_chromedriver_v91.exe");
            curAlredyDoTxtFileList = new ArrayList<File>();
            searchRootFileList = new ArrayList<File>();
            isLogFile = false;
            mLogSB = new StringBuilder();
            mLogFile = new File(zbinPath + File.separator + "win_zbin" + File.separator + "zrule_apply_G2_39rule.log");
            mOneTimeLogList = new ArrayList<String>();
            // cmderExePath 是写死的
            zMailCmdRunCommandList = new ArrayList<String>();
            minute_mailListMap = new HashMap<Integer, ArrayList<EmailInfo>>();
            last_email_count = 0;
            zAlreadRunMailCommandList = new ArrayList<EmailInfo>();
            sendMailCount = 1;
        }

        @Override
        boolean allowEmptyDirFileList() {
            // TODO Auto-generated method stub
            return true;
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            boolean Flag = true;

            for (int i = 0; i < inputParamList.size(); i++) {

                String paramItem = inputParamList.get(i);
                String paramItem_lower_trim = paramItem.toLowerCase().trim();

                if ("mdname_true".equals(paramItem_lower_trim)) {
                    isMDName = true;
                }

                if ("bootup_true".equals(paramItem_lower_trim)) {
                    isBootUp_VBS_Start = true;
                }

                if ("logfile_true".equals(paramItem_lower_trim)) {
                    isLogFile = false;
                }

            }

            System.out.println(
                    "isLogFile=" + isLogFile + "   isbootup=" + isBootUp_VBS_Start + "   isMDName=" + isMDName);

            return super.initParamsWithInputList(inputParamList) && Flag;
        }

        /*
         * @Override boolean initParams4InputParam(String inputParam) {
         * System.out.println("inputParam = " + inputParam + "  curDirPath = " +
         * curDirPath); if (curDirPath == null) { System.out.println("当前的Shell 路径为空！！！ "
         * + "inputParam = " + inputParam + "  curDirPath = " + curDirPath); return
         * false; } String shellAbsPath = curDirPath;
         *
         * String doucumentPath = System.getProperties().getProperty("user.home") +
         * File.separator + "Documents"; String wechatPathPre =
         * System.getProperties().getProperty("user.home") + File.separator +
         * "Documents" + File.separator + "WeChat Files";
         *
         * String tecentAbsFile = System.getProperties().getProperty("user.home") +
         * File.separator + "Documents" + File.separator + "Tencent Files";
         *
         * File wechatDocumentDirFile = new File(wechatPathPre); File
         * tecentDocumentDirFile = new File(tecentAbsFile);
         *
         *
         * if (!shellAbsPath.startsWith(doucumentPath)) { System.out.println(
         * "当前的Shell 路径不是 Document["+doucumentPath+"] 下的路径 的目录 ！！！ " + "inputParam = " +
         * inputParam + "  curDirPath = " + curDirPath);
         *
         * return false; }
         *
         *
         * File shellFile = new File(curDirPath); String shellDirName =
         * shellFile.getName(); String shellDirName_clearBlank =
         * shellDirName.replace("-", ""); // 2021-07 String shellFileAbsPath =
         * shellFile.getAbsolutePath();
         *
         * String wechatRootPath = System.getProperties().getProperty("user.home") +
         * File.separator + "Documents" + File.separator + "WeChat Files";
         *
         * String now_yyyymm = getTimeStamp_YYYYMM(); //
         * C:\Users\zhuzj5\Documents\WeChat Files
         *
         * if (!now_yyyymm.equals(shellDirName_clearBlank)) {
         * System.out.println("当前的Shell是 WeChat的目录  但不是最新月份下的目录 ！！！ " + "inputParam = "
         * + inputParam + "  curDirPath = " + curDirPath);
         * System.out.println("最新目录结果类似于: " +
         * " C:\\Users\\zukgit\\Documents\\WeChat Files\\xxxx\\FileStorage\\File\\2021-07"
         * ); return false; }
         *
         *
         * // 如果不是wechat的目录 那么提示 路径不对 // if
         * (!shellFileAbsPath.startsWith(wechatRootPath)) { //
         * System.out.println("当前的Shell是 WeChat的目录 下的目录 ！！！ " + "inputParam = " +
         * inputParam // + "  curDirPath = " + curDirPath +"   wechatRootPath = "+
         * wechatRootPath +"   shellFileAbsPath="+ shellFileAbsPath ); //
         * System.out.println("最新目录结果类似于: " // +
         * " C:\\Users\\zukgit\\Documents\\WeChat Files\\xxxx\\FileStorage\\File\\2021-07"
         * ); // return false; // } // if (!wechatDocumentDirFile.exists() &&
         * !tecentDocumentDirFile.exists()) {
         *
         * System.out.println("当前 Document目录[" + doucumentPath + "] "); return false; }
         *
         * if (!mDownloadedRootFile.exists()) { mDownloadedRootFile.mkdirs(); }
         *
         * if (!mDownloadedMonthDir.exists()) { mDownloadedMonthDir.mkdirs(); }
         *
         * if (!mDownloadedMonthDir.exists()) { System.out.println(
         * "当前文件下载保存路径不存在_请检查这个保存文件的目录 mDownloadedMonthDir = " +
         * mDownloadedMonthDir.getAbsolutePath()); return false;
         *
         * }
         *
         * mWeChatRootFile = wechatDocumentDirFile; mTencentRootFile =
         * tecentDocumentDirFile;
         *
         * if (mWeChatRootFile.exists()) { searchRootFileList.add(mWeChatRootFile);
         * System.out.println("当前 WeChat目录存在 将持续为您监听"); } else {
         * System.out.println("当前 WeChat目录不存在   !!! File Not Exist =" +
         * mWeChatRootFile.getAbsolutePath()); }
         *
         * if (mTencentRootFile.exists()) { searchRootFileList.add(mTencentRootFile);
         * System.out.println("当前 Tecent[QQ] 目录存在 将持续为您监听"); } else {
         * System.out.println("当前 Tecent[QQ]目录不存在   !!! File Not Exist =" +
         * mTencentRootFile.getAbsolutePath());
         *
         * }
         *
         * mLastTxtFile = calLastTxtFileInFileList(searchRootFileList);
         * curAlredyDoTxtFileList = getAllSubFileInFileList(searchRootFileList, ".txt");
         *
         * // File[] fileArr = mWeChatRootFile.listFiles(); // if (fileArr == null ||
         * fileArr.length == 0) { // System.out.println("当前目录文件为空,将休眠1分钟后继续监测!!"); // //
         * } else { // mLastTxtFile = calLastTxtFileInList(mWeChatRootFile); //
         * curAlredyDoTxtFileList = getAllSubFile(mWeChatRootFile,".txt"); // }
         *
         * return super.initParams4InputParam(inputParam); }
         */

        String getSearchFileTip(ArrayList<File> searchFileList) {
            StringBuilder sb = new StringBuilder();

            for (int i = 0; i < searchFileList.size(); i++) {
                File searchFile = searchFileList.get(i);
                sb.append(searchFile.getAbsolutePath() + "_____");
            }
            return sb.toString();

        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {

            int minute_count = 0;
            String searchFileTip = getSearchFileTip(searchRootFileList);
            if (true) {

                Http_Server_Cmd_Operation();
                
                while (true) {

                    try {
                        File lastTxtFile = calLastTxtFileInFileList(searchRootFileList);
                        if (lastTxtFile == null) {
                            mLastTxtFile = null;
                            System.out.println("当前搜索目录[" + searchFileTip + "] mailFirst["+mMailFirstMinute+"]"+"mailInteval["+mMailInteval+"]"+"没有Txt文件!!  睡眠1分钟后继续检测！！！ ");
                        } else if (mLastTxtFile != null
                                && lastTxtFile.getAbsolutePath().equals(mLastTxtFile.getAbsolutePath())) {

                            System.out
                                    .println("当前搜索目录[" + searchFileTip + "] mailFirst["+mMailFirstMinute+"] mailInteval["+mMailInteval+"] 没有Txt文件!!!!  没有产生最新的Txt文件   睡眠1分钟后继续检测！！！ ");
                        } else if (lastTxtFile != null && lastTxtFile != mLastTxtFile) {
                            System.out.println("当前检测到最新的 TXT 文件  lastTxtFile = " + lastTxtFile.getName()
                                    + " 创建新线程 打印内容！！！ 【lastTxtFile == mLastTxtFile】==【" + (lastTxtFile == mLastTxtFile)
                                    + "】   lastTxtFile=" + lastTxtFile.getAbsolutePath() + "  mLastTxtFile="
                                    + mLastTxtFile.getAbsolutePath());
                            mLastTxtFile = lastTxtFile;
                            NewFileOperation(mLastTxtFile, minute_count);
                        } else {
                            System.out.println("什么情况" + "   lastTxtFile=" + lastTxtFile.getAbsolutePath()
                                    + "  mLastTxtFile=" + mLastTxtFile.getAbsolutePath());
                        }



                        // ================== 检测 cmdmail 邮件 Begin ================


                        Receive_Monitor_Mail_Operation(minute_count);

                        // ================== 检测 cmdmail 邮件 End ================

                        // 第3分钟 以及 每隔 30分钟 发个邮件 ?
                        int minutes_inteval = mMailInteval; // 发邮件的间隔  2
                        int first_send_miute = mMailFirstMinute; // 起始发送文件的分钟数 1
                        if (minute_count == first_send_miute
                                || (minute_count != 0 && minute_count % minutes_inteval == 0)) {
                            if (isBootUp_VBS_Start) { //
                                Send_Monitor_Email(minute_count, first_send_miute, minutes_inteval, mOneTimeLogList,
                                        mLastTxtFile, mWeChatRootFile, mTencentRootFile, zcmdRunCommandList, zMailCmdRunCommandList ,
                                        searchRootFileList, curAlredyDoTxtFileList);
                                // 发送邮件
                            }
                            mOneTimeLogList.clear();
                        }

                        System.out.println("══════════════════ " + "Minute[" + minute_count + "] mailFirst["+mMailFirstMinute+"] mailInteval["+mMailInteval+"]:" + getTimeStamp()
                                + " ════════ mLastTxtFile=" + (mLastTxtFile == null ? "null" : mLastTxtFile.getName()));

                        Thread.sleep((long) ONE_MINUTES_MILLSECOND);
                        minute_count++;

                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }

                }

            }

            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        int curUrlIndex_InTxtFile;

        
        
        int Http_Client_Index = 0 ;
     
        // 子线程 启动 Http服务 用来 检测 8080 端口 , 等待 Socket Client 调用  8080
        void Http_Server_Cmd_Operation( ) {
        	
            new Thread(new Runnable() {

                @Override
                public void run() {
                	Http_Main(8080);  // 8080 端口 监听 事件  
                }
            }).start();
        	
        	
        }
        
        void Http_Main(int monitorPort) {


            // ServerSocket指定端口port
            java.net.ServerSocket serverSocket = null ;
   
            try {

                // http://192.168.199.11:65000/wirelessadb_connect_rule1


                InetAddress addr;
                addr = InetAddress.getLocalHost();  // 【InetAddress.getLocalHost().getHostAddress()】
                String localHostIpAddr = addr.getHostAddress();


                String localWifiIpAddr = null ;


                Enumeration<NetworkInterface> networkInterfaces = NetworkInterface.getNetworkInterfaces();
                int network_interface_index = 1;

               break_out: while (networkInterfaces.hasMoreElements()) {
                    NetworkInterface networkInterface = networkInterfaces.nextElement();

                    System.out.println("networkInterface["+network_interface_index+"].getName() = "+ networkInterface.getName());

                    if (networkInterface.getName().startsWith("wlan")) {
                        Enumeration<InetAddress> inetAddresses = networkInterface.getInetAddresses();
                        while (inetAddresses.hasMoreElements()) {
                            InetAddress inetAddress = inetAddresses.nextElement();
                            if (!inetAddress.isLoopbackAddress() && inetAddress.isSiteLocalAddress()) {
                                System.out.println("HostIpAddr IP Address: " + inetAddress.getHostAddress());
                                System.out.println("Wifi IP Address: " + inetAddress.getHostAddress());
                                localWifiIpAddr = inetAddress.getHostAddress();
                                break break_out;   // 取到  这个值 就 break 
                            }
                        }
                    }
                    network_interface_index++;
                }

                if(localWifiIpAddr != null && !localWifiIpAddr.equals(localHostIpAddr)){
                    localHostIpAddr = localWifiIpAddr;
                }

         
                serverSocket = new java.net.ServerSocket(monitorPort);

                if(serverSocket == null) {
                    System.out.println("无法启动Http服务---ip:port【"+localHostIpAddr+":"+monitorPort+"】");
                    return ;
                }




                System.out.println("启动Http服务---ip:port【"+localHostIpAddr+":"+monitorPort+"】");


                while(true){
                    // 阻塞到有连接访问，拿到socket

                    System.out.println("主线程开始在端口______"+"【"+localHostIpAddr+":"+monitorPort+"】监听Accept()方法_______");
                    Socket 	socket = serverSocket.accept();
                    System.out.println();
                    System.out.println();
                    System.out.println();
                    System.out.println("主线程监听到在端口______"+"【"+localHostIpAddr+":"+monitorPort+"】有请求,从Accept()阻塞方法中苏醒_执行逻辑_______");


                    System.out.println("主线程接受到 客户端Client_Socket HashCode:"+socket.hashCode());

                    // STEP. 启动线程
                    new Thread(()->{
                        try {
                            // STEP. 获取输入流、输出流
                            OutputStream outputStream = null;
                            InputStream inputStream = null;
                            inputStream = socket.getInputStream();
                            outputStream = socket.getOutputStream();

                            // STEP. 获取输入内容
                            byte[] bytes = new byte[inputStream.available()];
                            int result = inputStream.read(bytes);
                            String clientIp = "";
                            if (result != -1) {
                                System.out.println("_________子线程客户ID["+Http_Client_Index+"]打印Begin_______");
                                String mByteStr = new String(bytes);
                                System.out.println(mByteStr);
                                Operation_HttpCmd_Command(mByteStr);    // 命令在这里 需要执行
                                System.out.println("_________子线程客户ID["+Http_Client_Index+"]End_______");


                            }

                            // STEP. 响应内容
                            // http 状态
                            String httpStatus = "200 OK";
                            // String httpStatus = "404 Not Found";
                            // String httpStatus = "500 Internal Server Error";

                            // 状态行、响应头部、空行、响应信息
                            String body = "<h1>hello_"+clientIp+"</h1>";
                            String responseStatusLine = "HTTP/1.1 "+httpStatus+"\r\n";
                            String responseHeader = "";
                            responseHeader += "Content-Length: " + body.getBytes().length + "\r\n";
                            responseHeader += "Content-Type: text/html; charset-utf-8\r\n";
                            String responseLine = "\r\n";
                            String responseBody = body + "\r\n";
                            String response = responseStatusLine + responseHeader +responseLine + responseBody;

                            // 输出响应内容、关闭流
                            outputStream.write(response.getBytes());//按照协议，将返回请求由outputStream写入
                            outputStream.flush();
                            socket.shutdownInput();
                            socket.shutdownOutput();
                            socket.close();
                            Http_Client_Index++;
                        }catch (Exception e){
                            e.printStackTrace();
                        }

                    },String.valueOf(socket.hashCode())).start();
                }

            } catch (IOException e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
            }

            System.out.println("_______Port:"+monitorPort+" While(true) 结束!_______");


        }
        
        void Operation_HttpCmd_Command(String mRawHttpCommandStr) {
            System.out.println("mRawHttpCommandStr = "+ mRawHttpCommandStr);	
        	
        }
        //
        void Receive_Monitor_Mail_Operation(int minute_count) {


            new Thread(new Runnable() {

                @Override
                public void run() {
                    EmailContext emalContext = null;
                    try {
                        emalContext = receive_mailcmd_Context(minute_count, "imap", "imap.qq.com", "382581427@qq.com",
                                "kyioxkexvqdtbjhd");

                        if (minute_mailListMap.get(minute_count) != null && minute_mailListMap.get(minute_count).size() > 0) {
                            ArrayList<EmailInfo> match_minutes_MailList = minute_mailListMap.get(minute_count);

                            System.out.println("match_minutes_MailList.size() = "+ match_minutes_MailList.size());
                            for (int i = 0; i < match_minutes_MailList.size(); i++) {

                                EmailInfo emailInfo = match_minutes_MailList.get(i);
                                String mSubject = emailInfo.getSubject();

                                System.out.println("AA_Receive_Monitor_Mail_Operation  minute_count=" + minute_count + " mail[" + i
                                        + "][" + match_minutes_MailList.size() + "]  Subkect= " + mSubject);

                                if(!isEmailInfoExist(zAlreadRunMailCommandList,emailInfo)) {
                                    zAlreadRunMailCommandList.add(emailInfo);
                                    exe_cmd_email_operation(minute_count, emailInfo);
                                }else {

                                    System.out.println("当前已经存在相同的 EmailInfoList emailInfo="+emailInfo);
                                }


                                System.out.println("BB_Receive_Monitor_Mail_Operation  minute_count=" + minute_count + " mail[" + i
                                        + "][" + match_minutes_MailList.size() + "]  Subkect= " + mSubject);

                            }

                        }else {
                            System.out.println("match_minutes_MailList.size() = 0 null  minute_count="+minute_count);
                        }

                    } catch (Exception e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }

                }
            }).start();






        }


        boolean isEmailInfoExist(ArrayList<EmailInfo> usedEmailList , EmailInfo curEmail) {
            boolean isExist = false;

            for (int i = 0; i < usedEmailList.size(); i++) {

                EmailInfo  mEmailInfo = 	usedEmailList.get(i);

                if(mEmailInfo.body.equals(curEmail.body)  && mEmailInfo.subject.equals(curEmail.subject)) {
                    return true;
                }

            }



            return isExist;



        }
        void exe_cmd_email_operation(int minutes_count, EmailInfo emailInfo) {
            String mSubject = emailInfo.getSubject();

            String task_identify = minutes_count+"_"+mSubject;
            System.out.println("exe_cmd_email_operation  minutes_count="+minutes_count+"    task_identify="+task_identify+"的任务!    containFlag=");
            mLogSB.append("_______________mailcmder_run_[minute:" + minutes_count + "]  subject[" + mSubject
                    + "] Begin ____");

            System.out.println("_______ exe_cmd_email_operation ________mailcmder_run_[minute:" + minutes_count + "]  subject[" + mSubject
                    + "] Begin ____");
//			mSubject    // mailcmd_zhuzj5_run_【afafafa】 %win_zbin%/zrule_apply_G2.bat #_48 voice_12345678900987654321

            StringBuilder tipSb = new StringBuilder();

            if (mSubject.contains("mailcmd_") && mSubject.contains("【") && mSubject.contains("】")) {

                String command_pre_flag = "mailcmd_";
                String userName_raw = mSubject.substring(mSubject.indexOf("【"));
                String userName_fix = userName_raw.replace(command_pre_flag, "").replace("_run_", "").trim();

                String command = mSubject.substring(mSubject.indexOf("】") + 1).trim();

                System.out.println(
                        "minutes_count=" + minutes_count + "   userName_fix=" + userName_fix + "   cmdercommand=" + command);

                command = command.replace("%win_zbin%", Win_Lin_Mac_ZbinPath);
                String command_fixed = command.replace("%zbin%", zbinPath);


                String result = "";
                new Thread(new Runnable() {   // 让 子线程  去执行  否则 卡住 主线程

                    @Override
                    public void run() {
                        // TODO Auto-generated method stub

                        zMailCmdRunCommandList.add(command_fixed);
                        String result = execCMD(command_fixed);
                        System.out.println("execCMD command【"+command_fixed+"】 result="+result);

                    }
                }).start();

                System.out.println("minutes_count=" + minutes_count + "   userName_fix=" + userName_fix
                        + "   cmder_command=" + command + "  result=" + result);

            }else {

                System.out.println(
                        "AA minutes_count=" + minutes_count + "   Subject_command=" + mSubject  );
            }

            if (mSubject.contains("mailcmder_") && mSubject.contains("【") && mSubject.contains("】")) {
                String command_pre_flag = "mailcmder_";
                String userName_raw = mSubject.substring(mSubject.indexOf("【"));
                String userName_fix = userName_raw.replace(command_pre_flag, "").replace("_run_", "").trim();
                String command = mSubject.substring(mSubject.indexOf("】") + 1).trim();

                System.out.println("minutes_count=" + minutes_count + "   userName_fix=" + userName_fix
                        + "   cmd_command=" + command);

                command = command.replace("%win_zbin%", Win_Lin_Mac_ZbinPath);
                String command_fixed = command.replace("%zbin%", zbinPath);

                String result = "";
                new Thread(new Runnable() { // 让 子线程  去执行  否则 卡住 主线程

                    @Override
                    public void run() {
                        // TODO Auto-generated method stub

                        zMailCmdRunCommandList.add(command_fixed);
                        String result = run_cmder(command_fixed); // cmd 运行
                        System.out.println("run_cmder  command【"+command_fixed+"】 result="+result);
                    }
                }).start();



                System.out.println("minutes_count=" + minutes_count + "   userName_fix=" + userName_fix
                        + "   cmdcommand=" + command + " result=" + result);

            }else {

                System.out.println(
                        "BB minutes_count=" + minutes_count + "   Subject_command=" + mSubject  );
            }

            mLogSB.append(
                    "_______________mailcmder_run_[minute:" + minutes_count + "]  subject[" + mSubject + "] End ____");
            System.out.println(
                    "_______________mailcmder_run_[minute:" + minutes_count + "]  subject[" + mSubject + "] End ____");

        }

        /**
         * 接收邮件
         */
        public EmailContext receive_mailcmd_Context(int minutes, String protocol, String host, String username,
                                                    String password) throws Exception {
            // 读取收件箱
            System.out.println("receive_CmdMail 方法开始! AA");
            EmailContext emailContext = readInbox(protocol, host, username, password);
            System.out.println("receive_CmdMail 方法结束! BB  ");
            if (emailContext == null) {
                return null;
            }
            // 处理邮件
            ArrayList<EmailInfo> result = parseCmdMessage(emailContext.messages);
            emailContext.setEmailInfos(result);
            minute_mailListMap.put(minutes, result);
            System.out.println("receive_CmdMail CC  ");
            return emailContext;
        }

        /**
         * 解析邮件
         *
         * @param allMessages 要解析的邮件列表
         */
        public ArrayList<EmailInfo> parseCmdMessage(javax.mail.Message... allMessages) throws MessagingException {
            if (allMessages == null || allMessages.length < 1) {
                throw new MessagingException("未找到要解析的邮件!");
            }

            ArrayList<EmailInfo> mCmdMailInfoList = new ArrayList<EmailInfo>();

            // 解析所有邮件
            System.out.println("parseMessage 解析邮件begin  messages.length = " + allMessages.length);
            int all_eamil_count = allMessages.length;
            int receive_mail_count = 0;
            System.out.println("messages.length = " + allMessages.length);
            if (last_email_count == 0) { // 首次监听邮件时候 邮件长度为0

                last_email_count = all_eamil_count;
                System.out.println("当前的邮件长度为: " + last_email_count);
                receive_mail_count = allMessages.length - last_email_count;
            } else {

                receive_mail_count = all_eamil_count - last_email_count;

                System.out.println("当前静默期间 收到 receive_mail_count=" + receive_mail_count + "封邮件!");

            }

            System.out.println("当前的需要读取的邮件长度为: receive_mail_count=" + receive_mail_count);

            if (receive_mail_count <= 0) {

                System.out.println("当前静默期间 收到的邮件为0  receive_mail_count=" + receive_mail_count + "  继续静默!");
                return mCmdMailInfoList;
            }

            // mailcmd_zhuzj5_xxxxxxxxxx
            // mailcmder_gjh123_xxxxxxxxxx

            for (int i = allMessages.length - receive_mail_count; i < allMessages.length; i++) {
                if (!allMessages[i].getFolder().isOpen()) {
                    allMessages[i].getFolder().open(javax.mail.Folder.READ_WRITE);
                }
                MimeMessage msg = (MimeMessage) allMessages[i];
                EmailInfo emailInfo = new EmailInfo();
                try {



                    String mSubject_Content = msg.getSubject();
                    System.out.println("当前的需要读取的邮件长度为: AA receive_mail_count=" + receive_mail_count +" mSubject_Content="+mSubject_Content);
                    if (mSubject_Content == null || "".equals(mSubject_Content)) {
                        continue;
                    }
                    System.out.println("当前的需要读取的邮件长度为: BB receive_mail_count=" + receive_mail_count +" mSubject_Content="+mSubject_Content);

                    if (!(mSubject_Content.startsWith("mailcmd_") || mSubject_Content.startsWith("mailcmder_"))) {
                        // 只 读取 特定 主题 subject 主题的 邮件
                        continue;
                    }
                    System.out.println("当前的需要读取的邮件长度为: CC receive_mail_count=" + receive_mail_count +" mSubject_Content="+mSubject_Content);

                    emailInfo.setSubject(msg.getSubject());
                    emailInfo.setSender(getFrom(msg));
                    emailInfo.setSenderName(getSenderName(msg));
                    emailInfo.setSendAt(msg.getSentDate());
                    emailInfo.setMessageId(msg.getMessageID());
                    // 邮件源文件
                    emailInfo.setSourceFileKey(saveSourceEmailFile(msg));
                    emailInfo.setReplyMessageId(getHeader(msg, "In-Reply-To"));
                    String body = getTextFromMessage(msg);
                    body = obtainEmailType(emailInfo, body);

                    try {
                        System.out.println("当前的需要读取的邮件长度为: DD receive_mail_count=" + receive_mail_count +" mSubject_Content="+mSubject_Content);

                        emailInfo.setBody(body.toString());
                    } catch (Exception e) {
                        e.printStackTrace();
                    }

                    if (isContainAttachment(msg)) {
                        emailInfo.setAttachments(saveAttachment(msg));
                    }
                    System.out.println("当前的需要读取的邮件长度为: EE receive_mail_count=" + receive_mail_count +" mSubject_Content="+mSubject_Content);

                    mCmdMailInfoList.add(emailInfo);
                    if (allMessages[i].getFolder().isOpen()) {
                        allMessages[i].getFolder().close(true);
                    }

                    System.out.println("当前的需要读取的邮件长度为: FF receive_mail_count=" + receive_mail_count +" mSubject_Content="+mSubject_Content);

                } catch (Exception e) {
                    System.out.println("读取邮件失败");
                    e.printStackTrace();
                }
            }
            System.out.println("parseMessage 方法结束: List<EmailInfo>.size()  =" + mCmdMailInfoList.size());
            return mCmdMailInfoList;
        }

        /**
         * 保存附件
         *
         * @param part 邮件中多个组合体中的其中一个组合体
         * @throws UnsupportedEncodingException
         * @throws MessagingException
         * @throws IOException
         */
        private ArrayList<File> saveAttachment(javax.mail.Part part)
                throws UnsupportedEncodingException, MessagingException, IOException {
            System.out.println(" hashCode :" + part.hashCode());

            ArrayList<File> attchFileList = new ArrayList<File>();

            if (part.isMimeType("multipart/*")) {
                javax.mail.Multipart multipart = (javax.mail.Multipart) part.getContent();
                int partCount = multipart.getCount();
                for (int i = 0; i < partCount; i++) {
                    javax.mail.BodyPart bodyPart = multipart.getBodyPart(i);
                    String disp = bodyPart.getDisposition();
                    if (disp != null) {
                        String fileName = decodeText(bodyPart.getFileName());
                        System.out.println(" fileName :" + fileName);
                        // 通过getInputStream方法下载附件
                        InputStream attatchIns = bodyPart.getInputStream();

                        File attchFile = new File(mDownloadedRootFile + fileName);
                        FileOutputStream fos = new FileOutputStream(attchFile);
                        byte[] b = new byte[1024];
                        while ((attatchIns.read(b)) != -1) {
                            fos.write(b);// 写入数据
                        }

                        attatchIns.close();
                        fos.close();// 保存数据

                        attchFileList.add(attchFile);

                    }
                }
            }

            return attchFileList;
        }

        public String decodeText(String encodeText) throws UnsupportedEncodingException {
            if (encodeText == null || "".equals(encodeText)) {
                return "";
            } else {
                return MimeUtility.decodeText(encodeText).replaceAll("/", "_");
            }
        }

        // 查看是否包含附件
        public boolean isContainAttachment(javax.mail.Part part)
                throws MessagingException, IOException, InterruptedException {
            // 是否包含multipart内容
            if (part.isMimeType("multipart/*")) {
                // 转换content为MimeMultipart对象
                MimeMultipart multipart = (MimeMultipart) part.getContent();
                // 获取bodyPart的数量
                int partCount = multipart.getCount();
                for (int i = 0; i < partCount; i++) {
                    javax.mail.BodyPart bodyPart = multipart.getBodyPart(i);
                    // 返回bodyPart的配置
                    String disp = bodyPart.getDisposition();
                    // 是否包含附件
                    if (disp != null && (disp.equalsIgnoreCase(javax.mail.Part.ATTACHMENT)
                            || disp.equalsIgnoreCase(javax.mail.Part.INLINE))) {
                        return true;
                    }
                }
            }
            return false;
        }

        /**
         * 提取邮件类型
         *
         * @param emailInfo
         * @param body
         */
        public String obtainEmailType(EmailInfo emailInfo, String body) {
            if (body == null) {
                emailInfo.setEmailTypeEnum(EmailTypeEnum.NEW_EMAIL);
                return null;
            }
            if (body.contains("《hidden《") && body.contains("》hidden》")) {
                emailInfo.setEmailTypeEnum(EmailTypeEnum.REPLY);
                String startFlag = "《hidden《";
                int start = body.lastIndexOf(startFlag);
                int end = body.lastIndexOf("》hidden》");
                String info = body.substring(start + startFlag.length(), end);
                String[] split = info.split(":");
                if (split.length != 2) {
                    emailInfo.setEmailTypeEnum(EmailTypeEnum.NEW_EMAIL);
                } else {
                    emailInfo.setTicketId(split[0]);
                    emailInfo.setTicketTableName(split[1]);
                }
            } else {
                emailInfo.setEmailTypeEnum(EmailTypeEnum.NEW_EMAIL);
            }
            return body;
        }

        public String getTextFromMessage(javax.mail.Message message) throws MessagingException, IOException {
            String result = "";
            if (message.isMimeType("text/plain") || message.isMimeType("text/html")) {
                result = message.getContent().toString();
            } else if (message.isMimeType("multipart/mixed")) {
                result = getTextFromMimeMultipart((javax.mail.Multipart) message.getContent());
            } else if (message.isMimeType("multipart/alternative")) {
                result = getTextFromMimeMultipart((javax.mail.Multipart) message.getContent());
            }
            return result;
        }

        public String getTextFromMimeMultipart(javax.mail.Multipart mimeMultipart)
                throws MessagingException, IOException {
            String result = "";
            int count = mimeMultipart.getCount();
            for (int i = 0; i < count; i++) {
                javax.mail.BodyPart bodyPart = mimeMultipart.getBodyPart(i);
                if (bodyPart.isMimeType("text/plain")) {
                    result = result + bodyPart.getContent();
                } else if (bodyPart.isMimeType("text/html")) {
                    String html = (String) bodyPart.getContent();
                    result = result + html;
                } else if (bodyPart.getContent() instanceof javax.mail.Multipart) {
                    result = result + getTextFromMimeMultipart((javax.mail.Multipart) bodyPart.getContent());
                } else if (bodyPart.isMimeType("text/html")) {
                    String html = (String) bodyPart.getContent();
                    result = result + html;
                } else if (bodyPart.getContent() instanceof javax.mail.Multipart) {
                    result = result + getTextFromMimeMultipart((javax.mail.Multipart) bodyPart.getContent());
                }
            }
            return result;
        }

        public String saveSourceEmailFile(MimeMessage msg) {
            return "source_file_key";
        }

        public String getHeader(MimeMessage mimeMessage, String header) {
            String[] headers = new String[0];
            try {
                headers = mimeMessage.getHeader(header);
            } catch (MessagingException e) {
                e.printStackTrace();
            }
            return headers != null && headers.length > 0 ? headers[0] : null;
        }

        // ----------------------------------------------------------------------------------------------

        /**
         * 获得邮件主题
         *
         * @param msg 邮件内容
         * @return 解码后的邮件主题
         */
        public String getSubject(MimeMessage msg) throws UnsupportedEncodingException, MessagingException {
            return MimeUtility.decodeText(msg.getSubject());
        }

        // ----------------------------------------------------------------------------------------------

        /**
         * 获取发件人
         *
         * @param msg
         * @return
         */
        public String getSenderName(MimeMessage msg) throws MessagingException {
            javax.mail.Address[] froms = msg.getFrom();
            if (froms.length < 1) {
                return "";
            }
            javax.mail.internet.InternetAddress address = (javax.mail.internet.InternetAddress) froms[0];
            return address.getPersonal();
        }

        // ----------------------------------------------------------------------------------------------

        /**
         * 获得邮件发件人
         *
         * @param msg 邮件内容
         * @return 姓名 <Email地址>
         * @throws MessagingException
         * @throws UnsupportedEncodingException
         */
        public String getFrom(MimeMessage msg) throws MessagingException {
            javax.mail.Address[] froms = msg.getFrom();
            if (froms.length < 1) {
                return "";
            }
            javax.mail.internet.InternetAddress address = (javax.mail.internet.InternetAddress) froms[0];
            return address.getAddress();
        }

        /**
         * Flag 类型列举如下 Flags.Flag.ANSWERED 邮件回复标记，标识邮件是否已回复。 Flags.Flag.DELETED
         * 邮件删除标记，标识邮件是否需要删除。 Flags.Flag.DRAFT 草稿邮件标记，标识邮件是否为草稿。 Flags.Flag.FLAGGED
         * 表示邮件是否为回收站中的邮件。 Flags.Flag.RECENT 新邮件标记，表示邮件是否为新邮件。 Flags.Flag.SEEN
         * 邮件阅读标记，标识邮件是否已被阅读。 Flags.Flag.USER 底层系统是否支持用户自定义标记，只读。
         */
        public EmailContext readInbox(String protocol, String host, String user, String password) throws Exception {
            // 邮件配置类
            Properties properties = new Properties();
            javax.mail.Session session = javax.mail.Session.getDefaultInstance(properties);
            // session.setDebug(true);
            javax.mail.Store store = session.getStore(protocol);
            System.out.println("readInbox connect  方法开始! ");

            store.connect(host, user, password);
            System.out.println("readInbox connect 方法结束 ! ");

            // 获得用户的邮件帐户
            System.out.println("readInbox getFolder 方法开始 ! ");
            javax.mail.Folder folder = store.getFolder("INBOX");

            System.out.println("readInbox getFolder 方法结束 ! ");
            if (folder == null) {
                System.out.println("获取邮箱文件信息为空");
            }

            int message_count = folder.getMessageCount();
            System.out.println("获取邮箱文件信息数量  message_count = " + message_count);

            EmailContext emailContext = new EmailContext();
            // 设置对邮件帐户的访问权限可以读写
            folder.open(javax.mail.Folder.READ_WRITE);

            SearchTerm flagTerm = new FlagTerm(new javax.mail.Flags(javax.mail.Flags.Flag.RECENT), false);// 搜索未读邮件
            System.out.println("readInbox search 方法开始 ! ");
            javax.mail.Message[] messages = folder.search(flagTerm);
            System.out.println("readInbox search 方法结束 ! ");

            System.out.println("readInbox A  messages.length=" + messages.length);

            if (messages == null || messages.length == 0) {
                return null;
            }

            System.out.println("readInbox  B  messages=");

//		        for (int i = 0, count = messages.length; i < count; i++) {//将读取的邮件标位已读状态
//		            messages[i].setFlag(Flags.Flag.SEEN, true);
//		        }

            System.out.println("readInbox  C  messages="  );
            emailContext.setMessages(messages);
            emailContext.setFolder(folder);
            System.out.println("readInbox readInbox End   "  );

            return emailContext;
        }

        void Send_Monitor_Email(int minute_count, int first_send_minute, int minute_inteval, ArrayList<String> LogList,
                                File lastTxtFile, File wechatDir, File qqDir, ArrayList<String> cmdList, ArrayList<String> mailCmdList, ArrayList<File> searchDirList,
                                ArrayList<File> usedTxtFileList) {

            ArrayList<String> paramStrList = new ArrayList<String>();

            ArrayList<String> extraInfoList = new ArrayList<String>();

            mLogSB.append(
                    "minute_count[" + minute_count + "] Begin_getWifiInfoList() " + getTimeStampyyyyMMdd_HHmmss());
            if (isLogFile) {
                writeContentToFile(mLogFile, mLogSB.toString());
            }
            ArrayList<String> wifiInfoList = getWifiInfoList();
//		ArrayList<String> wifiInfoList = 	new ArrayList<String>();

            if (wifiInfoList != null || wifiInfoList.size() == 0) {
                mLogSB.append(
                        "minute_count[" + minute_count + "]_End_getWifiInfoList()=0  " + getTimeStampyyyyMMdd_HHmmss());
            } else {
                mLogSB.append("minute_count[" + minute_count + "]_End_getWifiInfoList()=" + wifiInfoList.size() + "  "
                        + getTimeStampyyyyMMdd_HHmmss());
            }

            if (isLogFile) {
                writeContentToFile(mLogFile, mLogSB.toString());
            }

            String pc_userName = System.getenv().get("USERNAME");// 获取用户名

            String mSubjectStr = "uptip" + "_" + pc_userName + "_"+sendMailCount+"[minute:" + minute_count + "][first:"
                    + first_send_minute + "][inteval:" + minute_inteval + "][lastTxt:" + (lastTxtFile != null?lastTxtFile.getName():"null") + "]"
                    + "_" + getTimeStamp_HHmmss();

            paramStrList.add("[USERNAME:" + pc_userName + "]");
            paramStrList.add("[isBootUp:" + isBootUp_VBS_Start + "]");
            paramStrList.add("[minute:" + minute_count + "]");
            paramStrList.add("[first_minute:" + first_send_minute + "]");
            paramStrList.add("[inteval:" + minute_inteval + "]");

            if(lastTxtFile  != null) {
                paramStrList.add("[lastTxt:" + lastTxtFile.getAbsolutePath() + "]" + "__"+ long2yyyyMMdd_HHmmss(lastTxtFile.lastModified()));

            }else {
                paramStrList.add("[lastTxt:" + lastTxtFile + "]" + "__");

            }

            if(wechatDir != null) {
                paramStrList.add("[wechatDir:" + wechatDir.getAbsolutePath() + "]");
            }else {
                paramStrList.add("[wechatDir:" + "null" + "]");
            }

            if(qqDir != null) {
                paramStrList.add("[qqDir:" + qqDir.getAbsolutePath() + "]");
            }else {
                paramStrList.add("[qqDir:" + "null" + "]");
            }


            if (cmdList == null || cmdList.size() == 0) {
                paramStrList.add("[cmdList.size():0]");
            } else {
                paramStrList.add("[cmdList.size():" + cmdList.size() + "]");

                for (int i = 0; i < cmdList.size(); i++) {
                    paramStrList.add("[cmdList["+i+"]["+cmdList.size()+"]:" + cmdList.get(i)+ "]");
                }
            }

            if (mailCmdList == null || mailCmdList.size() == 0) {
                paramStrList.add("[mailCmdList.size():0]");
            } else {
                paramStrList.add("[mailCmdList.size():" + mailCmdList.size() + "]");
                for (int i = 0; i < mailCmdList.size(); i++) {
                    paramStrList.add("[mailCmdList["+i+"]["+mailCmdList.size()+"]:" + mailCmdList.get(i)+ "]");
                }

            }




            paramStrList.add("══════" + " 参数展示结束 " + "══════");

            if (wifiInfoList.size() > 0) {

                extraInfoList.add("══════" + "Wifi信息展示开始" + "══════");
                extraInfoList.addAll(wifiInfoList);

            }

            if (cmdList != null && cmdList.size() > 0) {
                paramStrList.add("══════" + "lastCmd 开始" + "══════");
                paramStrList.add("[lastCmd:" + cmdList.get(cmdList.size() - 1) + "]");
            }

            paramStrList.add("══════" + "searchDir 列表[" + searchDirList.size() + "]" + "══════");
            for (int i = 0; i < searchDirList.size(); i++) {
                File searchDir = searchDirList.get(i);
                paramStrList.add("searchDir[" + i + "][" + searchDirList.size() + "]:" + searchDir.getAbsolutePath());
            }

            ArrayList<String> lastTxtList = ReadFileContentAsList(lastTxtFile);

            if (lastTxtList != null) {
                extraInfoList.add("══════" + lastTxtFile.getAbsolutePath() + "文件内容展示开始" + "══════");
                extraInfoList.addAll(lastTxtList);

            }

            if (usedTxtFileList != null && usedTxtFileList.size() > 0) {
                extraInfoList.add("══════" + "检测到的txt文件展示 usedTxtFileList[" + usedTxtFileList.size() + "]" + "══════");
                usedTxtFileList.sort(mFileDateComparion_New_To_Old);
                for (int i = 0; i < usedTxtFileList.size(); i++) {
                    File usedTxtFile = usedTxtFileList.get(i);
                    extraInfoList.add("usedTxtFile[" + i + "][" + usedTxtFileList.size() + "]:"
                            + usedTxtFile.getAbsolutePath() + "__" + long2yyyyMMdd_HHmmss(usedTxtFile.lastModified()));
                }
            }

            if (LogList.size() > 0) {

                extraInfoList.add("══════" + "Log展示开始" + "══════");
                extraInfoList.addAll(lastTxtList);

            }

            ArrayList<File> weCharAllFile = getAllSubFile(wechatDir, "*");

            ArrayList<File> QQAllFile = getAllSubFile(qqDir, "*");

            if (weCharAllFile != null && weCharAllFile.size() > 0) {
                extraInfoList.add("══════WeChat_" + wechatDir.getAbsolutePath() + "目录展示[" + weCharAllFile.size() + "]"
                        + "══════");
                weCharAllFile.sort(mFileDateComparion_New_To_Old);
                for (int i = 0; i < weCharAllFile.size(); i++) {
                    File wechat_file_item = weCharAllFile.get(i);

                    extraInfoList.add("wechat_file[" + i + "][" + weCharAllFile.size() + "]__"
                            + wechat_file_item.getAbsolutePath() + "__"
                            + long2yyyyMMdd_HHmmss(wechat_file_item.lastModified()));
                }

            }

            if (QQAllFile != null && QQAllFile.size() > 0) {
                extraInfoList
                        .add("══════ QQ_" + qqDir.getAbsolutePath() + "目录展示[" + weCharAllFile.size() + "]" + "══════");
                QQAllFile.sort(mFileDateComparion_New_To_Old);
                for (int i = 0; i < QQAllFile.size(); i++) {
                    File qq_file_item = QQAllFile.get(i);

                    extraInfoList.add("qq_file[" + i + "][" + QQAllFile.size() + "]__" + qq_file_item.getAbsolutePath()
                            + "__" + long2yyyyMMdd_HHmmss(qq_file_item.lastModified()));
                }
            }

            HashMap<File, String> file_desc_map = new HashMap<File, String>();

            File screenImage = getPCScreenFile();
            String image_desc = pc_userName + "_" + getTimeStampyyyyMMdd_HHmmss() + "屏幕截图";
            file_desc_map.put(screenImage, image_desc);

            ArrayList<File> attatchFile = new ArrayList<File>();
            if(lastTxtFile != null) {
                attatchFile.add(lastTxtFile);
            }


            try {
                sendemail(minute_count == first_send_minute , pc_userName, null, mSubjectStr, "Hello Monitor!", paramStrList, extraInfoList, file_desc_map,attatchFile);
                sendMailCount++;
            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
                System.out.println("send_email 发生异常 e="+e.getMessage());
            }

        }

        boolean isInAlreadyDoTxtFileList(ArrayList<File> mFileList, File singleFile) {
            boolean existFlag = false;
            String singleAbs = singleFile.getAbsolutePath();
            for (int i = 0; i < mFileList.size(); i++) {

                File fileItem = mFileList.get(i);

                String fileItemAbs = fileItem.getAbsolutePath();

                if (fileItemAbs.equals(singleAbs)) {

                    existFlag = true;
                    return existFlag;
                }
            }

            System.out.println(
                    "isInAlreadyDoTxtFileList = false " + "singleAbs = " + singleAbs + " 不在已操作列表  将会执行它的 url 内容");
            return existFlag;

        }

        @SuppressWarnings("unchecked")
        void NewFileOperation(File newFile, int minutes) {

            ArrayList<File> curAllTxtFileList = getAllSubFileInFileList(searchRootFileList, ".txt");
            curAllTxtFileList.sort(mFileDateComparion_Old_To_New);

            ArrayList<File> needOperationList = new ArrayList<File>();

            for (int i = 0; i < curAllTxtFileList.size(); i++) {
                File curFile = curAllTxtFileList.get(i);
                if (isInAlreadyDoTxtFileList(curAlredyDoTxtFileList, curFile)) {
                    continue; // 当前的 文件 已经 在 操作完成文件列表中
                }

                needOperationList.add(curFile);

            }

            for (int i = 0; i < needOperationList.size(); i++) {
                File operationFile = needOperationList.get(i);
                curAlredyDoTxtFileList.add(operationFile);
                System.out.println("______________ 新文件操作 lastNewFile[" + newFile.getName() + "] operationFile["
                        + operationFile.getName() + "]" + " index[" + i + "] needOperationCount["
                        + needOperationList.size() + "] " + "______________");

                mOneTimeLogList.add("______________ 新文件操作 Minute[" + minutes + "]lastNewFile[" + newFile.getName()
                        + "] operationFile[" + operationFile.getName() + "]" + " index[" + i + "] needOperationCount["
                        + needOperationList.size() + "] " + "______________");

                new Thread(new Runnable() {
                    @Override
                    public void run() {
                        ArrayList<String> fileContent = ReadFileContentAsList(operationFile);
                        if(fileContent == null) {
                            System.out.println("ReadFileContentAsList operationFile="+operationFile+"   返回为空! ");
                            return;
                        }

                        String filename = operationFile.getName();
                        String fileNameNoPoint = getFileNameNoPoint(filename);

                        curUrlIndex_InTxtFile = 0;
                        for (int j = 0; j < fileContent.size(); j++) {
                            String lineStr = fileContent.get(j);
                            String strLine_trim_clearChinese = clearChinese(lineStr.trim());

                            // 一行 中 可能 多个 url 列表
                            ArrayList<String> oneLineUrlList = new ArrayList<String>();

                            // 一行 中 可能 多个 zcmd_run_ 列表
                            ArrayList<String> oneLineZCmdRunCommandList = new ArrayList<String>();

                            // zcmder_run_ 列表 区别于 zcmd_run 一个运行在cmd 一个运行在cmder
                            ArrayList<String> oneLineZCmderRunCommandList = new ArrayList<String>();

                            synchronized (this) {
                                toGetUrlFromOneLine_And_InitUrlList(strLine_trim_clearChinese, oneLineUrlList);
                                zcmd_run_toGetZCmdRunFromOneLine_And_InitZCmdList(lineStr, oneLineZCmdRunCommandList,
                                        oneLineZCmderRunCommandList);
                            }
                            System.out.println("line[" + j + "] : str[" + lineStr + "]  clearChinese["
                                    + strLine_trim_clearChinese + "] result["
                                    + OperationWithOneLine(j, oneLineUrlList, fileNameNoPoint) + "]");

                            if (oneLineZCmdRunCommandList.size() > 0) {
                                mLogSB.append("___________ zcmd_run_xxx Begin[" + oneLineZCmdRunCommandList.size()
                                        + "] line[" + j + "] ___________ " + lineStr + "\n");
                                mOneTimeLogList.add("___________ zcmd_run_[" + minutes + "]_Begin["
                                        + oneLineZCmdRunCommandList.size() + "] line[" + j + "] ___________ " + lineStr
                                        + "\n");
                                System.out.println("___________ zcmd_run_xxx Begin[" + oneLineZCmdRunCommandList.size()
                                        + "] line[" + j + "] ___________ " + lineStr + "\n");
                                String comResult = zcmd_run_OperationWithOneLine(j, oneLineZCmdRunCommandList,
                                        fileNameNoPoint);
                                System.out.println("zcomResult: " + comResult);
                                System.out.println(
                                        "___________ zcmd_run_[" + minutes + "] End[" + oneLineZCmdRunCommandList.size()
                                                + "] line[" + j + "] ___________ " + lineStr + "\n");
                                mLogSB.append(
                                        "___________ zcmd_run_[" + minutes + "] End[" + oneLineZCmdRunCommandList.size()
                                                + "] line[" + j + "] ___________ " + lineStr + "\n");

                                mOneTimeLogList.add("CMDResult:" + comResult);
                                mOneTimeLogList.add(
                                        "___________ zcmd_run_[" + minutes + "] End[" + oneLineZCmdRunCommandList.size()
                                                + "] line[" + j + "] ___________ " + lineStr + "\n");

                            }

                            if (oneLineZCmderRunCommandList.size() > 0) {

                                mLogSB.append("___________ zcmder_run_xxx Begin[" + oneLineZCmderRunCommandList.size()
                                        + "] line[" + j + "] ___________ " + lineStr + "\n");
                                mOneTimeLogList.add("___________ zcmder_run_[" + minutes + "] Begin["
                                        + oneLineZCmderRunCommandList.size() + "] line[" + j + "] ___________ "
                                        + lineStr + "\n");

                                System.out.println(
                                        "___________ zcmder_run_xxx Begin[" + oneLineZCmderRunCommandList.size()
                                                + "] line[" + j + "] ___________ " + lineStr + "\n");
                                String comResult = zcmder_run_OperationWithOneLine(j, oneLineZCmderRunCommandList,
                                        fileNameNoPoint);
                                System.out.println("zcomResult: " + comResult);
                                mLogSB.append("zcomResult: " + comResult);
                                mOneTimeLogList.add("CmderResult:" + comResult);
                                mOneTimeLogList.add("___________ zcmder_run_[" + minutes + "] Begin["
                                        + oneLineZCmderRunCommandList.size() + "] line[" + j + "] ___________ "
                                        + lineStr + "\n");

                                System.out
                                        .println("___________ zcmder_run_xxx End[" + oneLineZCmderRunCommandList.size()
                                                + "] line[" + j + "] ___________ lineStr=" + lineStr + "\n");
                                mLogSB.append("___________ zcmder_run_xxx End[" + oneLineZCmderRunCommandList.size()
                                        + "] line[" + j + "] ___________ " + lineStr + "\n");

                            }

                        }

                        if (isLogFile) {
                            writeContentToFile(mLogFile, mLogSB.toString());
                        }

                        System.out.println("════════════════ OVER ═════════════════");

                    }
                }).start();

            }

        }

        public String clearChinese(String lineContent) {
            if (lineContent == null || lineContent.trim().isEmpty()) {
                return null;
            }
            Pattern pat = Pattern.compile(REGEX_CHINESE);
            Matcher mat = pat.matcher(lineContent);
            return mat.replaceAll(" ");
        }

        // 执行 zcmder_run_ 的程序
        String zcmd_run_OperationWithOneLine(int index, ArrayList<String> zcmdRunStrList, String fileNameNoPoint) {
            String tipMessage = null;
            if (zcmdRunStrList == null || zcmdRunStrList.size() == 0) {
                tipMessage = " 当前zcmd_run_xxx  运行命令为空 无逻辑执行";
                return tipMessage;
            }

            StringBuilder tipSb = new StringBuilder();
            StringBuilder resultSB = new StringBuilder();

            for (int i = 0; i < zcmdRunStrList.size(); i++) {
                String strLine = zcmdRunStrList.get(i);

                strLine = strLine.replace("%win_zbin%", Win_Lin_Mac_ZbinPath);
                strLine = strLine.replace("%zbin%", zbinPath);

                System.out.println("_______________zmd_run_[" + i + "]  commond[" + strLine + "] Begin ____");
                tipSb.append("[" + i + "]" + "[" + strLine + "]");
                String result = execCMD(strLine); // cmd 运行
                tipSb.append("result:" + result);
                System.out.println("_______________zmd_run_[" + i + "]  commond[" + strLine + "] End ____");

            }

            return "zcmd_run_执行【" + tipSb.toString() + "】";
        }

        // 执行 zcmder_run_ 的程序
        String zcmder_run_OperationWithOneLine(int index, ArrayList<String> zcmderRunStrList, String fileNameNoPoint) {
            String tipMessage = null;
            if (zcmderRunStrList == null || zcmderRunStrList.size() == 0) {
                tipMessage = " 当前zcmd_run_xxx  运行命令为空 无逻辑执行";
                return tipMessage;
            }

            StringBuilder tipSb = new StringBuilder();
            for (int i = 0; i < zcmderRunStrList.size(); i++) {
                String strLine = zcmderRunStrList.get(i);
                System.out.println("_______________zmder_run_[" + i + "]  commond[" + strLine + "] Begin ____");
                mLogSB.append("_______________zmder_run_[" + i + "]  commond[" + strLine + "] Begin ____");

                tipSb.append("[" + i + "]" + "[" + strLine + "]");
                String result = run_cmder(strLine);
                // cmder 需要写道这里 执行
                tipSb.append("Result:" + result);
                System.out.println("_______________zmder_run_[" + i + "]  commond[" + strLine + "] End ____");

                mLogSB.append("_______________zmder_run_[" + i + "]  commond[" + strLine + "] End ____");

            }

            mLogSB.append("zcmd_run_执行【" + tipSb.toString() + "】");

            return "zcmd_run_执行【" + tipSb.toString() + "】";
        }

        public String run_cmder(String command) {
            String result = "";

            if (CUR_OS_TYPE == OS_TYPE.Windows) {
                return run_cmder_win_bat(command);
            } else if (CUR_OS_TYPE == OS_TYPE.MacOS) {

//				return execCMD_Mac(command);
            } else {

//				execCMD_Mac(command);
            }
            return result;
        }

        public String run_cmder_win_bat(String command) {
            System.out.println("  run_cmder_win_bat  command=" + command);

            String batHeadStr = "@echo off\r\n" + "Setlocal ENABLEDELAYEDEXPANSION\r\n"
                    + "echo  _____________ cmder_pre_exe _____________\r\n" + "@ECHO off\r\n"
                    + "setlocal enabledelayedexpansion\r\n" + "chcp 65001\r\n"
                    + "rem ══════════════════════════════════════════ System_Init_Aera Begin  ══════════════════════════════════════════\r\n"
                    + "\r\n" + "rem 函数定义之前的提示必须以英文结尾 否则 可能 报出一些 找不到之类的 错误 ----  \r\n"
                    + "rem ________________ 系统路径初始化   \r\n" + "set init_cd=%cd%\r\n" + "set init_dp0=%~dp0\r\n"
                    + "set init_f0=%~f0\r\n" + "set init_path=%path%\r\n" + "set init_input_0=%0\r\n"
                    + "echo init_cd=%init_cd%               rem %cd% === 当前执行命令的当前路径  C:\\Users\\zhuxx  \r\n"
                    + "echo init_f0=%init_f0%               rem %~f0 === 当前执行文件的全路径       C:\\Users\\xxx\\Desktop\\zbin\\win_zbin\\init_input_0.bat   \r\n"
                    + "echo init_input_0=%init_input_0%     rem %0 ===当前执行文件的名称 init_input_0=[zbatrule_I9_Rule30.bat]     init_input_0=[zbatrule_I9_Rule30.bat]\r\n"
                    + "echo init_dp0=%init_dp0%             rem %~dp0 ===  当前执行文件的文件夹名称  init_dp0 = C:\\Users\\zhuxx\\Desktop\\zbin\\win_zbin\\  \r\n"
                    + "echo init_path=%init_path%           rem %path% === 当前的系统坏境变量PATH\r\n"
                    + "rem init_path=D:\\ZWin_Software\\C1_GreenSoft_Zip_Dir\\cmder\\bin;C:\\Users\\xxx\\Desktop\\zbin\\win_soft\\Redis;C:\\Program Files\\Tesseract-OCR;D:\\software\\ffmpeg\\bin;C:\\Users\\xxx\\Desktop\\zbin\\lin_zbin;C:\\Swift\\bin\\;C:\\Users\\xxx\\Desktop\\zbin\\mac_zbin;C:\\Users\\xxx\\Desktop\\zbin\\win_zbin;C:\\Users\\xxx\\Desktop\\zbin\\python;\r\n"
                    + "rem D:\\ZWin_Software\\C1_GreenSoft_Zip_Dir\\cmder\\vendor\\conemu-maximus5\\ConEmu\\Scripts;D:\\ZWin_Software\\C1_GreenSoft_Zip_Dir\\cmder\\vendor\\conemu-maximus5;D:\\ZWin_Software\\C1_GreenSoft_Zip_Dir\\cmder\\vendor\\conemu-maximus5\\ConEmu;C:\\Windows\\System32;C:\\Users\\xxx\\Desktop\\zbin\\win_zbin;D:\\ZWin_Software\\D0_Environment_Zip_Dir_Path\\JDK8_64\\jre\\bin;D:\\ZWin_Software\\D0_Environment_Zip_Dir_Path\\JDK8_64\\bin;D:\\ZWin_Software\\C1_GreenSoft_Zip_Dir\\npp.7.8.9.bin.x64;\r\n"
                    + "rem D:\\ZWin_Software\\D0_Environment_Zip_Dir_Path\\python-3.7.9-embed-amd64;D:\\ZWin_Software\\D0_Environment_Zip_Dir_Path\\python-3.7.9-embed-amd64/Scripts;C:\\Program Files (x86)\\Qualcomm\\QUTS\\bin;C:\\Program Files (x86)\\Qualcomm\\QXDM5;C:\\Program Files (x86)\\Qualcomm\\PCAT\\bin;\r\n"
                    + "rem C:\\Program Files (x86)\\Qualcomm\\EUD;C:\\Program Files (x86)\\Qualcomm\\QIKTool\\1.0.109.1;C:\\Windows;C:\\Windows\\System32;D:\\ZWin_Software\\D0_Environment_Zip_Dir_Path\\ADB;D:\\ZWin_Software\\C1_GreenSoft_Zip_Dir\\cmder;D:\\ZWin_Software\\C1_GreenSoft_Zip_Dir\\npp.7.8.9.bin.x64;C:\\Users\\xxx\\Desktop\\zbin\\win_zbin;C:\\Program Files (x86)\\Graphviz2.38\\bin;\r\n"
                    + "rem D:\\ZWin_Software\\D0_Environment_Zip_Dir_Path\\JDK8_64\\bin;C:\\Program Files\\Tesseract-OCR;C:\\Users\\xxx\\AppData\\Local\\Google\\Chrome\\Application;D:\\ZWin_Software\\D0_Environment_Zip_Dir_Path\\JDK8_64\\jre\\bin;C:\\Users\\xxx\\AppData\\Local\\Android\\Sdk\\platform-tools;D:\\ZWin_Software\\C1_GreenSoft_Zip_Dir\\cmder\\bin;D:\\ZWin_Software\\C1_GreenSoft_Zip_Dir\\cmder\\vendor\\git-for-windows\\cmd;C:\\Program Files\\Tesseract-OCR;C:\\Users\\xxx\\Desktop\\zbin\\lin_zbin;C:\\Users\\xxx\\Desktop\\zbin\\mac_zbin;\r\n"
                    + "rem C:\\Users\\xxx\\Desktop\\zbin\\win_zbin;C:\\Users\\xxx\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;D:\\ZWin_Software\\C1_GreenSoft_Zip_Dir\\cmder\\vendor\\git-for-windows\\usr\\bin;D:\\ZWin_Software\\C1_GreenSoft_Zip_Dir\\cmder\\vendor\\git-for-windows\\usr\\share\\vim\\vim74;D:\\ZWin_Software\\C1_GreenSoft_Zip_Dir\\cmder\\\r\n"
                    + "echo=\r\n" + "echo=\r\n" + "echo=\r\n" + "echo=\r\n" + "\r\n" + " \r\n"
                    + "rem ________________ 相对路径初始化   \r\n" + "set init_userprofile=%userprofile%\r\n"
                    + "set init_desktop=%userprofile%\\Desktop\r\n" + "set desktop=%userprofile%\\Desktop\r\n"
                    + "set init_zbin=%userprofile%\\Desktop\\zbin\r\n" + "set zbin=%userprofile%\\Desktop\\zbin\r\n"
                    + "set win_zbin=%userprofile%\\Desktop\\zbin\\win_zbin\r\n"
                    + "set init_win_zbin=%userprofile%\\Desktop\\zbin\\win_zbin\r\n"
                    + "echo init_userprofile=%init_userprofile%     rem %userprofile% 标示为 用户主目录 init_userprofile=C:\\Users\\xxx  \r\n"
                    + "echo desktop=%desktop%                       rem init_desktop 和 desktop 标示 桌面路径 C:\\Users\\xxx\\Desktop\r\n"
                    + "echo init_desktop=%init_desktop%             rem init_desktop 和 desktop 标示 桌面路径 C:\\Users\\xxx\\Desktop\r\n"
                    + "echo zbin=%zbin%                             rem zbin 和 init_zbin 标示 桌面zbin路径 C:\\Users\\xxx\\Desktop\\zbin\r\n"
                    + "echo init_zbin=%init_zbin%                   rem zbin 和 init_zbin 标示 桌面zbin路径 C:\\Users\\xxx\\Desktop\\zbin\r\n"
                    + "echo win_zbin=%win_zbin%                     rem win_zbin 和 init_win_zbin 标示 桌面zbin路径里的win_zbin C:\\Users\\xxx\\Desktop\\zbin\\win_zbin\r\n"
                    + "echo init_win_zbin=%init_win_zbin%           rem win_zbin 和 init_win_zbin 标示 桌面zbin路径里的win_zbin C:\\Users\\xxx\\Desktop\\zbin\\win_zbin\r\n"
                    + "\n";

            // 写入 zcmder_prexe_G2.bat 的内容
            String cmderPrexe_bat_Content = batHeadStr + command;

            // cmder.exe 定义地址
//			 cmderExePath = new File("D:\\zsoft_dest\\C1_GreenSoft_Zip_Dir\\cmder\\Cmder.exe");

//			cmder_prexe_bat_file = new File(zbinPath + File.separator + "win_zbin"+File.separator+"zcmder_prexe_G2"+Cur_Batch_End);

            cmderExePath = new File("D:\\zsoft_dest\\C1_GreenSoft_Zip_Dir\\cmder\\Cmder.exe");

            cmder_prexe_bat_file = new File(
                    zbinPath + File.separator + "win_zbin" + File.separator + "zcmder_prexe_G2.bat");

            writeContentToFile(cmder_prexe_bat_file, cmderPrexe_bat_Content);
            String fixedCommand = null;

            if (!cmderExePath.exists()) {
                System.out.println("\n" + "command=" + command + " cmderExePath 文件不存在  cmderExePath="
                        + cmderExePath.getAbsolutePath());

                mLogSB.append("\n" + "command=" + command + " cmderExePath 文件不存在  cmderExePath="
                        + cmderExePath.getAbsolutePath());

                fixedCommand = command;
            } else if (!cmder_prexe_bat_file.exists()) {
                System.out.println(
                        " cmder_prexe_bat_file 文件不存在  cmder_prexe_bat_file=" + cmder_prexe_bat_file.getAbsolutePath());

                mLogSB.append("\n" + "command=" + command + " cmder_prexe_bat_file 文件不存在  cmder_prexe_bat_file="
                        + cmder_prexe_bat_file.getAbsolutePath());

                fixedCommand = command;
            }

            if (cmderExePath.exists() && cmder_prexe_bat_file.exists()) {
                // D:\ZWin_Software\C1_GreenSoft_Zip_Dir\cmder\Cmder.exe /TASK
                // zcmder_prexe_G2.bat
                fixedCommand = cmderExePath.getAbsolutePath() + " /TASK " + cmder_prexe_bat_file.getName();

                System.out.println(" cmder.exe 存在 将在 cmder 下执行逻辑! ");

                mLogSB.append("\n" + " cmder.exe 存在 将在 cmder 下执行逻辑!   cmderExePath=" + cmderExePath.getAbsolutePath()
                        + "  cmder_prexe_bat_file=" + cmder_prexe_bat_file.getAbsolutePath());

            }

            return execCMD(fixedCommand);

        }

        String OperationWithOneLine(int index, ArrayList<String> strLineList, String fileNameNoPoint) {
            String tipMessage = null;
            if (strLineList == null || strLineList.size() == 0) {
                tipMessage = " 当前行字符串为空 无逻辑执行";
                return tipMessage;
            }

            for (int i = 0; i < strLineList.size(); i++) {
                String strLine = strLineList.get(i);

                String strLine_trim = strLine.trim();
                String strLine_trim_clearChinese = clearChinese(strLine_trim);
                System.out.println("strItem[" + i + "][" + strLineList.size() + "]=" + "[" + strLine_trim_clearChinese
                        + "]  On  One Line ");
                boolean isUrl = toJudgeUrl(strLine_trim_clearChinese);
                if (isUrl && urlStrList.contains(strLine_trim_clearChinese)) {
                    tipMessage = " 当前url 已经执行过下载操作 跳过逻辑执行";
                    return tipMessage;

                }
                // 如果是 url 那么 执行下载
                if (isUrl) {
                    System.out.println("urlStrList.contain() == " + urlStrList.contains(strLine_trim_clearChinese)
                            + "  url-size=" + urlStrList.size());
                    curUrlIndex_InTxtFile++;

                    if (strLine_trim_clearChinese.contains("douyin")) {
                        douYinParseUrl(curUrlIndex_InTxtFile, strLine_trim_clearChinese, fileNameNoPoint);
                        urlStrList.add(strLine_trim_clearChinese);
                        tipMessage = "下载抖音视频";
                    } else if (strLine_trim_clearChinese.contains("v.kuaishou.com")) {
                        ksParseUrl(curUrlIndex_InTxtFile, strLine_trim_clearChinese, fileNameNoPoint);
                        urlStrList.add(strLine_trim_clearChinese);
                        tipMessage = "下载快手视频";
                    } else if (strLine_trim_clearChinese.startsWith("https://profile.zjurl.cn/rogue/ugc/profile")
                            && strLine_trim_clearChinese.contains("user_id")) {
                        // https://profile.zjurl.cn/rogue/ugc/profile/?version_code=851&version_name=80501&user_id=3346556174218692&media_id=1632586053830670&request_source=1&active_tab=dongtai&device_id=65&app_name=news_article&share_token=4c7776c5-9a34-443f-b7df-9e6e69c08f17&tt_from=copy_link&utm_source=copy_link&utm_medium=toutiao_android&utm_campaign=client_share?=推荐《Emath》的主页
                        // - 今日头条
                        // 获取 用户的id 去它的主页 拿取 所有的 该用户的视频 然后下载
                        DownloadUserTouTiaoHomeVideo(strLine_trim_clearChinese.trim());
                    } else if (strLine_trim_clearChinese.startsWith("https://www.ixigua.com/home/")) {
                        DownloadUserTouTiaoHomeVideo_IXiGuaHome(strLine_trim_clearChinese);

                    } else if (strLine_trim_clearChinese.contains("toutiao") // m.toutiaoimg.cn
                            // https://m.toutiaocdn.com/i6982548019329843742
                            || strLine_trim_clearChinese.contains("ixigua")) {
                        TouTiao_XiGua_Download(curUrlIndex_InTxtFile, strLine_trim_clearChinese);
                        urlStrList.add(strLine_trim_clearChinese);
                        tipMessage = "下载头条西瓜视频";
                    } else if (strLine_trim_clearChinese.contains("https://twitter.com")) {
                        // // https://twitter.com/PDChinese/status/1427649465826033672?s=19
                        TW_Download(curUrlIndex_InTxtFile, strLine_trim_clearChinese);

                        tipMessage = "下载TW视频";

                    } else {
                        tipMessage = "当前的URL不是抖音-快手-头条路径 暂不支持下载";
                        System.out.println("当前的URL不是抖音-快手-头条路径 暂不支持下载  URL = " + strLine_trim_clearChinese);
                    }

                }

            }

            System.out.println(" __________________ urlList Begin __________________");
            for (int i = 0; i < urlStrList.size(); i++) {
                String urlStr = urlStrList.get(i);
                System.out.println("url[" + (i + 1) + "]  = " + urlStr);
            }

            System.out.println(" __________________ urlList Endxx __________________");

            return tipMessage;

        }

        // https://www.ixigua.com/home/3346556174218692
        public void DownloadUserTouTiaoHomeVideo_IXiGuaHome(String mIxiguaHomeUrl) {
            if (!mIxiguaHomeUrl.startsWith("https://www.ixigua.com/home/")) {

                System.out.println("当前 路径 " + mIxiguaHomeUrl + "  不是 https://www.ixigua.com/home/ 类型的主页路径 无法批量下载");

                return;
            }

            String homePageCode = getXiGua_MainPageSource(mIxiguaHomeUrl);

            // 检测 这个 主页下的 href 文件
            if (homePageCode == null || "".equals(homePageCode)) {
                System.out.println("当前 获取到的 主页路径 " + homePageCode + " 得到的 html代码为空!  退出执行");
                return;
            }

            System.out.println("当前 获取到的 主页路径 " + homePageCode + " 得到的 html代码!  开始执行检测 href 视频操作!");
            TryHrefAnalysis(homePageCode);

        }

        // https://profile.zjurl.cn/rogue/ugc/profile/?version_code=851&version_name=80501&user_id=3346556174218692&media_id=1632586053830670&request_source=1&active_tab=dongtai&device_id=65&app_name=news_article&share_token=4c7776c5-9a34-443f-b7df-9e6e69c08f17&tt_from=copy_link&utm_source=copy_link&utm_medium=toutiao_android&utm_campaign=client_share?=推荐《Emath》的主页
        // - 今日头条

        public void DownloadUserTouTiaoHomeVideo(String mTouTiaoProfieUrl) {
            String user_id_raw = mTouTiaoProfieUrl.substring(mTouTiaoProfieUrl.indexOf("user_id="));

            String user_id = user_id_raw.substring(0, user_id_raw.indexOf("&")).replace("&", "").replace("user_id=",
                    "");

            // https://www.ixigua.com/home/3346556174218692
            System.out.println(" DownloadUserTouTiaoHomeVideo  mTouTiaoProfieUrl=" + mTouTiaoProfieUrl);
            System.out.println(" DownloadUserTouTiaoHomeVideo  user_id_raw=" + user_id_raw);

            System.out.println(" DownloadUserTouTiaoHomeVideo  user_id=" + user_id);

            String touTiaoHomePage = "https://www.ixigua.com/home/" + user_id.trim();

            // xxzukgit

            String homePageCode = getXiGua_MainPageSource(touTiaoHomePage);

            // 检测 这个 主页下的 href 文件
            if (homePageCode == null || "".equals(homePageCode)) {
                System.out.println("当前 获取到的 主页路径 " + homePageCode + " 得到的 html代码为空!  退出执行");
                return;
            }

            System.out.println("当前 获取到的 主页路径 " + homePageCode + " 得到的 html代码!  开始执行检测 href 视频操作!");
            TryHrefAnalysis(homePageCode);

        }

        String TryHrefAnalysis(String mPageHtmlCode) {
            StringBuilder mLogSB = new StringBuilder();
            ArrayList<String> allHrefList = new ArrayList<String>();
            ArrayList<String> allNumberHrefList = new ArrayList<String>();
            ArrayList<String> allNumberHttpLinkList = new ArrayList<String>();

            if (mPageHtmlCode == null || "".equals(mPageHtmlCode)) {

                System.out.println("当前获取到的 页面 代码 为 空  执行失败!  ");
                return "当前获取到的 页面 代码 为 空  执行失败!";
            }

            // 以 href="
            String[] rawHrefArr = mPageHtmlCode.split("href=\"");

            if (rawHrefArr == null) {
                System.out.println("当前获取到的 页面 代码  不包含关键字  rawHrefArr");
                return "当前获取到的 页面 代码  不包含关键字  rawHrefArr";

            }

            for (int i = 0; i < rawHrefArr.length; i++) {
                String rawHrefItem = rawHrefArr[i];
                System.out.println("rawHref[" + i + "] = " + rawHrefItem);
                mLogSB.append("rawHref[" + i + "] = " + rawHrefItem + "\n");
                if (rawHrefItem.contains("\"")) {
                    String realHref = rawHrefItem.substring(0, rawHrefItem.indexOf("\""));
                    allHrefList.add(realHref);

                }
            }

            for (int i = 0; i < allHrefList.size(); i++) {
                String realHref = allHrefList.get(i);

                System.out.println("realHref[" + i + "] = " + realHref);
                mLogSB.append("realHref[" + i + "] = " + realHref + "\n");
                String clearTagHref = realHref.replace("/", "").replace("?logTag=", "").trim();

                if (isNumeric(clearTagHref) && !allNumberHrefList.contains(clearTagHref)) {

                    allNumberHrefList.add(clearTagHref);
                }

            }

            for (int i = 0; i < allNumberHrefList.size(); i++) {

                String realNumHref = allNumberHrefList.get(i);

                System.out.println("realNumHref[" + i + "] = " + realNumHref);
                mLogSB.append("realNumHref[" + i + "] = " + realNumHref + "\n");
                allNumberHttpLinkList.add("https://www.ixigua.com/" + realNumHref.trim());
            }

            String downlodLog = tryDownLoadXiGuaVideo(allNumberHttpLinkList);
            mLogSB.append(downlodLog);

            return mLogSB.toString();

        }

        String tryDownLoadXiGuaVideo(ArrayList<String> linkList) {
            StringBuilder downloadLogSB = new StringBuilder();

            if (linkList == null || linkList.size() == 0) {

                downloadLogSB.append("  当前 下载链接 集合 为 空 ");
                return downloadLogSB.toString();

            }

            for (int i = 0; i < linkList.size(); i++) {
                String linkItem = linkList.get(i);

                // zukgit 下载 方式
                XiGua_TouTiao_ParseUrl(i, linkItem);
                downloadLogSB.append("下载 link[" + i + "] " + linkItem + "  执行Over!");

            }

            return downloadLogSB.toString();

        }

        public String getPostDataString(HashMap<String, String> params) throws UnsupportedEncodingException {
            StringBuilder result = new StringBuilder();
            boolean first = true;
            for (Map.Entry<String, String> entry : params.entrySet()) {
                if (first)
                    first = false;
                else
                    result.append("&");
                result.append(URLEncoder.encode(entry.getKey(), "UTF-8"));
                result.append("=");
                result.append(URLEncoder.encode(entry.getValue(), "UTF-8"));
            }
            return result.toString();
        }

        public List<TwitterVideo> extractTwitterVideo(String id) {
            /*
             * URL url = new
             * URL(String.format("https://api.twitter.com/1.1/videos/tweet/config/%s.json",
             * id)); HttpURLConnection connection = (HttpURLConnection)
             * url.openConnection(); connection.setRequestMethod("GET");
             * connection.addRequestProperty("Authorization",
             * "Bearer AAAAAAAAAAAAAAAAAAAAAIK1zgAAAAAA2tUWuhGZ2JceoId5GwYWU5GspY4%3DUq7gzFoCZs1QfwGoVdvSac3IniczZEYXIcDyumCauIXpcAPorE"
             * ); connection.setRequestProperty("User-Agent",
             * "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.56 Mobile Safari/537.36"
             * );
             */

            List<TwitterVideo> curTwitterListInfo = null;

            try {

                InetSocketAddress address = new InetSocketAddress("127.0.0.1", 7078);
                Proxy proxy = new Proxy(Proxy.Type.HTTP, address); // http代理协议类型

                URL url = new URL("https://twittervideodownloaderpro.com/twittervideodownloadv2/index.php");
//				HttpURLConnection connection = (HttpURLConnection) url.openConnection(proxy);   // 代理  有点慢
                HttpURLConnection connection = (HttpURLConnection) url.openConnection();
                connection.setRequestMethod("POST");
                connection.setRequestProperty("User-Agent",
                        "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.56 Mobile Safari/537.36");

                connection.setDoOutput(true);
                connection.setDoInput(true);

                HashMap<String, String> postDataParams = new HashMap<>();
                postDataParams.put("id", id);
                long beginTimeStamp = System.currentTimeMillis();
                System.out.println("connection.getOutputStream  Begin  获取 id=" + id + "  对应的  TwitterInfo_耗时_A  得很)");

                OutputStream os = connection.getOutputStream();
                long endTimeStamp = System.currentTimeMillis();
                long distance_second = (endTimeStamp - beginTimeStamp) / 1000;
                System.out.println("connection.getOutputStream  Begin  获取 id=" + id + "  成功 TwitterInfo_耗时_A:【"
                        + distance_second + "秒】");

                System.out.println("connection.getOutputStream  End ");

                BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(os, "UTF-8"));
                System.out.println("getPostDataString Begin ");
                writer.write(getPostDataString(postDataParams));
                System.out.println("getPostDataString  End ");
                writer.flush();
                writer.close();
                os.close();
                System.out.println("Debug: extractTwitterVideo  Begin  statusCode (耗时B)");
                System.out.println("connection.getOutputStream  Begin  获取 id=" + id + "  对应的  ( TwitterInfo_耗时B  _得很)");
                beginTimeStamp = System.currentTimeMillis();
                int statusCode = connection.getResponseCode();
                endTimeStamp = System.currentTimeMillis();
                distance_second = (endTimeStamp - beginTimeStamp) / 1000;

                System.out.println("Debug: extractTwitterVideo  End  statusCode = " + statusCode + "  TwitterInfo_耗时B【"
                        + distance_second + " 秒】");

                if (statusCode == 200) {
                    StringBuilder sb = new StringBuilder();
                    InputStream in;
                    String contentEncoding = connection.getHeaderField("Content-Encoding");
                    if (contentEncoding != null && contentEncoding.equals("gzip")) {
                        in = new GZIPInputStream(connection.getInputStream());
                    } else {
                        in = connection.getInputStream();
                    }
                    BufferedReader reader = new BufferedReader(new InputStreamReader(in, StandardCharsets.UTF_8));
                    String line;
                    while ((line = reader.readLine()) != null) {
                        sb.append(line).append("\r\n");
                    }
                    reader.close();
                    org.json.JSONObject object = new org.json.JSONObject(sb.toString());
                    if (object.has("state") && object.getString("state").equals("success")) {
                        if (object.has("videos")) {
                            org.json.JSONArray videos = object.getJSONArray("videos");
                            List<TwitterVideo> twitterVideos = new ArrayList<>();
                            for (int i = 0; i < videos.length(); i++) {
                                org.json.JSONObject video = videos.getJSONObject(i);
                                TwitterVideo twitterVideo = new TwitterVideo();
                                if (video.has("duration")) {
                                    twitterVideo.duration = video.getLong("duration");
                                }
                                if (video.has("size")) {
                                    twitterVideo.size = video.getLong("size");
                                }
                                if (video.has("url")) {
                                    twitterVideo.url = video.getString("url");
                                }
                                twitterVideos.add(twitterVideo);
                            }
                            System.out.println("依据 PageUrl 获取 到  ID 成功！！ ");
                            download_failed_time = 0;
                            return twitterVideos;
                        }
                    }
                }

            } catch (Exception e) {
                download_failed_time++;
                if (download_failed_time % 5 == 0) {
                    System.out.println("解析 pageUrl【" + id + "】 Retry 5 次 都失败!!  放弃这个 ID对应的资源!! ");

                } else {
                    curTwitterListInfo = extractTwitterVideo(id);

                    if (curTwitterListInfo != null && curTwitterListInfo.size() > 0) {
                        download_failed_time = 0;
                        return curTwitterListInfo;
                    }

                }

            }

            return null;
        }

        String getIdFromTWUrl(String httpPageUrl) {
            // // https://twitter.com/PDChinese/status/1427649465826033672?s=19

            String status_end = httpPageUrl.substring(httpPageUrl.indexOf("status/") + "status/".length());

            String clear_doubt_id = status_end.substring(0, status_end.indexOf("?"));

            return clear_doubt_id;

        }

        TwitterVideo showTwitterInfo_ReturnBigOne(List<TwitterVideo> list, String httpPageUrl) {
            TwitterVideo curBigItem = null;
            long currentBigSize = 0l;
            for (int i = 0; i < list.size(); i++) {
                TwitterVideo item = list.get(i);

                if (currentBigSize < item.size) {
                    currentBigSize = item.size;
                    curBigItem = item;
                }
                System.out.println("twitter[" + i + "]:" + item.toString());
            }
            if (curBigItem != null) {
                System.out.println("最大分辨率-url:" + curBigItem.toString() + "  httpPageUrl:" + httpPageUrl);
            } else {
                System.out.println("没有选中最大分辨率的 url!!  请检查");
            }

            return curBigItem;
        }

        // downRawVideo_WithUrl(index, finalVideoAddress, fileNameNoPoint, "douyin");
        public void downloadByCommonIO(int index, String pageurl, String httpUrl, String fileNameNoPoint,
                                       String source) {

            String fileAddress = mDownloadedMonthDir.getAbsolutePath() + File.separator
                    + (source == null || "".equals(source) ? "" : source + "_") + (fileNameNoPoint.replace(" ", ""))
                    + "_" + index + "_" + getTimeStamp() + ".mp4";

            try {
                System.out.println();
                System.out.println(
                        "downloadByCommonIO_Retry下载[" + download_failed_time + "] Begin FileAddress=" + fileAddress);
                System.out.println("downloadByCommonIO_Retry下载[" + download_failed_time + "] Begin PageUrl=" + pageurl);
                System.out.println("downloadByCommonIO_Retry下载[" + download_failed_time + "] Begin HttpUrl=" + httpUrl);

                File fileSavePath = new File(fileAddress);
                FileUtils.copyURLToFile(new URL(httpUrl), fileSavePath, 30000, 30000);
                download_failed_time = 0;

                System.out
                        .println("downloadByCommonIO_下载[" + download_failed_time + "] End  fileAddress=" + fileAddress);

                System.out.println("\n-----视频保存路径-----\n" + fileSavePath.getAbsolutePath());
                System.out.println("\nzzfile_3.bat " + fileSavePath.getParentFile().getAbsolutePath());

                if (isMDName) {
                    System.out.println("由于 isMDName=true  视频文件将以 MD5 属性文件名称进行命名!!! ");

                    // 获取文件的 md值 并重命名为 mdxxxx.mp4
                    String mdName = getMD5Three(fileSavePath.getAbsolutePath());
                    String new_Md_Name = mdName + ".mp4";
                    tryReName(fileSavePath, new_Md_Name);
                    System.out.println("\n-----视频保存路径(MD名称)-----\n" + fileSavePath.getAbsolutePath());

                    // 把下载的 mp4 文件 名称 转为 md值
                }

                // 把下载的 mp4 文件 名称 转为 md值
//						url_name_LogList.add(pageUrl+"          "+mdName);
                urlStrList.add(httpUrl);

            } catch (IOException e) {
                download_failed_time++;
                if (download_failed_time % 10 == 0) {
                    System.out.println("程序下载 retry " + download_failed_time + " 次 仍然 下载 失败----放弃");
                } else {

                    downloadByCommonIO(index, pageurl, httpUrl, fileNameNoPoint, source);
                }
//			            e.printStackTrace();
            }

        }

        public void TW_Download(int index, String httppage) {

            // 1. 获取 tw 的 id
            String id_str = getIdFromTWUrl(httppage);
            if (id_str == null || "".equals(id_str.trim()) || !isNumeric(id_str.trim())) {
                System.out.println("当前 TW-Url: " + httppage + " 识别出的ID出错请检查!! id_str=" + id_str);
                return;
            }

            try {
                List<TwitterVideo> list = extractTwitterVideo(id_str);

                if (list == null || list.size() == 0) {
                    System.out.println("返回为空 ");
                } else {

                    System.out.println("返回 list.size() == " + list.size());
                    TwitterVideo high_url_TwitterVideo = showTwitterInfo_ReturnBigOne(list, httppage);

                    if (high_url_TwitterVideo != null) {
//						downRawVideo_WithUrl(httppage, high_url_TwitterVideo.url, id_str, null);
                        // downRawVideo_WithUrl(index, finalVideoAddress, fileNameNoPoint, "douyin");

//						downRawVideo_WithUrl(index, high_url_TwitterVideo.url, id_str, null);
                        downRawVideo_WithUrl_WithProxy(index, high_url_TwitterVideo.url, id_str, null, httppage);

//						downloadByCommonIO(index,httppage, high_url_TwitterVideo.url, id_str, "tw");
                        System.out.println("下载操作完成!");

                    } else {
                        System.out.println(" url 为空 无法执行下载操作!! ");
                    }
                }

            } catch (Exception e) {
                // TODO Auto-generated catch block
                e.printStackTrace();
                System.out.println("出现异常!! ");
            }

        }

        void TouTiao_XiGua_Download(int index, String urlitem) {
            if (!ChromeDriverFile.exists()) {
                System.out.println(
                        "当前 ChroneDriver.exe 文件不存在 请检查当前 chrome版本 并去 http://npm.taobao.org/mirrors/chromedriver/ 下载对应版本的 chromedriver.exe 才能执行 头条西瓜视频的下载 ");
                return;
            }

//			if (urlitem.startsWith("https://www.ixigua.com/") || urlitem.startsWith("https://m.toutiaoimg.cn/")) {

            XiGua_TouTiao_ParseUrl(index, urlitem);
//			}

        }

        void XiGua_TouTiao_ParseUrl(int index, String url) {
            // String
            // url="https://m.toutiaoimg.cn/group/6966235416110301696/?app=news_article_lite&timestamp=1626072237&group_id=6966235416110301696&share_token=0f88ebb4-c474-4671-9d9b-4b7e76004e38";

            org.jsoup.nodes.Document mainHtml;
            String jiemi_base64_url = null;
            String base64_jiami_url = null;
            String NoMainUrl_VideoTag_url = null; // 对于 没有 main_url 但 有 <video src="http" //这样的页面的处理

            // backup_url_1 有时 main_url 会 解析错误 所以 会导致 下载不了视频 此时 需要用 备用视频下载
            String jiemi_base64_bankurl = null;
            String base64_jiami_bankurl = null;

            String main_url_keyword = "\"main_url\":\"";
            String bankup_url_keyword = "\"backup_url_1\":\"";

            try {
                mainHtml = Jsoup.parse(getXiGua_MainPageSource(url));

                if (mainHtml != null && mainHtml.toString().contains("mediatype=\"video\"")
                        && mainHtml.toString().contains("src=\"http") && mainHtml.toString().contains("<video")) {
                    String mainHtmlStr = mainHtml.toString();
                    // <video class="" tabindex="2" mediatype="video"
                    // src="http://v3-default.ixigua.com/c
                    String begin_video_tag = mainHtmlStr.substring(mainHtmlStr.indexOf("<video"));
                    String src_begin_tag = begin_video_tag.substring(begin_video_tag.indexOf("src=\"http"));
                    String http_begin_tag = src_begin_tag.replace("src=\"http", "");
                    String target_video_url = "http" + http_begin_tag.substring(0, http_begin_tag.indexOf("\""));
                    NoMainUrl_VideoTag_url = target_video_url;
                    System.out.println("当前页面源码有 Video Tag 标签 ");

                    System.out.println();
                    System.out.println("url = " + url);
                    System.out.println("NoMainUrl_VideoTag_url = " + NoMainUrl_VideoTag_url);
                    System.out.println("===============mainHtml Begin============ ");

                    System.out.println(mainHtml);

                    System.out.println("===============mainHtml Endxx============ ");

                    System.out.println();

                } else {
                    System.out.println();
                    System.out.println("url = " + url);
                    System.out.println("===============mainHtml Begin============ ");

                    System.out.println(mainHtml);

                    System.out.println("===============mainHtml Endxx============ ");

                    System.out.println();
                }
                if (mainHtml != null) {
                    String MainHtmlStr = mainHtml.toString();

                    // 把 "main_url":" 去除 那么 起点 就是 我们 要找的 url
                    // "backup_url_1":"

                    base64_jiami_url = calculXiGuaMainUri(url, MainHtmlStr, main_url_keyword);
                    base64_jiami_bankurl = calculXiGuaMainUri(url, MainHtmlStr, bankup_url_keyword);
                    if (base64_jiami_url == null) {

                        if (NoMainUrl_VideoTag_url != null) {
                            System.out.println(
                                    "解析出的 base64_jiami_main_url 为空  但存在 video_tag_url = " + NoMainUrl_VideoTag_url);
                            System.out.println(" 尝试下载  video_tag_url : " + NoMainUrl_VideoTag_url);

                            downRawVideo_WithUrl(index, NoMainUrl_VideoTag_url, "", "TouTiao");
                        } else {

                            System.out.println(
                                    "解析出的 base64_jiami_main_url 为空  NoMainUrl_VideoTag_url 为空 无法下载视频到本地   base64_jiami_url="
                                            + base64_jiami_url);

                        }

                    } else {
                        System.out.println("解析出的 base64_jiami_url=[" + base64_jiami_url + "]  尝试解密base64");

                        jiemi_base64_url = jiemi_decryptBASE64(base64_jiami_url);
                        System.out.println();

                        System.out.println("解析出的地址  jiemi_base64_url = [" + jiemi_base64_url + "]");

                        if (jiemi_base64_url.startsWith("http")) {
                            System.out.println("执行 main_url 下载操作!!!    jiemi_base64_url=[" + jiemi_base64_url + "]");
                            downRawVideo_WithUrl(index, jiemi_base64_url, "", "TouTiao");

                        } else {
                            System.out.println("解密出的地址不是以  http 开头  无法下载!!!");
                        }

                    }

                } else {
                    System.out.println(
                            "当前读取到的 网页源码为空 ,   可能 G2_chromedriver版本 和 当前浏览器版本不一致!!   \n chromedriver.exe 下载地址: http://npm.taobao.org/mirrors/chromedriver/");
                }

            } catch (Exception e) {
                // TODO: handle exception
                System.out.println("解密Base64出意外Exception 尝试使用 bankup_url   \njiemi_base64_url=[" + jiemi_base64_url
                        + "]\nbase64_jiami_url=[" + base64_jiami_url + "]    \n base64_jiami_bankurl=["
                        + base64_jiami_bankurl + "]");

                try {
                    if (base64_jiami_bankurl != null) {

                        jiemi_base64_bankurl = jiemi_decryptBASE64(base64_jiami_bankurl);
                    }

                    if (jiemi_base64_bankurl != null && jiemi_base64_bankurl.startsWith("http")) {
                        System.out.println(
                                "执行 bankup_url_1 下载操作!!!    jiemi_base64_bankurl=[" + jiemi_base64_bankurl + "]");
                        downRawVideo_WithUrl(index, jiemi_base64_bankurl, "", "TouTiao");

                    }

                } catch (Exception e1) {

                    System.out.println("尼玛 不干了  备用的 bankup_url 也解析失败!! 下载失败!! jiemi_base64_bankurl =["
                            + jiemi_base64_bankurl + "]");
                    // TODO: handle exception
                }

            }

        }

        // 把 "main_url":" 去除 那么 起点 就是 我们 要找的 url
        // "backup_url_1":"

        public String calculXiGuaMainUri(String url, String mainHtmlStr, String beginKeyStr) {

            String jiami_main_uri = null;

            if (mainHtmlStr == null) {
                System.out.println("当前 url=" + url + "  获取到的网页源代码 htmlcode 为空!! ");
                return jiami_main_uri;
            }

            if (!mainHtmlStr.contains("\"vtype\":\"mp4\"")) {
                System.out.println("当前 url=" + url + "  获取到的网页源代码 htmlcode   不包含关键字 \"vtype\":\"mp4\" 无法解析视频!! ");
                return jiami_main_uri;
            }

            // "definition":"1080p","quality":"normal","vtype":"mp4"
            // "definition":"720p","quality":"normal","vtype":"mp4"
            // "definition":"480p","quality":"normal","vtype":"mp4"
            // "definition":"360p","quality":"normal","vtype":"mp4"

            String mp4_1080p_keystr = "\"definition\":\"1080p\",\"quality\":\"normal\",\"vtype\":\"mp4\"";
            String mp4_720p_keystr = "\"definition\":\"720p\",\"quality\":\"normal\",\"vtype\":\"mp4\"";
            String mp4_480p_keystr = "\"definition\":\"480p\",\"quality\":\"normal\",\"vtype\":\"mp4\"";
            String mp4_360p_keystr = "\"definition\":\"360p\",\"quality\":\"normal\",\"vtype\":\"mp4\"";

            String mKeyMp4Tag = null; // 如果有 1080p 那么选择1080p 如果只有720p 那么就是720p 选分辨率最高那个

            if (mainHtmlStr.contains(mp4_1080p_keystr)) {
                mKeyMp4Tag = mp4_1080p_keystr;
            } else if (mainHtmlStr.contains(mp4_720p_keystr)) {
                mKeyMp4Tag = mp4_720p_keystr;
            } else if (mainHtmlStr.contains(mp4_480p_keystr)) {
                mKeyMp4Tag = mp4_480p_keystr;
            } else if (mainHtmlStr.contains(mp4_360p_keystr)) {
                mKeyMp4Tag = mp4_360p_keystr;
            }

            if (mKeyMp4Tag == null) {

                System.out.println(
                        "当前 url=" + url + "  获取到的网页源代码 htmlcode  查不到 1080p 720p 480p  360p 视频的任意一个  无法解析视频!! ");

                return jiami_main_uri;
            }

            // 把 要 解析的 分辨率 搞到 第一行位置
            // "definition":"1080p","quality":"normal","vtype":"mp4","vwidth":1920,"vheight":1080,"bitrate":2629630,"fps":25,"codec_type":"h264","size":77367333,"main_url":"...,"backup_url_1":...
            String mp4tag_begin_str = mainHtmlStr.substring(mainHtmlStr.indexOf(mKeyMp4Tag));

            if (mp4tag_begin_str == null || !mp4tag_begin_str.contains("\"main_url\":\"")) {
                System.out.println("当前 url=" + url + "  获取到的网页源代码 htmlcode  找到 1080p 720p 480p  360p   mKeyMp4Tag = "
                        + mKeyMp4Tag + "  但解析出 main_url 失败!!");

                return jiami_main_uri;
            }

            if (mp4tag_begin_str == null || !mp4tag_begin_str.contains("\"backup_url_1\":\"")) {
                System.out.println("当前 url=" + url + "  获取到的网页源代码 htmlcode  找到 1080p 720p 480p  360p   mKeyMp4Tag = "
                        + mKeyMp4Tag + "  但解析出  backup_url_1;	 失败!!");

                System.out.println();
                System.out.println();
                System.out.println("mp4tag_begin_str = ");
                System.out.println(mp4tag_begin_str);

                System.out.println();
                System.out.println();

            }

            // "main_url":"...,"backup_url_1":...
            String main_url_begin = mp4tag_begin_str.substring(mp4tag_begin_str.indexOf(beginKeyStr));

            // 把 "main_url":" 去除 那么 起点 就是 我们 要找的 url
            // "backup_url_1":"
            String main_url_raw = main_url_begin.replace(beginKeyStr, "");

            // 第一个引号的位置 就是 结束 标示 main_url_fixed 就是我们 要找的 url_raw
            String main_url_fixed = main_url_raw.substring(0, main_url_raw.indexOf("\""));

            System.out.println("当前寻找到的 base64_url = " + main_url_fixed);

            return main_url_fixed;

        }

        /**
         * 获取首页内容
         *
         * @return 首页内容
         * @throws InterruptedException 睡眠中断异常
         */
        String getXiGua_MainPageSource(String url) {

            ChromeOptions CUR_CHROME_OPTIONS = new ChromeOptions();
            // 驱动位置
            CUR_CHROME_OPTIONS.addArguments("--start-fullscreen");

//			CUR_CHROME_OPTIONS.addArguments("Accept=text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8");
//			CUR_CHROME_OPTIONS.addArguments("Accept-Encoding=gzip, deflate, sdch");
//			CUR_CHROME_OPTIONS.addArguments("Accept-Language=zh-CN,zh;q=0.8");
//			CUR_CHROME_OPTIONS.addArguments("Connection=keep-alive");
//			CUR_CHROME_OPTIONS.addArguments("Host=activityunion-marketing.meituan.com");
//			CUR_CHROME_OPTIONS.addArguments("Upgrade-Insecure-Requests=1");
//			CUR_CHROME_OPTIONS.addArguments("User-Agent=Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.3 (KHTML, like Gecko) Version/8.0 Mobile/12A4345d Safari/600.1.4");

            System.setProperty("webdriver.chrome.driver", ChromeDriverFile.getAbsolutePath());
            // 避免被浏览器检测识别
            CUR_CHROME_OPTIONS.setExperimentalOption("excludeSwitches", Collections.singletonList("enable-automation"));

            ChromeDriver driver = new ChromeDriver(CUR_CHROME_OPTIONS);
            int loop_index = 0;
            try {

                driver.get(url);
                long waitTime = Double.valueOf(Math.max(3, Math.random() * 5) * 1000).longValue();
                TimeUnit.MILLISECONDS.sleep(waitTime);
                long timeout = 20_000;
                // 循环下拉，直到全部加载完成或者超时
                do {
                    new Actions(driver).sendKeys(Keys.END).perform();
                    TimeUnit.MILLISECONDS.sleep(waitTime);
                    if (loop_index == 1) {
                        System.out.println("!! 触发点击事件  起始 标识 AAA !!");
                        new Actions(driver).sendKeys(Keys.HOME).perform();
                        TimeUnit.MILLISECONDS.sleep(1500);
                        try {
                            driver.findElement(By.className("xgplayer-start")).click();
                            TimeUnit.MILLISECONDS.sleep(2000);
                        } catch (Exception e) {
                            System.out.println("尝试点击播放按钮失败!! ");

                            System.out.println("click异常:");
                            System.out.println(e.fillInStackTrace());

                        }

//				        List<WebElement> element =  driver.findElements(xgplayer);
//				        if(element != null && element.size() > 0) {
//				        	WebElement endElement = element.get(element.size() -1 );
//				    		System.out.println("!! 触发点击事件  起始 标识 BBB   element.size()="+element.size());
//				        	endElement.click();
//				        }

                        /*
                         * System.out.println("!! 触发点击事件  起始 标识 BBB !!"); List<WebElement> playelements
                         * = driver.findElementsByClassName("xgplayer-start");
                         * System.out.println(" xgplayer-start  playelements.size() = " + (playelements
                         * == null ? "null":playelements.size()+"")); if(playelements != null &&
                         * playelements.size() > 0) { for (WebElement webElement : playelements) {
                         * if(webElement != null) {
                         * System.out.println("_______________ webelement begin _______________"); //
                         * System.out.println(webElement.toString());
                         * System.out.println("_______________ webelement endxx _______________");
                         *
                         * }
                         *
                         * }
                         *
                         *
                         *
                         * System.out.println("存在播放按钮 xgplayer-start   触发点击 playelements="+(playelements
                         * == null?"null":""+playelements.size())); }else {
                         *
                         * System.out.println("没有播放按钮 xgplayer-start "); }
                         */

//						TimeUnit.MILLISECONDS.sleep(2000);

                    }

                    TimeUnit.MILLISECONDS.sleep(waitTime);
                    timeout -= waitTime;
                    loop_index++;
                } while (!driver.getPageSource().contains("已经到底部，没有新的内容啦") && timeout > 0);
                System.out.println("已经到底部，没有新的内容啦");
                return driver.getPageSource();
            } catch (Exception e) {
                // TODO: handle exception
                System.out.println("获取网页源码的时候出错  url = " + url);
                e.printStackTrace();

            } finally {
                driver.close();

            }
            return null;
        }

        @SuppressWarnings("unchecked")
        public void ksParseUrl(int index, String url, String fileNameNoPoint) {
            HashMap headers = MapUtil.newHashMap();
            headers.put("User-Agent",
                    "Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.103 Mobile Safari/537.36");
            String redirectUrl = HttpUtil.createGet(url).addHeaders(headers).execute().header("Location");
            String body = HttpUtil.createGet(redirectUrl).addHeaders(headers).execute().body();
            org.jsoup.nodes.Document doc = Jsoup.parse(body);
            Elements videoElement = doc.select("video[id=video-player]");
            String videoUrl = videoElement.get(0).attr("src");
            String title = videoElement.get(0).attr("alt");
            System.out.println();
            System.out.println(videoUrl);
            System.out.println(title);
//	        downVideo(videoUrl,title,"kuaishou");
            downRawVideo_WithUrl(index, videoUrl, fileNameNoPoint, "kuaishou");
        }

        @SuppressWarnings("unchecked")
        public void douYinParseUrl(int index, String url, String fileNameNoPoint) {
            try {
                final String videoPath = "https://www.iesdouyin.com/web/api/v2/aweme/iteminfo/?item_ids=";
                Connection con = Jsoup.connect(clearChinese(url));
                con.header("User-Agent",
                        "Mozilla/5.0 (iPhone; CPU iPhone OS 12_1_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/16D57 Version/12.0 Safari/604.1");
                Connection.Response resp = con.method(Connection.Method.GET).execute();
                String videoUrl = videoPath + getDouYinItemId(resp.url().toString());
                String jsonStr = Jsoup.connect(videoUrl).ignoreContentType(true).execute().body();
                JSONObject json = JSONObject.parseObject(jsonStr);
                String videoAddress = json.getJSONArray("item_list").getJSONObject(0).getJSONObject("video")
                        .getJSONObject("play_addr").getJSONArray("url_list").get(0).toString();
                String title = json.getJSONArray("item_list").getJSONObject(0).getJSONObject("share_info")
                        .getString("share_title");
                videoAddress = videoAddress.replaceAll("playwm", "play");
                HashMap headers = MapUtil.newHashMap();
                headers.put("User-Agent",
                        "Mozilla/5.0 (iPhone; CPU iPhone OS 12_1_4 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/16D57 Version/12.0 Safari/604.1");
                String finalVideoAddress = HttpUtil.createGet(videoAddress).addHeaders(headers).execute()
                        .header("Location");
                // 注:打印获取的链接
                System.out.println("-----抖音去水印链接-----\n" + "finalVideoAddress=" + finalVideoAddress
                        + "  \nvideoAddress=" + videoAddress);
                // 下载无水印视频到本地
                if (finalVideoAddress == null) {
                    finalVideoAddress = videoAddress;
                }
                downRawVideo_WithUrl(index, finalVideoAddress, fileNameNoPoint, "douyin");
            } catch (IOException e) {
                System.out.println(e.getMessage());
            }
        }

        // String fileAddress = videoSavePath+"/"+((source==null ||"".equals(source) ?
        // "":source+"_")+title.replace(" ",
        // ""))+"_"+index_download+"_"+timeStamp_Str+".mp4";

        // 视频的保存 目录 不能是 当前文件 否则 就会执行 同步操作 影响网速
        // pageUrl 是页面的url httpUrl 是视频文件的url
        @SuppressWarnings("unchecked")
        public void downRawVideo_WithUrl_WithProxy(int index, String httpUrl, String fileNameNoPoint, String source,
                                                   String pageUrl) {
            if (urlStrList.contains(httpUrl)) {
                System.out.println("当前url 路径已经下载过  跳过下载!!  url路径: " + httpUrl + "");
                return;
            }

            String fileAddress = mDownloadedMonthDir.getAbsolutePath() + File.separator
                    + (source == null || "".equals(source) ? "" : source + "_") + (fileNameNoPoint.replace(" ", ""))
                    + "_" + index + "_" + getTimeStamp() + ".mp4";

            int byteRead;

            try {

                // 获取链接

                System.out.println(
                        "downloadByCommonIO_Retry下载[" + download_failed_time + "] Begin fileAddress= " + fileAddress);
                System.out
                        .println("downloadByCommonIO_Retry下载[" + download_failed_time + "] Begin HttpUrl= " + httpUrl);
                System.out
                        .println("downloadByCommonIO_Retry下载[" + download_failed_time + "] Begin PageUrl= " + pageUrl);

                InetSocketAddress address = new InetSocketAddress("127.0.0.1", 7078);
                Proxy proxy = new Proxy(Proxy.Type.HTTP, address); // http代理协议类型
                URL url = new URL(httpUrl);
                URLConnection conn = url.openConnection(proxy);
                // 输入流

                long beginTimeStamp = System.currentTimeMillis();

                System.out.println("conn.getInputStream 获得 输入流  Begin ( downRawVideo耗时_A 得很) ");
                InputStream inStream = conn.getInputStream();
                long endTimeStamp = System.currentTimeMillis();
                long distance_second = (endTimeStamp - beginTimeStamp) / 1000;

                System.out.println("conn.getInputStream 获得 输入流  End ( downRawVideo耗时_A【" + distance_second + " 秒】 得很)");

                // 封装一个保存文件的路径对象
                File fileSavePath = new File(fileAddress);
                // 注:如果保存文件夹不存在,那么则创建该文件夹
                File fileParent = fileSavePath.getParentFile();
                if (!fileParent.exists()) {
                    fileParent.mkdirs();
                }
                // 写入文件
                FileOutputStream fs = new FileOutputStream(fileSavePath);
                byte[] buffer = new byte[1024];
                beginTimeStamp = System.currentTimeMillis();
                System.out.println("FileOutputStream.write  写入本地文件  Begin   比较 downRawVideo_耗时_B ");

                while ((byteRead = inStream.read(buffer)) != -1) {
                    fs.write(buffer, 0, byteRead);
                }
                endTimeStamp = System.currentTimeMillis();
                distance_second = (endTimeStamp - beginTimeStamp) / 1000;

                System.out.println(
                        "FileOutputStream.write  写入本地文件  End ( downRawVideo_耗时_B【" + distance_second + " 秒】 得很)");

                inStream.close();
                fs.close();
                System.out.println("\n-----视频保存路径-----\n" + fileSavePath.getAbsolutePath());
                System.out.println("\nzzfile_3.bat " + fileSavePath.getParentFile().getAbsolutePath());

                if (isMDName) {
                    System.out.println("由于 isMDName=true  视频文件将以 MD5 属性文件名称进行命名!!! ");

                    // 获取文件的 md值 并重命名为 mdxxxx.mp4
                    String mdName = getMD5Three(fileSavePath.getAbsolutePath());
                    String new_Md_Name = mdName + ".mp4";
                    tryReName(fileSavePath, new_Md_Name);
                    // 把下载的 mp4 文件 名称 转为 md值
                }

                urlStrList.add(httpUrl);
                download_failed_time = 0;
                System.out
                        .println("downloadByCommonIO_下载[" + download_failed_time + "] End  fileAddress=" + fileAddress);
            } catch (Exception e) {

                download_failed_time++;
                if (download_failed_time % 10 == 0) {
                    System.out.println("程序下载 retry " + download_failed_time + " 次 仍然 下载 失败----放弃");
                } else {
                    downRawVideo_WithUrl_WithProxy(index, httpUrl, fileNameNoPoint, source, pageUrl);
                }
                // e.printStackTrace();

                // System.out.println(e.getMessage());
            }
        }

        // 视频的保存 目录 不能是 当前文件 否则 就会执行 同步操作 影响网速
        @SuppressWarnings("unchecked")
        public void downRawVideo_WithUrl(int index, String httpUrl, String fileNameNoPoint, String source) {
//	        String fileAddress = videoSavePath+"/"+source+"/"+title+".mp4";
            if (mDownloadedMonthDir == null) {
                mDownloadedMonthDir = new File(curDirPath);
            }
            String fileAddress = mDownloadedMonthDir.getAbsolutePath() + File.separator
                    + (source == null || "".equals(source) ? "" : source + "_") + (fileNameNoPoint.replace(" ", ""))
                    + "_" + index + "_" + getTimeStamp() + ".mp4";

            int byteRead;
            try {
                URL url = new URL(httpUrl);
                // 获取链接
                URLConnection conn = url.openConnection();
                // 输入流
                InputStream inStream = conn.getInputStream();
                // 封装一个保存文件的路径对象
                File fileSavePath = new File(fileAddress);
                // 注:如果保存文件夹不存在,那么则创建该文件夹
                File fileParent = fileSavePath.getParentFile();
                if (!fileParent.exists()) {
                    fileParent.mkdirs();
                }
                // 写入文件
                FileOutputStream fs = new FileOutputStream(fileSavePath);
                byte[] buffer = new byte[1024];
                while ((byteRead = inStream.read(buffer)) != -1) {
                    fs.write(buffer, 0, byteRead);
                }
                inStream.close();
                fs.close();
                System.out.println("\n-----视频保存路径-----\n" + fileSavePath.getAbsolutePath());
                System.out.println("\nzzfile_3.bat " + fileSavePath.getParentFile().getAbsolutePath());

                if (isMDName) {
                    System.out.println("由于 isMDName=true  视频文件将以 MD5 属性文件名称进行命名!!! ");

                    // 获取文件的 md值 并重命名为 mdxxxx.mp4
                    String mdName = getMD5Three(fileSavePath.getAbsolutePath());
                    String new_Md_Name = mdName + ".mp4";
                    tryReName(fileSavePath, new_Md_Name);
                    // 把下载的 mp4 文件 名称 转为 md值
                }

                urlStrList.add(httpUrl);
            } catch (FileNotFoundException e) {
                System.out.println(e.getMessage());
            } catch (IOException e) {
                System.out.println(e.getMessage());
            }
        }

        public String getDouYinItemId(String url) {
            int start = url.indexOf("/video/") + 7;
            int end = url.lastIndexOf("/");
            String itemId = url.substring(start, end);
            return itemId;
        }

        public boolean toJudgeUrl(String str) {
            boolean isUrl = false;

            if (str.trim().toLowerCase().startsWith("http:") || str.toLowerCase().trim().startsWith("https:")
                    || str.toLowerCase().trim().startsWith("thunder:")
                    || str.toLowerCase().trim().startsWith("magnet:")) {

                return true;
            }

            return isUrl;
        }

        @SuppressWarnings("unchecked")
        File calLastTxtFileInFileList(ArrayList<File> rootFileList) {

            if (rootFileList == null || rootFileList.size() == 0) {
                System.out.println(" AA   calLastTxtFileInFileList == null ");
                return null;
            }
            // 全目录 搜索 TXT 文件 Begin
            ArrayList<File> allTxtFileList = new ArrayList<File>();
//			ArrayList<File> txtFileList = new ArrayList<File>();
            for (int i = 0; i < rootFileList.size(); i++) {
                File rootDir = rootFileList.get(i);
                ArrayList<File> txtFileList = getAllSubFile(rootDir, ".txt");
                if (txtFileList == null || txtFileList.size() == 0) {
                    continue;
                }

                allTxtFileList.addAll(txtFileList);

            }

            if (allTxtFileList.size() == 0) {
                System.out.println(" BB   calLastTxtFileInFileList.size() == 0 ");
                return null;
            }

            System.out.println(" CC   calLastTxtFileInFileList.size() ==  " + allTxtFileList.size());

            allTxtFileList.sort(mFileDateComparion_Old_To_New);
            File lastTxtFile = allTxtFileList.get(allTxtFileList.size() - 1);
            return lastTxtFile;

        }

        @SuppressWarnings("unchecked")
        File calLastTxtFileInList(File rootDir) {

            // 全目录 搜索 TXT 文件 Begin
//			ArrayList<File> txtFileList = new ArrayList<File>();

            ArrayList<File> txtFileList = getAllSubFile(rootDir, ".txt");

            /*
             * File newRootFile = new File(rootDir.getAbsolutePath()); if (newRootFile ==
             * null) { System.out.println(" 当前 检测不到根目录 newRootFile = null !!"); return null;
             * } File[] fileArr = newRootFile.listFiles(); if (fileArr == null ||
             * fileArr.length == 0) { System.out.println("当前目录文件为空,将休眠1分钟后继续监测!!");
             * System.out.println("mWeChatRootFile.listFiles().size() ==  0 "); } else {
             * System.out.println("mWeChatRootFile.listFiles().size() == " +
             * fileArr.length); for (int i = 0; i < fileArr.length; i++) { File curFile =
             * fileArr[i]; String fileNmae = curFile.getName().toLowerCase(); if
             * (fileNmae.endsWith(".txt")) { txtFileList.add(curFile); } }
             *
             * }
             */
            // 全目录 搜索 TXT 文件 End

            if (txtFileList.size() == 0) {
                return null;
            }
            txtFileList.sort(mFileDateComparion_Old_To_New);
            File lastTxtFile = txtFileList.get(txtFileList.size() - 1);
//			mWeChatRootFile = newRootFile;

            return lastTxtFile;

        }

        // 对每行的数据进行分析

        public void toGetUrlFromOneLine_And_InitUrlList(String rowString, ArrayList<String> urlList) {
            String[] strArrRow = null;
            String fixStr = "";

//	        if(str.trim().startsWith("http:") || str.trim().startsWith("https:") ||
//	                str.trim().startsWith("thunder:") ||   str.trim().startsWith("magnet::") ){

            if (rowString != null) {
                fixStr = new String(rowString);
                // http://xxxxxx/sahttp:// 避免出现 http://http: 连着的情况 起码也要使得间隔一个空格
                fixStr = fixStr.replace("http:", " http:");
                fixStr = fixStr.replace("https:", " https:");
                fixStr = fixStr.replace("thunder:", " thunder:");
                fixStr = fixStr.replace("magnet:", " magnet:");
                strArrRow = fixStr.split(" ");
            }

            if (strArrRow != null && strArrRow.length > 0) {

                for (int i = 0; i < strArrRow.length; i++) {
                    String mCurContent = strArrRow[i];
                    if (mCurContent == null || mCurContent.trim().equals("")) {
                        continue;
                    }

                    boolean isUrl = toJudgeUrl(mCurContent);
                    if (isUrl) {
                        urlList.add(clearChinese(mCurContent).trim());

                    }

                }

            }

        }

        // 对每行的数据检查是否有 zcmd_run_ 之类的 运行命令

        public void zcmd_run_toGetZCmdRunFromOneLine_And_InitZCmdList(String rowString,
                                                                      ArrayList<String> zcmdrunStrList, ArrayList<String> zrunStrList_cmderList) {
            String[] strArrRow = null;
            String fixStr = "";

//	        if(str.trim().startsWith("http:") || str.trim().startsWith("https:") ||
//	                str.trim().startsWith("thunder:") ||   str.trim().startsWith("magnet::") ){

            if (!rowString.contains("zcmd_run_") && !rowString.contains("zcmder_run_")) {
                System.out.println("当前行 rowString=" + rowString + " 不包含标识符 【zcmd_run_】   【zcmder_run_】命令执行失败!");
                return;
            }

            if (rowString.contains("zcmd_run_")) {

                if (rowString != null) {
                    fixStr = new String(rowString);
                    // http://xxxxxx/sahttp:// 避免出现 http://http: 连着的情况 起码也要使得间隔一个空格
                    fixStr = fixStr.replace("zcmd_run_", " zcmd_run_");

                    strArrRow = fixStr.split("zcmd_run_");
                }

                if (strArrRow != null && strArrRow.length > 0) {

                    for (int i = 0; i < strArrRow.length; i++) {
                        String mCommandItem = strArrRow[i];
                        System.out.println("strArrRow[" + i + "] = " + mCommandItem);
                        if (mCommandItem == null || mCommandItem.trim().equals("")) {
                            continue;
                        }

                        mCommandItem = mCommandItem.replace("zcmd_run_", "");
                        System.out.println("zcmd_run_xxx rowString[" + rowString + "]" + "  mCommandItem = ["
                                + mCommandItem + "] ");

                        if (mCommandItem.contains("【") && mCommandItem.contains("】")
                                && mCommandItem.indexOf("【") < mCommandItem.indexOf("】")) {

                            String tipNum = mCommandItem.substring(mCommandItem.indexOf("【"),
                                    mCommandItem.lastIndexOf("】") + 1);

                            System.out.println("tipNum = " + tipNum);
                            mCommandItem = mCommandItem.replace(tipNum, "");

                        }

                        zcmdrunStrList.add(mCommandItem.trim());

                    }

                }

            } else if (rowString.contains("zcmder_run_")) {

                if (rowString != null) {
                    fixStr = new String(rowString);
                    // http://xxxxxx/sahttp:// 避免出现 http://http: 连着的情况 起码也要使得间隔一个空格
                    fixStr = fixStr.replace("zcmder_run_", " zcmder_run_");

                    strArrRow = fixStr.split("zcmder_run_");
                }

                if (strArrRow != null && strArrRow.length > 0) {

                    for (int i = 0; i < strArrRow.length; i++) {
                        String mCommandItem = strArrRow[i];
                        System.out.println("strArrRow[" + i + "] = " + mCommandItem);
                        if (mCommandItem == null || mCommandItem.trim().equals("")) {
                            continue;
                        }

                        mCommandItem = mCommandItem.replace("zcmder_run_", "");
                        System.out.println("zcmd_run_xxx rowString[" + rowString + "]" + "  mCommandItem = ["
                                + mCommandItem + "] ");

                        if (mCommandItem.contains("【") && mCommandItem.contains("】")
                                && mCommandItem.indexOf("【") < mCommandItem.indexOf("】")) {

                            String tipNum = mCommandItem.substring(mCommandItem.indexOf("【"),
                                    mCommandItem.lastIndexOf("】") + 1);

                            System.out.println("tipNum = " + tipNum);
                            mCommandItem = mCommandItem.replace(tipNum, "");

                        }

                        zrunStrList_cmderList.add(mCommandItem.trim());

                    }

                }

            }

        }

        /*
         * @Override String simpleDesc() {
         *
         * return Cur_Bat_Name + " #_" + rule_index +
         * "  ### 持续检测 WeChat目录 C:\\Users\\zukgit\\Documents\\WeChat Files\\xxxx\\FileStorage\\File\\2021-07 的 TXT文件的内容    \n"
         * + Cur_Bat_Name + " #_" + rule_index +
         * "   ### 只有在 WeChat的当前 月份接收文件目录 才能生效 Monitor 监控 \n" + "  explorer.exe  \"" +
         * System.getProperties().getProperty("user.home") +
         * "\\Documents\\WeChat Files\\zzj382581427\\FileStorage\\File\"   \n" +
         * "  explorer.exe  \"" + mDownloadedMonthDir.getAbsolutePath() + "\"   \n" +
         * "cd  " + "\""+ System.getProperties().getProperty("user.home") +
         * "\\Documents\\WeChat Files\\zzj382581427\\FileStorage\\File" +
         * File.separator+ getTimeStamp_YYYY_MM() + "\"" +"  && "+ "  explorer.exe " +
         * " \""+ mDownloadedMonthDir.getAbsolutePath()+"\"" +
         * " \n &&   zrule_apply_G2.bat " + "_" + rule_index + "_" + "\n"
         *
         * ; }
         */

        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_" + rule_index
                    + "  ### 持续检测 WeChat目录 C:\\Users\\zukgit\\Documents\\WeChat Files\\xxxx\\FileStorage\\File\\2021-07 的 TXT文件的内容    \n"
                    + Cur_Bat_Name + " #_" + rule_index + "  mdname_true   logfile_true "
                    + "  ### 以MD5字符串保存下载视频文件 持续检测 WeChat目录 C:\\Users\\zukgit\\Documents\\WeChat Files\\xxxx\\FileStorage\\File\\2021-07 的 TXT文件的内容    \n"

                    + Cur_Bat_Name + " #_" + rule_index + "   ### 只有在 WeChat的当前 月份接收文件目录 才能生效 Monitor 监控 \n"
                    + Cur_Bat_Name + " #_" + rule_index
                    + "  bootup_true   ### 只有在 WeChat的当前 月份接收文件目录 才能生效 Monitor 监控  bootup_true 标识是开机启动的进程 \n"
                    // copy
                    // System.getProperties().getProperty("user.home")\Desktop\zbin\win_zbin\zrule_apply_G2_39rule_startup.vbs
                    // C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\
                    // copy %userprofile%\Desktop\zbin\win_zbin\zrule_apply_G2_39rule_startup.vbs
                    // C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\
                    // zbatrule_I9_Rule30.bat _31_ file_C:\Users\zhuzj5\Desktop\ScreenShot\D\T.txt
                    + " 【配置检测开机启动_MailCmd服务器】 \"\n" + "zbatrule_I9_Rule30.bat _31_  file_" + Win_Lin_Mac_ZbinPath + File.separator
                    + "zrule_apply_G2_39rule_startup.vbs" + "  " + "\n" + "  explorer.exe  \""
                    + "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\StartUp\\\"  \n"

                    + "  explorer.exe  \"" + System.getProperties().getProperty("user.home")
                    + "\\Documents\\WeChat Files\"  \n" + "  explorer.exe  \""
                    + System.getProperties().getProperty("user.home") + "\\Documents\\Tencent Files\"  \n"

                    + "  explorer.exe  \"" + mDownloadedMonthDir.getAbsolutePath() + "\"   \n" + "cd  " + "\""
                    + System.getProperties().getProperty("user.home") + "\\Documents\\" + "\"" + "  && "

                    + "  explorer.exe " + " \"" + mDownloadedMonthDir.getAbsolutePath() + "\""
                    + " \n &&   zrule_apply_G2.bat " + "_" + rule_index + "_" + "  mdname_true" + "\n"

                    ;
        }

    }

    static double ONE_MINUTES_SECOND = 60; // 1分钟 单位:秒
    static double ONE_SECOND_MILLSECOND = 1000; // 1 秒钟 单位:毫秒
    static double ONE_MINUTES_MILLSECOND = ONE_MINUTES_SECOND * ONE_SECOND_MILLSECOND; // 1分钟 单位:毫秒

    static Comparator mFileDateComparion_Old_To_New = new Comparator<File>() {
        @Override
        public int compare(File o1, File o2) {
            long diff = o1.lastModified() - o2.lastModified();
            if (diff > 0)
                return 1;
            else if (diff == 0)
                return 0;
            else
                return -1;// 如果 if 中修改为 返回-1 同时此处修改为返回 1 排序就会是递减
        }

    };

    static int getStrRepeatCount(String mainStr, String subStr) {
//声明一个要返回的变量
        int count = 0;
//声明一个初始的下标，从初始位置开始查找
        int index = 0;
//获取主数据的长度
        int mainStrLength = mainStr.length();
//获取要查找的数据长度
        int subStrLength = subStr.length();
//如果要查找的数据长度大于主数据的长度则返回0
        if (subStrLength > mainStrLength) {
            return 0;
        }
//循环使用indexOf查找出现的下标，如果出现一次则count++
        while ((index = mainStr.indexOf(subStr, index)) != -1) {
            count++;
//从找到的位置下标加上要查找的字符串长度，让指针往后移动继续查找
            index += subStrLength;
        }
        return count;
    }

    static Comparator mFileDateComparion_New_To_Old = new Comparator<File>() {
        @Override
        public int compare(File o1, File o2) {
            long diff = o1.lastModified() - o2.lastModified();
            if (diff > 0)
                return -1;
            else if (diff == 0)
                return 0;
            else
                return 1;// 如果 if 中修改为 返回-1 同时此处修改为返回 1 排序就会是递减
        }

    };


    static Comparator mFileDateComparion_Deep_Seperator = new Comparator<File>() {
        @Override
        public int compare(File o1, File o2) {
            String o1_name = o1.getAbsolutePath();
            String o2_name = o2.getAbsolutePath();

            int o1_separator_count = getStrRepeatCount(o1_name,File.separator);

            int o2_separator_count = getStrRepeatCount(o2_name,File.separator);


            //	repeat
//			o1.separator

            if(o1_separator_count > o2_separator_count) {

                return -1;
            }

            if(o1_separator_count < o2_separator_count) {

                return 1;
            }

            return 0;

        }

    };



    static Comparator mStringComparion = new Comparator<String>() {
        @Override
        public int compare(String o1, String o2) {
            int o1_length = o1.length();
            int o2_length = o2.length();
            if (o1_length < o2_length) {
                return -1;
            } else if (o1_length == o2_length) {
                return o1.compareTo(o2);
            } else if (o1_length > o2_length) {
                return 1;
            }

            return o1.compareTo(o2);
        }

    };

    class Revert_xlsx2json_Rule_38 extends Basic_Rule {
        boolean isDirOperation; // 是否没有输入 xlsx 文件 而是 输入了一个 目录 默认shell 目录 已经 输入的目录

        File inputDirFile;
        ArrayList<File> xlsxFileList;

        Revert_xlsx2json_Rule_38() {
            super("#", 38, 3); //
            xlsxFileList = new ArrayList<File>();
            inputDirFile = null;
            isDirOperation = false;
        }

        @Override
        boolean allowEmptyDirFileList() {
            // TODO Auto-generated method stub
            return true;
        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {
            // TODO Auto-generated method stub

            for (int i = 0; i < xlsxFileList.size(); i++) {
                File xlsxFile = xlsxFileList.get(i);
                String xlsxFileName = xlsxFile.getName();
                String getxlsxNameNoType = getFileNameNoPoint(xlsxFileName);
                String resut_json_xlsx_name = xlsxFileName.replace(".", "_") + "_" + getTimeStamp();
//				String resut_json_xlsx_name = getxlsxNameNoType+".json";
                File xlsxFile_resultDir = null;

                if (isDirOperation && inputDirFile != null) {
                    xlsxFile_resultDir = inputDirFile;
                    String resultJsonName = getxlsxNameNoType + ".json";
                    File resultJsonFile = new File(inputDirFile.getAbsolutePath() + File.separator + resultJsonName);
                    if (resultJsonFile.exists()) {
                        // 如果当前 目录 已经 有 xxxx.xlsx 对应的 xxxxx.json 文件 那么 就不解析 这个 xlsx文件
                        continue;
                    }
                    reverXlsxToJson(xlsxFile, xlsxFile_resultDir, true);
                } else {
                    // 如果 不是 输入 目录 的 话 那么就创建 xlsx 的 文件名称 如果是目录的话 那么就在当前目录生成 .json
                    xlsxFile_resultDir = new File(
                            xlsxFile.getParentFile().getAbsolutePath() + File.separator + resut_json_xlsx_name);
                    reverXlsxToJson(xlsxFile, xlsxFile_resultDir, false);
                }

            }

            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_" + rule_index
                    + "  <指定A.xlsx文件> <指定B.xls文件>  ### 按顺序解析当前的xlsx xls 为对应的json文件 生成在相同文件名_时间戳的文件夹中   \n"
                    + Cur_Bat_Name + " #_" + rule_index
                    + "  A.xlsx B.xls C.xlsx   ### 按顺序解析当前的xlsx day20200202.xls 为对应的day_20200202.json文件 生成在相同文件名_时间戳的文件夹中    \n"
                    + Cur_Bat_Name + " #_" + rule_index
                    + "   ### 解析当前 shell-path 目录下的xlsx 文件 生成对应的.json 文件  没有直接返回    \n" + Cur_Bat_Name + " #_"
                    + rule_index
                    + "  C:\\Users\\xxx\\Desktop\\zbin\\J0_Data  ### 解析指定目录下的xlsx 文件 生成对应的.json 文件 没有直接返回    \n"

                    ;
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {
                String strInput = inputParamList.get(i);

                File tempFile = new File(curDirPath + File.separator + strInput);
                if (tempFile.exists() && !tempFile.isDirectory()) {
                    String inputFileName = tempFile.getName().toLowerCase();
                    if (inputFileName.endsWith(".xlsx") || inputFileName.endsWith(".xls")) {
                        xlsxFileList.add(tempFile);
                    }

                }

                File inputDir = new File(strInput);
                if (inputDir.exists() && inputDir.isDirectory()) {
                    isDirOperation = true;
                    inputDirFile = inputDir;
                }

                System.out.println("initParamsWithInputList[" + i + "] = " + strInput + "  inputDir.exists()="
                        + inputDir.exists() + "  inputDir.isDirectory()=" + inputDir.isDirectory());

            }

            if (xlsxFileList.size() == 0 && inputDirFile == null) {
                System.out.println("当前 输入的 xlsx 文件 为 空 无法获取 输入的 xlsx 请检查 输入!! ");
                File shellDir = new File(curDirPath);
                if (shellDir != null && shellDir.exists()) {
                    File[] listArr = shellDir.listFiles();

                    if (listArr == null || listArr.length == 0) {
                        System.out.println("当前 输入的目录  " + inputDirFile.getAbsolutePath() + "没有 任何文件操作!!");

                        return false;
                    }
                    for (int i = 0; i < listArr.length; i++) {
                        File fileItem = listArr[i];

                        String inputFileName = fileItem.getName().toLowerCase();
                        if (inputFileName.endsWith(".xlsx") || inputFileName.endsWith(".xls")) {
                            xlsxFileList.add(fileItem);
                            isDirOperation = true;
                            inputDirFile = shellDir;
                        }

                    }

                } else {
                    System.out.println("当前 输入的 xlsx 文件为空  shell目录为空 无法获取 输入的 xlsx 请检查 输入!! ");
                    return false;

                }

            }

            if (inputDirFile != null) {
                File[] listArr = inputDirFile.listFiles();
                if (listArr == null || listArr.length == 0) {
                    System.out.println("当前 输入的目录  " + inputDirFile.getAbsolutePath() + "没有 任何文件操作!!");

                    return false;
                }
                for (int i = 0; i < listArr.length; i++) {
                    File fileItem = listArr[i];

                    String inputFileName = fileItem.getName().toLowerCase();
                    if (inputFileName.endsWith(".xlsx") || inputFileName.endsWith(".xls")) {
                        xlsxFileList.add(fileItem);
                    }

                    System.out.println(
                            "inputDir_xlsx[" + i + "] = " + fileItem.getAbsolutePath() + "  Size=" + fileItem.length());

                }

            }

            if (xlsxFileList.size() == 0) {
                System.out.println(
                        "当前 输入的目录  inputDirFile =" + (inputDirFile == null ? "null" : inputDirFile.getAbsolutePath())
                                + "没有 任何文件的 .xls .xlsx文件进行操作!!");

                return false;

            }
            if (inputDirFile == null) {
                System.out.println("ZXX inputDirFile = null " + " xlsxFileList.size()=" + xlsxFileList.size()
                        + "   isDirOperation=" + isDirOperation);

            } else {
                System.out.println("ZXX inputDirFile =" + inputDirFile.getAbsolutePath() + "    xlsxFileList.size()="
                        + xlsxFileList.size() + "   isDirOperation=" + isDirOperation);

            }

            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }

        public void reverXlsxToJson(File xlsxFile, File jsonResultDirFile, boolean isDirOperation) {
            try {
                FileInputStream inp = new FileInputStream(xlsxFile.getAbsolutePath());

                ZipSecureFile.setMinInflateRatio(-1.0d);
                Workbook workbook = null;
//		            Workbook workbook = WorkbookFactory.create(inp);

                if (xlsxFile.getName().toLowerCase().trim().endsWith(".xls")) {
                    workbook = new HSSFWorkbook(inp);
                } else {
//			             workbook = WorkbookFactory.create(inp);
                    workbook = new XSSFWorkbook(inp);
                }

                // 获取sheet数
                int sheetNum = workbook.getNumberOfSheets();
                System.out.println("Shell_count = " + sheetNum);
                JSONObject jsonObject = new JSONObject();
                for (int s = 0; s < sheetNum; s++) {
                    // Get the Sheet of s.
                    Sheet sheet = workbook.getSheetAt(s);
                    // 获取最大行数
                    String shellName = sheet.getSheetName();

                    int rownum = sheet.getPhysicalNumberOfRows();
                    if (rownum <= 1) {
                        continue;
                    }

                    // 获取第一行
                    Row row1 = sheet.getRow(0);
                    // 获取最大列数
                    int colnum = row1.getPhysicalNumberOfCells();
//					System.out.println("shellIndex["+s+"]  shellName["+ shellName+"]  rownum["+ rownum+"]   colnum["+colnum+ "]");

                    JSONArray jsonArray = new JSONArray();
                    for (int i = 1; i < rownum; i++) {
                        Row row = sheet.getRow(i);
//						System.out.println("currentRow = "+ i );
//		                    if(i > 10) {
//
//		                    	continue;
//		                    }
                        if (row != null) {
//		                    List<Object> list = new ArrayList<>();
                            JSONObject rowObj = new JSONObject();
                            // 循环列
                            for (int j = 0; j < colnum; j++) {
                                Cell cellData = row.getCell(j);
                                if (cellData != null) {
                                    // 判断cell类型
//									System.out.println("colum="+j);

                                    switch (cellData.getCellType()) {
                                        case NUMERIC: {
                                            rowObj.put(row1.getCell(j).getStringCellValue(),
                                                    cellData.getNumericCellValue());
                                            break;
                                        }
                                        case FORMULA: {
                                            // 判断cell是否为日期格式
                                            if (DateUtil.isCellDateFormatted(cellData)) {
                                                // 转换为日期格式YYYY-mm-dd
                                                rowObj.put(row1.getCell(j).getStringCellValue(),
                                                        cellData.getDateCellValue());
                                            } else {
                                                // 数字
                                                rowObj.put(row1.getCell(j).getStringCellValue(),
                                                        cellData.getNumericCellValue());
                                            }
                                            break;
                                        }

                                        case STRING: {

//											System.out.println("row1.getCell(j).toString() = "+ row1.getCell(j).toString());
//											System.out.println("row1.getCell(j).getCellStyle() = "+ row1.getCell(j).getCellStyle());
//											System.out.println("row1.getCell(j).getCellType() = "+ row1.getCell(j).getCellType());

                                            String cellContent = null;

                                            try {
                                                cellContent = cellData.toString();

                                            } catch (Error e) {
                                                cellContent = "";

                                            }

                                            rowObj.put(row1.getCell(j).toString(), cellContent);

                                            // 表头 是 富文本 的 时候 调用 getRichStringCellValue() 和 getStringCellValue() 报错!!!
                                            // Exception in thread "main" java.lang.NoSuchMethodError:
                                            // org.openxmlformats.schemas.spreadsheetml.x2006.main.CTRst.xgetT()
                                            // Lorg/openxmlformats/schemas/officeDocument/x2006/sharedTypes/STXstring;

                                            // rowObj.put(row1.getCell(j).getRichStringCellValue().toString(),
                                            // cellData.getRichStringCellValue());
                                            // rowObj.put(row1.getCell(j).getStringCellValue().toString(),
                                            // cellData.getStringCellValue());

                                            break;
                                        }
                                        default:
                                            rowObj.put(row1.getCell(j).getStringCellValue(), "");
                                    }
                                } else {

                                    try {
                                        rowObj.put(row1.getCell(j).getStringCellValue(), "");

                                    } catch (Error e) {
                                        System.out.println("发生异常 e=" + e);
                                        continue;

                                    }

                                }
                            }
                            jsonArray.add(rowObj);
                        }
                    }
                    String jsonName = sheet.getSheetName() + ".json";

                    if (!isDirOperation) { // 如果是 单一的 输入 xlsx 文件 那么才 输出 sheetname.json
                        File jsonFile = new File(jsonResultDirFile.getAbsolutePath() + File.separator + jsonName);

                        System.out.println(jsonArray.toJSONString());

                        writeContentToFile(jsonFile, jsonArray.toJSONString() + "\n");
                    }

                    jsonObject.put(sheet.getSheetName(), jsonArray);
                }
//		            System.out.println(jsonObject.toJSONString());
//				System.out.println("长度"+jsonObject.toJSONString().length());
//				String allSheetJsonFileName = "AllSheet_"+xlsxFile.getName().replace(".", "_")+".json";

                String getxlsxNameNoType = getFileNameNoPoint(xlsxFile);
                String resut_json_file_name = getxlsxNameNoType + ".json";
                ArrayList<String> jsonRowList = new ArrayList<String>();

                String JsonOneLine = jsonObject.toJSONString(); // 把它分隔多份 不要总是一行

                // 有都逗号 就换行
                JsonOneLine = JsonOneLine.replace(",", ",\n");

                File allSheetJsonFile = new File(
                        jsonResultDirFile.getAbsolutePath() + File.separator + resut_json_file_name);

                writeContentToFile(allSheetJsonFile, JsonOneLine);

                System.out.println(" xlsxFile-->" + xlsxFile.getAbsolutePath() + " 解析成功!");

            } catch (Exception e) {
                e.printStackTrace();
            }
        }

    }

    // 把 pdf中指定的页数 分隔出来作为一个新的pdf文件 #_36 A.pdf 31_341
    // 在本地目录创建 /sdcard/zapp 和 /sdcard/zmain 相关的 dir目录
    class Zapp_Zmain_dir_Create_Rule_37 extends Basic_Rule {

        boolean isZappFlag;

        boolean isZmainFlag;

        boolean isZmainInputParamFlag;
        boolean isZappInputParamFlag;

        Zapp_Zmain_dir_Create_Rule_37() {
            super("#", 37, 3); //
            isZappFlag = false;

            isZmainFlag = false;
            isZmainInputParamFlag = false;
            isZappInputParamFlag = false;
        }

        @Override
        boolean allowEmptyDirFileList() {
            // TODO Auto-generated method stub
            return true;
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {

                String strParam = inputParamList.get(i);
                System.out.println("strParam[" + i + "] = " + strParam);
                if ("zmain".equals(strParam)) {
                    System.out.println("X2 strParam[" + i + "] = " + strParam);
                    isZmainFlag = true;
                    isZmainInputParamFlag = true;

                }

                if ("zapp".equals(strParam)) {
                    System.out.println("X3 strParam[" + i + "] = " + strParam);

                    isZappFlag = true;
                    isZappInputParamFlag = true;
                }

            }

            if (isZmainInputParamFlag == false && isZappInputParamFlag == false) { // 说明用户没有输入任何指定的参数 那么设置 两个值都为 true
                System.out.println("X4 strParam");

                isZmainFlag = true;
                isZappFlag = true;
            }
            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {
            // TODO Auto-generated method stub

            String absShellPath = curDirFile.getAbsolutePath();
            System.out.println(" 当前Shell的路径为: curDirFile =  " + absShellPath);

            ArrayList<String> Zmain_createDirNameList = new ArrayList<String>();

            ArrayList<String> Zapp_createDirNameList = new ArrayList<String>();

            if (isZmainFlag) {
                Zmain_createDirNameList.add("gif");
                Zmain_createDirNameList.add("gif_land");
                Zmain_createDirNameList.add("gif_port");
                Zmain_createDirNameList.add("jpg");
                Zmain_createDirNameList.add("jpg_land_home");
                Zmain_createDirNameList.add("jpg_port_home");
                Zmain_createDirNameList.add("jpg_port_wall");
                Zmain_createDirNameList.add("jpg_land_wall");
                Zmain_createDirNameList.add("mp3");
                Zmain_createDirNameList.add("mp4");
                Zmain_createDirNameList.add("mp4_home");
                Zmain_createDirNameList.add("mp4_music");
                Zmain_createDirNameList.add("mp4_scene");

            }

            if (isZappFlag) {

                Zapp_createDirNameList.add("gif");
                Zapp_createDirNameList.add("gif_land");
                Zapp_createDirNameList.add("gif_port");
                Zapp_createDirNameList.add("jpg");
                Zapp_createDirNameList.add("jpg_top_land");
                Zapp_createDirNameList.add("jpg_top_port");
                Zapp_createDirNameList.add("mp4");
                Zapp_createDirNameList.add("mp4_raw");
                Zapp_createDirNameList.add("mp4_hua");

            }

            if (Zmain_createDirNameList.size() > 0 && isZmainFlag) {
                System.out.println("══════════════════ zmain_begin ════════════════");

                for (int i = 0; i < Zmain_createDirNameList.size(); i++) {
                    String dirName = Zmain_createDirNameList.get(i);
                    String zmain_dirName = "zmain" + File.separator + dirName;
                    String abs_path_dir = absShellPath + File.separator + zmain_dirName;
                    File dirFile = new File(abs_path_dir);
                    dirFile.mkdirs();
                    System.out.println("创建_zmain_目录[" + i + "]  = " + abs_path_dir);

                }
                System.out.println("══════════════════ zmain_end ════════════════");
            }

            if (Zapp_createDirNameList.size() > 0 && isZappFlag) {
                System.out.println("══════════════════ zapp_begin ════════════════");

                for (int i = 0; i < Zapp_createDirNameList.size(); i++) {
                    String dirName = Zapp_createDirNameList.get(i);
                    String zmain_dirName = "zapp" + File.separator + dirName;
                    String abs_path_dir = absShellPath + File.separator + zmain_dirName;
                    File dirFile = new File(abs_path_dir);
                    dirFile.mkdirs();
                    System.out.println("创建_zapp_目录[" + i + "]  = " + abs_path_dir);
                }
                System.out.println("══════════════════ zapp_end ════════════════");

            }

            System.out.println("当前 创建 zapp zmain 结构目录的方法 Rule_" + rule_index + " 执行完毕!!  ");

            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        @Override
        String simpleDesc() {
            // TODO Auto-generated method stub

            return Cur_Bat_Name + " #_" + rule_index + "   ###  创建zapp 和 zmain的文件夹结构 /sdcard/zmain /sdcard/zapp   \n"
                    + Cur_Bat_Name + " #_" + rule_index
                    + "  zmain  zapp    ### 创建zapp 和 zmain的文件夹结构 /sdcard/zmain /sdcard/zapp \n" + Cur_Bat_Name + " #_"
                    + rule_index + " zmain      ### 只在当前目录创建 zmain 的 /sdcard/zmain 目录结构 \n" + Cur_Bat_Name + " #_"
                    + rule_index + " zapp      ### 只在当前目录创建 zapp 的 /sdcard/zapp 目录结构 \n"

                    ;

        }

    }

    class Seperate_Pdf_Rule_36 extends Basic_Rule {

        // 参数的Key是 从参数输入的 文件的名称 参数的Value是对这个文件进行操作的 页面数值

        File targetPDF_File = null; // 目标 pdf target
        // 1. 有前 2.有后 3.有前后
        ArrayList<String> page_page_StrArr; // 输入的分隔的字符串 _10 18_ 10_11 12_20

        Seperate_Pdf_Rule_36() {
            super("#", 36, 3); //

            page_page_StrArr = new ArrayList<String>();
        }

        @Override
        boolean allowEmptyDirFileList() {

            return true;
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {
                String strInput = inputParamList.get(i);

                File tempFile = new File(curDirPath + File.separator + strInput);
                if (tempFile.exists() && !tempFile.isDirectory()) {
                    String inputFileName = tempFile.getName().toLowerCase();
                    if (inputFileName.endsWith(".pdf")) {
                        targetPDF_File = tempFile;
                        continue;
                    }
                }

                if (strInput.contains("_") && !strInput.contains("#") && strInput.contains("page_")) {
                    // 去除掉_ 下划线后 全是数值
                    String verifyStr = strInput.replace("page_", "");
                    String verifyStr_2 = verifyStr.replace("_", "");
                    if (isNumeric(verifyStr_2)) {
                        page_page_StrArr.add(verifyStr);
                    }
                }

            }

            if (targetPDF_File == null || page_page_StrArr.size() == 0) {
                System.out.println("用户对于 规则 rule" + rule_index + "输入错误！  没有输入 指定的 pdf文件!");
                return false;
            }
            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {
            // TODO Auto-generated method stub
            if (targetPDF_File == null || page_page_StrArr.size() == 0) {
                System.out.println("用户对于 规则 rule" + rule_index + "输入错误！  没有输入 指定的 pdf文件!");

                return null;
            }

            try {
                for (int i = 0; i < page_page_StrArr.size(); i++) {

                    System.out.println("规则" + rule_index + " Param" + i + "[" + page_page_StrArr.get(i) + "]");
                }

                for (int i = 0; i < page_page_StrArr.size(); i++) {
                    String index_str_item = page_page_StrArr.get(i);
                    // 可能是 -1 , index_pre 为 -1 标示 从第一页 开始遍历
                    int index_pre = calculPageString(index_str_item, true);
                    System.out.println("calculPageString_index_pre = " + index_pre);
                    if (index_pre == -1 || index_pre < 0) { // 从第一页开始计数的
                        index_pre = 1;
                    }

                    // index_end 为 -1 标示 读取到 pdf的最后一页 这个页数需要读文件 才能拿取到
                    int index_end = calculPageString(index_str_item, false);
                    System.out.println("calculPageString_index_end = " + index_end);

                    PdfReader reader = new PdfReader(targetPDF_File.getAbsolutePath());

                    int numberOfPages_Pdf = reader.getNumberOfPages(); // 读取文件大小
                    reader.close(); // 关闭

                    if (index_end == -1 || index_end < 0) {
                        index_end = numberOfPages_Pdf;
                    }

                    // 如果索引超过了 文件的页数 那么更正
                    if (index_end > numberOfPages_Pdf) {
                        index_end = numberOfPages_Pdf;
                    }

                    if (index_pre > index_end) {
                        int temp = index_pre;
                        index_pre = index_end;
                        index_end = temp;
                    }

                    System.out.println("当前Page_Page字符串【" + index_str_item + "】  当前解析索引 pre_index=" + index_pre
                            + "  end_index=" + index_end + " PDF总页数=" + numberOfPages_Pdf);
                    String newPdfName = targetPDF_File.getParentFile().getAbsolutePath() + File.separator
                            + (getFileNameNoPoint(targetPDF_File.getName())) + "_" + index_pre + "_" + index_end
                            + ".pdf";

                    reader = new PdfReader(targetPDF_File.getAbsolutePath());
                    Document doc = new Document();
                    String splitFileName = newPdfName;
                    PdfCopy pdfCopy;
                    try {
                        pdfCopy = new PdfCopy(doc, new FileOutputStream(splitFileName));
                    } catch (FileNotFoundException | DocumentException e) {
                        System.out.println("分隔失败---》 当前Page_Page字符串【" + index_str_item + "】  当前解析索引 pre_index="
                                + index_pre + "  end_index=" + index_end + " PDF总页数=" + numberOfPages_Pdf);

                        throw new Exception("切割文件副本创建失败 AAAAA1111 ");

                    }
                    doc.open();
                    // 将pdf按页复制到新建的PDF中
                    System.out.println("PDF 循环起点 index_pre=" + index_pre + "   终点index_end=" + index_end);
                    for (int j = index_pre; j <= index_end; ++j) {
//				                System.out.println("jAA  = "+ j);
                        doc.newPage();
//				                System.out.println("jBB  = "+ j);
                        PdfImportedPage page = pdfCopy.getImportedPage(reader, j);
                        pdfCopy.addPage(page);
                    }
                    doc.close();

                    pdfCopy.close();

                }

            } catch (Exception e) {
                System.out.println("当前 执行 pdf 分割操作报错！AAA " + e.getLocalizedMessage());

            }

            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        int calculPageString(String pageStr, boolean isPre) {
            int pageIndex = -1;
            String fixed_str = pageStr.replace("__", "_").trim();
            fixed_str = fixed_str.replace("___", "_");
            fixed_str = fixed_str.replace("__", "_");
            fixed_str = fixed_str.replace("__", "_"); // 只有一个 _ 下划线了

            String[] splitArr = fixed_str.split("_");

            if (splitArr == null) {
                return pageIndex;
            }

            if (fixed_str.startsWith("_")) { // 如果以_ 开头说明 没有指定 起点 指定了终点
                if (isPre) {
                    return pageIndex;
                } else { //
                    String endIndex = fixed_str.replace("_", "");
                    if (isNumeric(endIndex)) {
                        return Integer.parseInt(endIndex);
                    }
                }

            } else if (fixed_str.endsWith("_")) { // 没有指定末尾页数 那么返回 -1 指定了起始页
                if (isPre) {
                    String preIndex = fixed_str.replace("_", "");
                    if (isNumeric(preIndex)) {
                        return Integer.parseInt(preIndex);
                    }

                } else { //
                    return pageIndex;
                }

            }

            if (splitArr.length != 2) {
                return pageIndex;
            }

            String preStr = splitArr[0];

            String endStr = splitArr[1];
            if (isPre && isNumeric(preStr)) {
                return Integer.parseInt(preStr);

            } else if (!isPre && isNumeric(endStr)) {
                return Integer.parseInt(endStr);
            }

            return pageIndex;
        }

        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_" + rule_index
                    + "  <指定Pdf文件>  page_1_10 page_11_20 page_30_40  ###  PDF从第一页开始 分隔当前的pdf文件中的1_10page 形成新的文件   \n"
                    + Cur_Bat_Name + " #_" + rule_index
                    + "  A.pdf  page_1_10  page_2_20  ### 解析当前的A.pdf 生成 下划线分隔 A_1_10.pdf 文件 分隔新page的pdf文件 \n"
                    + Cur_Bat_Name + " #_" + rule_index
                    + "  A.pdf  page_10_  page_50_  ### 解析当前的A.pdf 生成 从第10页开始解析到最后  从第50页开始解析到最后 \n"

                    ;
        }

    }

    class Append_Pdf_Rule_35 extends Basic_Rule {

        ArrayList<File> mPdfFileList; // 当前 cmd 参数给出的 pdf 文件列表 依次合并

        Append_Pdf_Rule_35() {
            super("#", 35, 3); //
            mPdfFileList = new ArrayList<File>();
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {
                String strInput = inputParamList.get(i);

                File tempFile = new File(curDirPath + File.separator + strInput);
                if (tempFile.exists() && !tempFile.isDirectory()) {
                    String inputFileName = tempFile.getName().toLowerCase();
                    if (inputFileName.endsWith(".pdf")) {
                        mPdfFileList.add(tempFile);
                    }
                }
            }

            if (mPdfFileList.size() < 2) {
                System.out.println("当前 命令行输入的 pdf 文件个数 小于2个无法 执行合并 操作!");
                return false;
            }
            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {
            // TODO Auto-generated method stub
            if (mPdfFileList.size() < 2) {
                System.out.println("当前 命令行输入的 pdf 文件个数 小于2个无法 执行合并 操作!");
                return null;
            }

            try {

                String originName = mPdfFileList.get(0).getName();
                String currentTimeStamp = "_" + getTimeStamp();
                String newPdfFileName = getFileNameNoPoint(originName) + currentTimeStamp + ".pdf";

                File newPdfFile = new File(curDirPath + File.separator + newPdfFileName);
                File mergedFIle = mulFile2One(mPdfFileList, newPdfFile.getAbsolutePath());
                System.out.println(" 新 合并文件大小:" + mergedFIle.length());

                if (mergedFIle.length() > 0) {
                    for (int i = 0; i < mPdfFileList.size(); i++) {
                        File tempFile = mPdfFileList.get(i);
                        tempFile.delete();
                    }

                    tryReName(mergedFIle, originName);
                }

                System.out.println("OK!  PDF 文件 已经 生成 --> " + originName);

            } catch (Exception e) {
                System.out.println("当前 执行 pdf 合并操作报错！" + e.getLocalizedMessage());

            }

            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_" + rule_index
                    + "  <指定A.Pdf文件> <指定B.Pdf文件>  ### 按顺序合并当前所有pdf到一个pdf文件中 原有pdf删除   \n" + Cur_Bat_Name + " #_"
                    + rule_index + "  A.pdf B.pdf C.pdf   ### 按顺序合并当前所有pdf到一个pdf文件中 原有pdf删除    \n";
        }

        /*
         * String ruleTip(String type, int index, String batName, OS_TYPE curType) {
         * String itemDesc = ""; String desc_true =
         * "  对给定的 pdf文件A   pdf文件B  pdf文件C 文件进行合并 合并的pdf文件名称为 pdfA文件名称,并删除原pdf文件 ";
         *
         * if (curType == OS_TYPE.Windows) { itemDesc = batName.trim() + ".bat  " + type
         * + "_" + index + "      <指定Pdf文件A> <指定Pdf文件B>   <指定Pdf文件C>     ## [索引 " +
         * index + "]  描述: " + desc_true + "\n";
         *
         * } else { itemDesc = batName.trim() + ".sh " + type + "_" + index +
         * "     <指定Pdf文件A>  <指定Pdf文件B>   <指定Pdf文件C>    ##   [索引 " + index + "]  描述:" +
         * desc_true; }
         *
         * return itemDesc; }
         */

    }

    public static File mulFile2One(List<File> files, String targetPath) throws IOException {
        // pdf合并工具类
        PDFMergerUtility mergePdf = new PDFMergerUtility();
        for (File f : files) {
            if (f.exists() && f.isFile()) {
                // 循环添加要合并的pdf
                mergePdf.addSource(f);
            }
        }
        // 设置合并生成pdf文件名称
        mergePdf.setDestinationFileName(targetPath);
        // 合并pdf
        mergePdf.mergeDocuments(MemoryUsageSetting.setupMainMemoryOnly());
        return new File(targetPath);
    }

    static final transient Rule34_MP3_NodeImpl Rule34_RootNodeImpl = new G2_ApplyRuleFor_TypeFile().new Rule34_MP3_NodeImpl(
            0, "全部", 0, 0, null);

    class MP3_Revert2JSOn_Rule_34 extends Basic_Rule {

        int Node_ID_Num = 0;
        String[] Alphabet;

        int getNextNodeID() {
            Node_ID_Num++;
            return Node_ID_Num;
        }

        // 第一部分的 字母表 序列 level== 1
        ArrayList<Rule34_MP3_NodeImpl> alphabet_node_list;

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            return super.initParamsWithInputList(inputParamList);
        }

        MP3_Revert2JSOn_Rule_34() {
            super("#", 34, 4);
            Alphabet = new String[] { "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P",
                    "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z" };
            alphabet_node_list = new ArrayList<Rule34_MP3_NodeImpl>();
            Node_ID_Num = 0;
        }

        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_34   ### 解析当前的MP3文件生成对应的 mp3_tree.json 文件  \n" + Cur_Bat_Name
                    + " #_34    ### 解析当前的MP3文件生成对应的 mp3_tree.json 文件 \n";
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            // TODO Auto-generated method stub
            ArrayList<File> allMp3FileList = new ArrayList<File>();

            ArrayList<File> mp3List_1 = subFileTypeMap.get(".mp3");
            ArrayList<File> mp3List_2 = subFileTypeMap.get(".MP3");
            if (mp3List_1 != null) {

                allMp3FileList.addAll(mp3List_1);
            }
            if (mp3List_2 != null) {

                allMp3FileList.addAll(mp3List_2);
            }

            if (allMp3FileList.size() == 0) {
                System.out.println("Rule34 当前的文件夹中 MP3文件的个数为0  请检查!!!");
                return null;
            }

            for (int i = 0; i < Alphabet.length; i++) {
                String alphaItem = Alphabet[i];

                /*
                 * public Rule34_MP3_NodeImpl(long id, String name, int count,int level , String
                 * xmp3Path) { this.id = id; this.name = name; this.count = count; this.level =
                 * level; this.mp3path = xmp3Path;
                 *
                 * }
                 */
                Rule34_MP3_NodeImpl Rule34_RootNodeImpl = mG2_Object.new Rule34_MP3_NodeImpl(getNextNodeID(), alphaItem,
                        0, 1, null);
                alphabet_node_list.add(Rule34_RootNodeImpl);
            }
            Rule34_RootNodeImpl.children.addAll(alphabet_node_list);

            // 把 当前 目录下的 mp3 依据 作者分类 分好

            HashMap<String, ArrayList<Rule34_MP3_NodeImpl>> mArtist_File_Map = new HashMap<String, ArrayList<Rule34_MP3_NodeImpl>>();

            // 依据 备注 进行 分类 得到的 Item 粤语 英语 纯语 更多分类 留下扩展
            HashMap<String, ArrayList<Rule34_MP3_NodeImpl>> mComment_File_Map = new HashMap<String, ArrayList<Rule34_MP3_NodeImpl>>();

            for (int i = 0; i < allMp3FileList.size(); i++) {

                try {
                    File File_realMP3 = allMp3FileList.get(i);
                    String mp3Name_nopoint = getFileNameNoPoint(allMp3FileList.get(i).getName());

                    String mp3File_Path = File_realMP3.getAbsolutePath();
                    Mp3File mp3file_item = new Mp3File(allMp3FileList.get(i).getAbsolutePath());
                    if (mp3file_item.hasId3v2Tag()) {
                        ID3v2 id3v2Tag = mp3file_item.getId3v2Tag();

                        String titleName_tag = id3v2Tag.getTitle().trim();
                        String ArtistName_tag = id3v2Tag.getArtist().trim();
                        String CommentName_tag = id3v2Tag.getComment().trim();

                        if (mArtist_File_Map.containsKey(ArtistName_tag)) {
                            ArrayList<Rule34_MP3_NodeImpl> curArr = mArtist_File_Map.get(ArtistName_tag);
                            curArr.add(mG2_Object.new Rule34_MP3_NodeImpl(getNextNodeID(), titleName_tag, 0, 3,
                                    mp3File_Path));
                        } else {
                            ArrayList<Rule34_MP3_NodeImpl> targetArr = new ArrayList<Rule34_MP3_NodeImpl>();
                            targetArr.add(mG2_Object.new Rule34_MP3_NodeImpl(getNextNodeID(), titleName_tag, 0, 3,
                                    mp3File_Path));
                            mArtist_File_Map.put(ArtistName_tag, targetArr);
                        }

                    }
                } catch (Exception e) {
                    System.out.println("RuleIndex 34  解析MP3文件出现错误! ");

                }
            }

            Show_AddNode_MP3Map(mArtist_File_Map, alphabet_node_list);

            showRootNodeContent(Rule34_RootNodeImpl);

            System.out.println("RuleIndex 34   MP3文件属性的操作 执行完成!");

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        // 从 上 到下 依次 显示 当前的 Node 的 内容
        void showRootNodeContent(Rule34_MP3_NodeImpl rootNode) {

//			{
//				  "id": -1,
//				  "name": "全部",
//				  "count": 21,
//				  "children": [  ]
//			}

            System.out.println("════════════════════════════════" + " Root JSON" + "════════════════════════════════");

            String mp3Json = rootNode.json();

//			mp3Json = StringEscape.unescapeJava(mp3Json);

            if (JSONUtil.isJson(mp3Json)) {
                System.out.println("═════════════════ 是JSON  ═════════════════");

                mp3Json = JSONUtil.formatJsonStr(mp3Json);
                System.out.println(mp3Json);
            } else {
                System.out.println("═════════════════ 不是JSON  ═════════════════");

                mp3Json = JSONUtil.formatJsonStr(mp3Json);
//				System.out.println(mp3Json);

            }

            File Mp3_Json_File = new File(curDirFile.getAbsolutePath() + File.separator + "MP3_JSON.json");
            writeContentToFile(Mp3_Json_File, mp3Json);
            NotePadOpenTargetFile(Mp3_Json_File.getAbsolutePath());

        }

        Rule34_MP3_NodeImpl getNodeImpl_With_Zimu(ArrayList<Rule34_MP3_NodeImpl> alphabet_node_list,
                                                  String charAlhapbet) {
            Rule34_MP3_NodeImpl selectedNode = null;
            for (int i = 0; i < alphabet_node_list.size(); i++) {
                Rule34_MP3_NodeImpl node = alphabet_node_list.get(i);
                if (node.name.toUpperCase().equals(charAlhapbet.toUpperCase())) {
                    selectedNode = node;
                    break;
                }

            }

            return selectedNode;

        }

        @SuppressWarnings("unchecked")
        boolean Show_AddNode_MP3Map(HashMap<String, ArrayList<Rule34_MP3_NodeImpl>> xMP3FileMap,
                                    ArrayList<Rule34_MP3_NodeImpl> alphabet_node_list) {
            boolean executeFlag = false;
            Map.Entry<String, ArrayList<Rule34_MP3_NodeImpl>> entry;

            if (xMP3FileMap != null) {
                Iterator iterator = xMP3FileMap.entrySet().iterator();
                while (iterator.hasNext()) {
                    entry = (Map.Entry<String, ArrayList<Rule34_MP3_NodeImpl>>) iterator.next();

                    // 获取 名称的 首字母
                    String arrTag = entry.getKey(); // Map的Value // 作者名称
                    String Alphabet_Word = getFirstZiMu(arrTag);
                    Rule34_MP3_NodeImpl selectedNode_level_1 = getNodeImpl_With_Zimu(alphabet_node_list, Alphabet_Word);
                    ArrayList<Rule34_MP3_NodeImpl> fileArr_level_3 = entry.getValue(); // Map的Value 歌曲MP3

                    Rule34_MP3_NodeImpl artistNode_level_2 = mG2_Object.new Rule34_MP3_NodeImpl(getNextNodeID(), arrTag,
                            fileArr_level_3.size(), 2, null);

                    selectedNode_level_1.addChildren(artistNode_level_2);

                    System.out.println("═══════════════════════ arrTag[" + arrTag + "]  alphabet=[" + Alphabet_Word
                            + "] all[" + fileArr_level_3.size() + "] ═══════════════════════");

                    for (int i = 0; i < fileArr_level_3.size(); i++) {
                        Rule34_MP3_NodeImpl mp3FileNode_level_3 = fileArr_level_3.get(i);

                        System.out.println("____________ arrTag[" + arrTag + "] alphabet=[" + Alphabet_Word + "] index["
                                + (i + 1) + "] all[" + fileArr_level_3.size() + "] ____________");
                        System.out.println(mp3FileNode_level_3.toString());

                        artistNode_level_2.addChildren(mp3FileNode_level_3);
                    }

                }
            }

            return executeFlag;
        }

        String getFirstZiMu(String srcStr) {
            String firstZimu = "U"; // 默认为 Unknow;
            if (srcStr == null || "".equals(srcStr.trim())) {
                return firstZimu;
            }

            if (!isContainChinese(srcStr)) { // 如果 不包含中文 那么 取这个词的 第一个字符
                String char_1 = srcStr.substring(0, 1).toUpperCase();
                firstZimu = char_1;

            } else {
                String char_1 = srcStr.substring(0, 1).toUpperCase();
//				System.out.println("X2 char_1 = "+char_1 );
                if (!isContainChinese(char_1)) {
                    firstZimu = char_1;
                } else { // 如果第一个字母为汉字 那么取到这个字的 拼音的 第一个词
                    String pinyinStr = ToPinyin(char_1);
//					System.out.println("X2  pinyinStr = "+pinyinStr );
                    String char_1_fixed = pinyinStr.substring(0, 1).toUpperCase();
                    firstZimu = char_1_fixed;
                }

            }

//			System.out.println("X3  firstZimu = "+firstZimu );
            return firstZimu;

        }

    }

    class Rule34_MP3_NodeImpl implements Rule34_MP3_Node, Serializable {

        private static final long serialVersionUID = 1L;

        public long id;
        public String name;
        public int count;
        public int level;
        public String mp3path;
        public List<Rule34_MP3_NodeImpl> children = new ArrayList<>();
        private transient long selectedChildId;

//	    {
//	    	  "id": -1,
//	    	  "name": "全部",
//	    	  "count": 21,
//	    	  "children": []
//	    }

        @Override
        public String json() {
            count = children.size();
            System.out.println("___________【" + name + "】 Node_Level_" + level + "节点情况 Begin ___________");
            for (int i = 0; i < children.size(); i++) {
                System.out.println(children.get(i).toString());
            }
            System.out.println("___________【" + name + "】Node_Level_" + level + "节点情况 End ___________");
            System.out.println();

            StringBuilder sb_json = new StringBuilder();
            sb_json.append("{\n");
            sb_json.append("\"id\": " + id + ",\n");
            sb_json.append("\"name\": " + "\"" + name + "\"" + ",\n");
            sb_json.append("\"count\": " + count + ",\n");
            sb_json.append("\"level\": " + level + ",\n");

            if (mp3path != null) {
                sb_json.append("\"mp3path\": " + "\"" + (mp3path.replace("\\", "\\\\")) + "\"" + ",\n");
            } else {
                sb_json.append("\"mp3path\": \"null\"" + ",\n");
            }

            if (children == null || children.size() == 0) {
                sb_json.append("\"children\": " + "[]\n");
            } else {
                sb_json.append("\"children\": " + "[\n");
                for (int i = 0; i < children.size(); i++) {
                    Rule34_MP3_NodeImpl childNode = children.get(i);
                    if (childNode != null && childNode.children() != null && childNode.children().size() > 0) {
                        System.out.println("childNode.name = " + childNode.name + "  childNode.level=" + childNode.level
                                + "  childNode.id=" + childNode.id + "  childNode.count="
                                + childNode.children().size());

                        // 子节点 之间 使用 , 逗号 分隔
                        if (i == children.size() - 1) {
                            sb_json.append(childNode.json() + "\n");
                        } else {
                            sb_json.append(childNode.json() + ",\n");
                        }

                    } else {
                        System.out.println("结点 的 childNode 为空！！！ 为叶子节点");
                        if (childNode != null) {
                            if (i == children.size() - 1) {
                                sb_json.append(childNode.json() + "\n");
                            } else {
                                sb_json.append(childNode.json() + ",\n");
                            }

                        }

                    }

                }
                sb_json.append("]\n");
            }

            sb_json.append("}\n");
            return sb_json.toString();
        }

        @Override
        public void setmp3path(String mp3Path) {
            this.mp3path = mp3Path;

        }

        @Override
        public void setlevel(int level) {
            // TODO Auto-generated method stub
            this.level = level;
        }

        @Override
        public int level() {
            // TODO Auto-generated method stub
            return level;
        }

        @Override
        public String mp3path() {
            // TODO Auto-generated method stub
            return mp3path;
        }

        public Rule34_MP3_NodeImpl(long id, String name, int count, int level, String xmp3Path) {
            this.id = id;
            this.name = name;
            this.count = count;
            this.level = level;
            this.mp3path = xmp3Path;
            children = new ArrayList<>();

        }

        @Override
        public long id() {
            return id;
        }

        @Nonnull
        @Override
        public String text() {
            return name + "(" + count + ")";
        }

        @Override
        public long selectedChild() {
            return selectedChildId;
        }

        @Override
        public void setSelectedChild(long id) {
            selectedChildId = id;
        }

        @Nullable
        @Override
        public List<? extends Rule34_MP3_Node> children() {
            return children;
        }

        public void setChildren(List<Rule34_MP3_NodeImpl> children) {
            this.children = children;
        }

        public void addChildren(Rule34_MP3_NodeImpl oneChildren) {
            this.children.add(oneChildren);
        }

        @Override
        public Rule34_MP3_Node getSelectedChild() {
            int i = getSelectedChildPosition();
            if (i == -1)
                return null;
            // in case of IndexOutOfBoundsException
            if (i >= 0 && i < children.size()) {
                return children.get(i);
            } else {
                return null;
            }
        }

        public String getName() {
            return name;
        }

        @Override
        public String toString() {
            return "text=[" + text() + "] " + "  id=[" + id + "] " + "  level=[" + level() + "]" + "  count=["
                    + children.size() + "]" + " mp3path=[" + mp3path() + "]";
        }

        private int getSelectedChildPosition() {
            if (children == null)
                return -1;
            for (int i = 0; i < children.size(); i++) {
                Rule34_MP3_NodeImpl nodeImpl = children.get(i);
                if (nodeImpl == null)
                    continue;
                if (nodeImpl.id == selectedChildId) {
                    return i;
                }
            }
            return -1;
        }

    }

    public interface Rule34_MP3_Node {

        /**
         * 标记唯一性
         *
         * @return -1 when it is root
         */
        long id();

        String json();

        // 当前的层级
        int level();

        // 当前的对应的 MP3 文件的 全路径
        String mp3path();

        void setmp3path(String mp3Path);

        void setlevel(int level);

        /**
         * 显示文案
         */
        @Nonnull
        String text();

        /**
         * 被选中的Id
         *
         * @return -1 when {@link #children()} is null
         */
        long selectedChild();

        void setSelectedChild(long id);

        /**
         * 子树(为空表示是叶节点)
         *
         * @return null when it is a leaf
         */
        @Nullable
        List<? extends Rule34_MP3_Node> children();

        /**
         * 返回被选中的child
         */
        Rule34_MP3_Node getSelectedChild();

    }

    class MP3_Prop_Fixed_Rule_33 extends Basic_Rule {
        String mTitle; // mp3文件的 标题
        String mArtist; // mp3文件的 作者
        String mComment; // mp3文件的 备注
        boolean isCommentAppend; // 是否是在Comment 进行追加 而不是替换

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            boolean Flag = true;

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem = inputParamList.get(i);
                String paramItem_lower_trim = paramItem.toLowerCase().trim();
                if (paramItem_lower_trim.contains("title_")) {
                    String replaceTitle = paramItem.replace("title_", "").replace("Title_", "").trim();
                    mTitle = replaceTitle;
                }

                if (paramItem_lower_trim.contains("artist_")) {
                    String replaceArtist = paramItem.replace("artist_", "").replace("Artist_", "").trim();
                    mArtist = replaceArtist;
                }

                if (paramItem_lower_trim.contains("comment_")) {
                    String replaceComment = paramItem.replace("comment_", "").replace("Comment_", "").trim();
                    mComment = replaceComment;
                }
                if (paramItem_lower_trim.contains("commentappend_")) {
                    String replaceComment = paramItem.replace("commentappend_", "").replace("Commentappend_", "")
                            .trim();
                    mComment = replaceComment;
                    isCommentAppend = true;
                }

            }
            System.out.println("用户输入的 三个替换参数 mTitle=" + mTitle + "  mArtist=" + mArtist + "   mComment=" + mComment);

            if (mTitle == null && mArtist == null && mComment == null) {

                Flag = false;
                System.out.println("无法检测到用户输入的 需要修改的 MP3的三个属性 Title_xx  Artist_xxx Comment_xxx 程序执行失败!  请检查 ");
            }

            return super.initParamsWithInputList(inputParamList) && Flag;
        }

        MP3_Prop_Fixed_Rule_33() {
            super("#", 33, 4);
            isCommentAppend = false;
        }

        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_33   artist_周杰伦  comment_国语  title_稻香     ### 把当前的 mp3的属性进行批量的修改  \n"
                    + Cur_Bat_Name + " #_33  artist_周杰伦  comment_国语   ### 把当前的 mp3的属性comment 和 artist 修改 \n"
                    + Cur_Bat_Name + " #_33  artist_周杰伦  title_稻香   ### 把当前的 mp3的属性comment 和 title 修改 \n" + Cur_Bat_Name
                    + " #_33  comment_国语  title_稻香   ### 把当前的 mp3的属性title 和 comment 修改 \n" + Cur_Bat_Name
                    + "  #_33 comment_国语   ### 把当前的 mp3的属性commont 改为国语  \n" + Cur_Bat_Name
                    + "  #_33 comment_粤语   ### 把当前的 mp3的属性commont 改为粤语   \n" + Cur_Bat_Name
                    + "  #_33 comment_英语   ### 把当前的 mp3的属性commont 改为英语   \n" + Cur_Bat_Name
                    + "  #_33 comment_纯语   ### 把当前的 mp3的属性commont 改为纯语   \n" + Cur_Bat_Name
                    + "  #_33 commentappend_收藏   ### 把当前的 mp3的属性commont 追加一个 原始Comment_收藏 为 Comment   \n" + Cur_Bat_Name
                    + "  #_33 commentappend_追赠   ### 把当前的 mp3的属性commont 追加一个 原始Comment_追赠 为 Comment   \n" + Cur_Bat_Name
                    + "  #_33 comment_纯语   ### 把当前的 mp3的属性commont 改为纯语   \n"

                    + Cur_Bat_Name + "  #_33 artist_周杰伦   ### 把当前的 mp3的属性artist 改为周杰伦 \n" + Cur_Bat_Name
                    + "  #_33 title_晴天   ### 把当前的 mp3的属性title 改为晴天 \n";
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            // TODO Auto-generated method stub
            ArrayList<File> allMp3FileList = new ArrayList<File>();

            ArrayList<File> mp3List_1 = subFileTypeMap.get(".mp3");
            ArrayList<File> mp3List_2 = subFileTypeMap.get(".MP3");
            if (mp3List_1 != null) {

                allMp3FileList.addAll(mp3List_1);
            }
            if (mp3List_2 != null) {

                allMp3FileList.addAll(mp3List_2);
            }

            if (allMp3FileList.size() == 0) {
                System.out.println("当前的文件夹中 MP3文件的个数为0  请检查!!!");
                return null;
            }

            // 没有 tag的 mp3文件的集合 // 估计会改名
            ArrayList<File> unTagedMp3FileList = new ArrayList<File>();

            String TargetDirName = "MP3_Fixed_" + getTimeStamp();

            String fixed_name = null;
            for (int i = 0; i < allMp3FileList.size(); i++) {

                try {
                    String mp3Name_nopoint = getFileNameNoPoint(allMp3FileList.get(i).getName());

                    File mp3File = allMp3FileList.get(i);
                    Mp3File mp3file = new Mp3File(allMp3FileList.get(i).getAbsolutePath());
                    String d3v1_title = null;
                    String d3v1_artist = null;
                    String d3v1_comment = null;

                    if (mp3file.hasId3v1Tag()) {

                        ID3v1 id3v1Tag = mp3file.getId3v1Tag();
//						  System.out.println("Track: " + id3v1Tag.getTrack());
//						  System.out.println("Artist: " + id3v1Tag.getArtist());
//						  System.out.println("Title: " + id3v1Tag.getTitle());
//						  System.out.println("Album: " + id3v1Tag.getAlbum());
//						  System.out.println("Year: " + id3v1Tag.getYear());
//						  System.out.println("Genre: " + id3v1Tag.getGenre() + " (" + id3v1Tag.getGenreDescription() + ")");
//						  System.out.println("Comment: " + id3v1Tag.getComment());
                        d3v1_title = id3v1Tag.getTitle();
                        d3v1_artist = id3v1Tag.getArtist();
                        d3v1_comment = id3v1Tag.getComment();

                    }

                    if (mp3file.hasId3v2Tag()) {
                        ID3v2 id3v2Tag = mp3file.getId3v2Tag();
                        String titleName_old = id3v2Tag.getTitle();
                        String ArtistName_old = id3v2Tag.getArtist();
                        String CommentName_old = id3v2Tag.getComment();

                        boolean mTitleExist = false;
                        boolean mCommentExist = false;
                        boolean mArtistExist = false;
//							String mTitle; // mp3文件的 标题
//							String mArtist; // mp3文件的 作者
//							String mComment; // mp3文件的 备注
                        if (mTitle != null && !"".equals(mTitle)) {
                            id3v2Tag.setTitle(mTitle);
                            titleName_old = mTitle;
                            mTitleExist = true;
                        }

                        if (mArtist != null && !"".equals(mArtist)) {
                            id3v2Tag.setArtist(mArtist);
                            mArtistExist = true;
                        }

                        if (mComment != null && !"".equals(mComment)) {
                            if (isCommentAppend) { // 追加 而不是 替换
                                String mCommentAppendStr = CommentName_old + "_" + mComment;
                                mCommentAppendStr = mCommentAppendStr.replace("__", "_").trim();
                                if (mCommentAppendStr.startsWith("_")) {
                                    mCommentAppendStr = mCommentAppendStr.substring(1, mCommentAppendStr.length());
                                }
                                id3v2Tag.setComment(mCommentAppendStr);
                            } else {
                                id3v2Tag.setComment(mComment);
                            }

                            mCommentExist = true;
                        }

                        mp3file.setId3v2Tag(id3v2Tag);

                        fixed_name = titleName_old;

                        if (titleName_old == null || "".equals(titleName_old.trim())) {

                            fixed_name = mp3Name_nopoint.replace("_", "");
                            fixed_name = clearNumber(fixed_name).trim();
                            if ("".equals(fixed_name)) {
                                fixed_name = "unknow";
                            }

                        }

                        String titleName_new = id3v2Tag.getTitle();
                        String ArtistName_new = id3v2Tag.getArtist();
                        String CommentName_new = id3v2Tag.getComment();

                        fixed_name = fixed_name.replace(" ", "_");
                        fixed_name = fixed_name.replace("《", "_");
                        fixed_name = fixed_name.replace("》", "_");
                        fixed_name = fixed_name.replace("（", "_");
                        fixed_name = fixed_name.replace("）", "_");
                        fixed_name = fixed_name.replace("(", "_");
                        fixed_name = fixed_name.replace(")", "_");
                        fixed_name = fixed_name.replace("___", "_");
                        fixed_name = fixed_name.replace("__", "_");
                        fixed_name = fixed_name.replace("__", "_");
                        fixed_name = fixed_name + "_" + getTimeStamp();
                        fixed_name = fixed_name.replace("__", "_");

                        File mp3File_DirTarget_File = new File(allMp3FileList.get(i).getParentFile().getAbsolutePath()
                                + File.separator + TargetDirName);

                        if (!mp3File_DirTarget_File.exists()) {
                            mp3File_DirTarget_File.mkdirs();
                        }
                        mp3file.save(allMp3FileList.get(i).getParentFile().getAbsolutePath() + File.separator
                                + TargetDirName + File.separator + fixed_name + ".mp3");

                        StringBuilder SBLog = new StringBuilder();

                        SBLog.append(" 当前生成文件[" + (i + 1) + "]: " + fixed_name + ".mp3 ");

//							  d3v1_title = id3v1Tag.getTitle();
//							  d3v1_artist = id3v1Tag.getArtist();
//							  d3v1_comment = id3v1Tag.getComment();

                        if (mTitleExist) {
                            SBLog.append(" Title[" + titleName_old + "] -> Title[" + titleName_new
                                    + "]  v2_titleName_old=" + titleName_old + "  v2_ArtistName_old=" + ArtistName_old
                                    + "  v2_CommentName_old=" + CommentName_old + "  v1_titleName_old=" + d3v1_title
                                    + "  v1_ArtistName_old=" + d3v1_artist + "  v1_CommentName_old=" + d3v1_comment);
                        }

                        if (mArtistExist) {
                            SBLog.append(" Artist[" + ArtistName_old + "] -> Artist[" + ArtistName_new
                                    + "]  v2_titleName_old=" + titleName_old + "  v2_ArtistName_old=" + ArtistName_old
                                    + "  v2_CommentName_old=" + CommentName_old + "  v1_titleName_old=" + d3v1_title
                                    + "  v1_ArtistName_old=" + d3v1_artist + "  v1_CommentName_old=" + d3v1_comment);
                        }

                        if (mCommentExist) {
                            SBLog.append(" Comment[" + CommentName_old + "] -> Comment[" + CommentName_new
                                    + "]  v2_titleName_old=" + titleName_old + "  v2_ArtistName_old=" + ArtistName_old
                                    + "  v2_CommentName_old=" + CommentName_old + "  v1_titleName_old=" + d3v1_title
                                    + "  v1_ArtistName_old=" + d3v1_artist + "  v1_CommentName_old=" + d3v1_comment);
                        }

                        SBLog.append("  文件原名称[" + mp3Name_nopoint + "]");
                        System.out.println(SBLog.toString());

                    } else {

                        unTagedMp3FileList.add(allMp3FileList.get(i));
                    }
                } catch (Exception e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();

                    System.out.println("创建 Mp3File 文件失败!!! 失败文件" + (i + 1) + fixed_name + ".mp3 ");
                }

            }

            //
            if (unTagedMp3FileList.size() > 0) {
                System.out
                        .println("═════════════════════════ " + "失败!!! 遗憾存在 MP3转换失败文件 " + "═════════════════════════ ");
                for (int j = 0; j < unTagedMp3FileList.size(); j++) {
                    System.out.println(
                            "没有D3V2-Tag    失败MP3文件[" + (j + 1) + "] = " + unTagedMp3FileList.get(j).getAbsolutePath());
                }

            } else {
                System.out.println(
                        "═════════════════════════ " + "恭喜!!! 当前没有 不存在D3V2-Tag的文件 " + "═════════════════════════ ");

            }
            System.out.println("RuleIndex 33 修改 MP3文件属性的操作 执行完成!");

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

    }

    class MakeJpg2PDF_Rule_32 extends Basic_Rule {

        MakeJpg2PDF_Rule_32() {
            super("#", 32, 4);

        }

        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_32    // 把当前的 jpg 和 png 文件转为一个 PDF文件  (不操作 孙文件 孙文件夹 )  \n" + Cur_Bat_Name
                    + "  #_32   ### 把当前的 jpg 和 png 文件转为一个 PDF文件  \n"

                    ;
        }

        @Override
        boolean allowEmptyDirFileList() {
            // TODO Auto-generated method stub
            return true;
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            ArrayList<File> pictureFileList = new ArrayList<File>();
            int picture_index = 1;
            for (int i = 0; i < curRealFileList.size(); i++) {
                File curFile = curRealFileList.get(i);
                String currentFileName = curFile.getName().toLowerCase();
                if (currentFileName.endsWith(".jpg") || currentFileName.endsWith(".png")) {
                    pictureFileList.add(curFile);
                    System.out.println("picture_index[" + picture_index + "] = " + curFile.getAbsolutePath());
                    picture_index++;
                }

            }

            if (pictureFileList.size() > 0) {
                SortFileWithName(pictureFileList);
                Document document = new Document();
                String result_pdf = curDirPath + File.separator + "Z_PDF_Merge" + pictureFileList.size() + "_"
                        + getTimeStamp() + ".pdf";

                FileOutputStream os;
                try {
                    os = new FileOutputStream(new File(result_pdf));
                    try {
                        PdfWriter.getInstance(document, os);
                    } catch (DocumentException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                } catch (FileNotFoundException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }

                document.open();
                for (int i = 0; i < pictureFileList.size(); i++) {
                    File imageFile = pictureFileList.get(i);
                    String imageFilename = imageFile.getName();
                    createPicInPDF(document, imageFile.getAbsolutePath(), i);
                    System.out.println("jpg[" + i + "] all[" + pictureFileList.size() + "] Name[" + imageFilename + "] "
                            + "图片转为 PDF完成");
                }

                document.close();
                System.out.println("═════════" + pictureFileList.size() + "张图片转为 PDF完成" + "═════════");

            } else {
                System.out.println("当前目录 没有 JPG PNG 文件 请检查! " + curDirPath);
            }

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        void createPicInPDF(Document document, String picturePath, int index) {
            try {
                com.itextpdf.text.Image image = com.itextpdf.text.Image.getInstance(picturePath);
                float image_width = image.getWidth();
                float image_hight = image.getHeight();

                float imageHeight = image.getScaledHeight();
                float imageWidth = image.getScaledWidth();
                // 设置页面宽高与图片一致
                com.itextpdf.text.Rectangle rectangle = new com.itextpdf.text.Rectangle(imageWidth, imageHeight);
                document.setMargins(0, 0, 0, 0);
                document.setPageSize(rectangle);

                // 图片居中
                image.setAlignment(com.itextpdf.text.Image.ALIGN_CENTER);

//					float documentWidth = document.getPageSize().getWidth() - document.leftMargin() - document.rightMargin();
//					float documentHeight = documentWidth / 580 * 320;// 重新设置宽高
//					float documentWidth = document.getPageSize().getWidth();
//					float documentHeight = document.getPageSize().getHeight();
                System.out.println(
                        "════════════════════ " + index + " (" + picturePath + ")" + " begin ════════════════════ ");
//					System.out.println("index="+index+"  documentWidth = "+documentWidth+"  documentHeight="+documentHeight +" image_width="+image_width+"  image_hight="+image_hight);
                System.out.println(
                        "index=" + index + "   " + " image_width=" + image_width + "  image_hight=" + image_hight);

                image.scaleAbsolute(image_width, image_hight);

                // 根据域的大小缩放图片
//				    image.scaleToFit(documentWidth,documentHeight);
                // 添加图片
//				    image.setAbsolutePosition(documentWidth,documentHeight);
//					image.setAbsolutePosition(documentWidth, documentHeight);
//					image.scaleAbsolute(documentWidth, documentHeight);// 重新设置宽高
//					document.setMargins(0, 0, 0, 0);
                System.out.println("document.topMargin()=" + document.topMargin() + "  document.bottomMargin()"
                        + document.bottomMargin() + "  document.leftMargin()" + document.leftMargin()
                        + "  document.rightMargin()" + document.rightMargin());
                document.newPage();
                document.add(image);
            } catch (Exception ex) {
            }
        }

    }

    class MakeFile_E5_Rule_31 extends Basic_Rule {
        ArrayList<String> fliterTypeList;
        int fileCount; // 创建文件的个数

        // jpg_wordcolor_255_255_255;
        int jpg_R; // 如果是jpg的话 那么 文笔的 颜色
        int jpg_G;
        int jpg_B;

        // jpg_background_255_255_255;
        int jpg_Back_R; // 如果是jpg的话 那么 背景的 颜色
        int jpg_Back_G;
        int jpg_Back_B;

        // jpg_frontsize_500; 默认500
        int jpg_front_size; // 字体的大小 默认 500

        // jpg_wxh_255_500
        int jpg_width; // 生成 照片的宽度
        int jpg_hight; // 生成 照片的高度

        // jpg_shownumber_true;
        boolean isShowNumber; // 是否显示 字母

        MakeFile_E5_Rule_31() {
            super("#", 31, 4);

            fliterTypeList = new ArrayList<String>();
            jpg_R = 255;
            jpg_G = 0;
            jpg_B = 0;

            jpg_Back_R = 255;
            jpg_Back_G = 255;
            jpg_Back_B = 255;

            jpg_front_size = 500;
            jpg_width = 1200;
            jpg_hight = 1200;

            isShowNumber = false;

        }

        @Override
        boolean allowEmptyDirFileList() {
            return true;
        }

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name
                    + "  #_31  100 .jpg     ## 创建100个.jpg文件 白底 默认宽高1200x1200 默认文字颜色 红色 默认背景颜色白色  默认字体大小500  默认不打印数值 \n"
                    + Cur_Bat_Name
                    + "  #_31  100 .png     ## 创建100个.png文件 默认宽高1200x1200 默认文字颜色 红色 默认背景颜色白色  默认字体大小500  默认不打印数值 \n"
                    + Cur_Bat_Name
                    + "  #_31  100 .png .jpg    ## 创建100个.png文件 和 100个.png文件  默认宽高1200x1200 默认文字颜色 红色 默认背景颜色白色  默认字体大小500  默认不打印数值 \n"
                    + Cur_Bat_Name + "  #_31  100 .pptx     ## 创建100个.pptx文件 \n" + Cur_Bat_Name
                    + "  #_31   .pptx     ## 默认创建1个.pptx文件 \n" + Cur_Bat_Name
                    + "  #_31  100 .jpg  jpg_shownumber_true     ## 创建100个白底红字的 jpg图片 默认图片大小1200x1200 \n" + Cur_Bat_Name
                    + "  #_31   .【任意类型】    ## 默认创建1个.【任意类型】格式的文件 \n" + Cur_Bat_Name
                    + " #_31  100 .jpg jpg_shownumber_true jpg_background_255_255_255 jpg_wordcolor_0_0_0 jpg_frontsize_600 jpg_wxh_1000_1000   ##创建100个依据参数确定的.jpg图片  白底黑字\n"
                    + Cur_Bat_Name
                    + " #_31  100 .jpg jpg_shownumber_true jpg_background_0_0_0 jpg_wordcolor_255_255_255 jpg_frontsize_600 jpg_wxh_1000_1000   ##创建100个依据参数确定的.jpg图片  白字黑底\n"
                    + Cur_Bat_Name
                    + " #_31  100 .jpg jpg_shownumber_true jpg_background_0_0_0  jpg_frontsize_600 jpg_wxh_1000_1000   ##创建100个依据参数确定的.jpg图片 黑底红字  \n"
                    + Cur_Bat_Name
                    + " #_31  100 .jpg jpg_shownumber_true jpg_background_255_0_0 jpg_wordcolor_0_0_0  jpg_frontsize_600 jpg_wxh_1000_1000   ##创建100个依据参数确定的.jpg图片 红底黑字  \n"
                    + Cur_Bat_Name
                    + " #_31  100 .jpg jpg_shownumber_true jpg_background_0_0_255 jpg_wordcolor_0_0_0  jpg_frontsize_600 jpg_wxh_1000_1000   ##创建100个依据参数确定的.jpg图片 蓝底黑字  \n"
                    + Cur_Bat_Name
                    + " #_31  100 .jpg jpg_shownumber_true jpg_background_0_0_255 jpg_wordcolor_255_255_255  jpg_frontsize_600 jpg_wxh_1000_1000   ##创建100个依据参数确定的.jpg图片 蓝底白字  \n"
                    + Cur_Bat_Name
                    + " #_31  100 .jpg jpg_shownumber_true jpg_background_0_0_255 jpg_wordcolor_255_0_0  jpg_frontsize_600 jpg_wxh_1000_1000   ##创建100个依据参数确定的.jpg图片 蓝底红字  \n"
                    + Cur_Bat_Name
                    + " #_31  100 .jpg jpg_shownumber_true jpg_background_0_0_255 jpg_wordcolor_255_255_0  jpg_frontsize_600 jpg_wxh_1000_1000   ##创建100个依据参数确定的.jpg图片 蓝底黄字  \n"
                    + Cur_Bat_Name
                    + " #_31  100 .jpg jpg_shownumber_true jpg_background_255_255_0 jpg_wordcolor_0_0_0  jpg_frontsize_600 jpg_wxh_1000_1000   ##创建100个依据参数确定的.jpg图片 黄底黑字  \n"
                    + Cur_Bat_Name
                    + " #_31  100 .jpg jpg_shownumber_true jpg_background_0_255_0 jpg_wordcolor_0_0_0  jpg_frontsize_600 jpg_wxh_1000_1000   ##创建100个依据参数确定的.jpg图片 绿底黑字  \n"

                    ;
        }

        void showParams() {
            System.out.println("═════════════ " + "showParams Rule31--MakeFile" + " ═════════════ ");
            System.out.println("isShowNumber = " + isShowNumber);
            System.out.println("jpg_width = " + jpg_width);
            System.out.println("jpg_hight = " + jpg_hight);
            System.out.println("jpg_front_size = " + jpg_front_size);
            System.out.println("jpg_R = " + jpg_R);
            System.out.println("jpg_G = " + jpg_G);
            System.out.println("jpg_B = " + jpg_B);
            System.out.println("RGB=(" + jpg_R + "," + jpg_G + "," + jpg_B + ")");
            System.out.println("jpg_Back_R = " + jpg_Back_R);
            System.out.println("jpg_Back_G = " + jpg_Back_G);
            System.out.println("jpg_Back_B = " + jpg_Back_B);
            System.out.println("Back_RGB=(" + jpg_Back_R + "," + jpg_Back_G + "," + jpg_Back_B + ")");

        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {
                String param = inputParamList.get(i);
                if (isNumeric(param)) {
                    fileCount = Integer.parseInt(param);
                }

                if (param.startsWith(".")) {
                    fliterTypeList.add(param);
                }

                // // jpg_frontsize_500;
                if (param.startsWith("jpg_frontsize_500")) {
                    String fixedStr = param.replace("jpg_frontsize_", "");
                    if (isNumeric(fixedStr)) {
                        jpg_front_size = Integer.parseInt(fixedStr);
                    }
                }

                // jpg_shownumber_true;
                if (param.startsWith("jpg_shownumber_")) {
                    String fixedStr = param.replace("jpg_shownumber_", "").toLowerCase().trim();
                    if ("true".endsWith(fixedStr) || "false".equals(fixedStr)) {
                        isShowNumber = Boolean.parseBoolean(fixedStr);
                    }
                }

                // // jpg_wxh_255_500
                if (param.startsWith("jpg_wxh_")) {
                    String fixedStr = param.replace("jpg_wxh_", "");
                    if (fixedStr.contains("_")) {
                        String[] rectArr = fixedStr.split("_");
                        if (rectArr != null && rectArr.length == 2) {

                            if (isNumeric(rectArr[0])) {
                                jpg_width = Integer.parseInt(rectArr[0]);
                            }

                            if (isNumeric(rectArr[1])) {
                                jpg_hight = Integer.parseInt(rectArr[1]);
                            }

                        }
                    }
                }

                if (param.startsWith("jpg_wordcolor_")) {
                    String fixedStr = param.replace("jpg_wordcolor_", "");
                    if (fixedStr.contains("_")) {
                        String[] colorArr = fixedStr.split("_");
                        if (colorArr != null && colorArr.length == 3) {

                            if (isNumeric(colorArr[0])) {
                                jpg_R = Integer.parseInt(colorArr[0]);
                            }

                            if (isNumeric(colorArr[1])) {
                                jpg_G = Integer.parseInt(colorArr[1]);
                            }

                            if (isNumeric(colorArr[2])) {
                                jpg_B = Integer.parseInt(colorArr[2]);
                            }
                        }
                    }
                }

                // jpg_background_255_255_255
                if (param.startsWith("jpg_background_")) {
                    String fixedStr = param.replace("jpg_background_", "");
                    if (fixedStr.contains("_")) {
                        String[] backcolorArr = fixedStr.split("_");
                        if (backcolorArr != null && backcolorArr.length == 3) {

                            if (isNumeric(backcolorArr[0])) {
                                jpg_Back_R = Integer.parseInt(backcolorArr[0]);
                            }

                            if (isNumeric(backcolorArr[1])) {
                                jpg_Back_G = Integer.parseInt(backcolorArr[1]);
                            }

                            if (isNumeric(backcolorArr[2])) {
                                jpg_Back_B = Integer.parseInt(backcolorArr[2]);
                            }
                        }
                    }
                }

            }
            if (fileCount == 0) {
                System.out.println("当前没有创建文件的个数  默认设置为 1 ");
                fileCount = 1;
            }

            if (fliterTypeList.size() == 0) {
                System.out.println("当前没有需要创建的文件类型 .xx   请检查输入参数!");
                return false;
            }
            // TODO Auto-generated method stub
            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            // TODO Auto-generated method stub

            for (int i = 0; i < fliterTypeList.size(); i++) {
                String type = fliterTypeList.get(i);
                ArrayList<File> mTypeFileList = getTypeFileListRule31(curDirFile.getAbsolutePath(), type, fileCount);
                tryDoFillFile(mTypeFileList, type);

            }

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        void tryDoFillFile(ArrayList<File> curFile, String pointtype) {
            File curTempFile = null;
            String type = pointtype.replace(".", "");

//	    	        Readers: [JPG, jpg, tiff, pcx, PCX, bmp, BMP, gif, GIF, WBMP, png, PNG, raw, RAW, JPEG, pnm, PNM, tif, TIF, TIFF, wbmp, jpeg]
//	    	        Writers: [JPG, jpg, tiff, bmp, BMP, pcx, PCX, gif, GIF, WBMP, png, PNG, raw, RAW, JPEG, pnm, PNM, tif, TIF, TIFF, wbmp, jpeg]
            if ("jpg".equals(type) || "png".equals(type) || "jpeg".equals(type) || "bmp".equals(type)
                    || "gif".equals(type)) { // 动态创建文件 文件的内容是数值
                // 不支持的格式 || "wbmp".equals(type) || "raw".equals(type)
                generalPicture(curFile, type);

            } else if ("wbmp".equals(type) || "raw".equals(type)) { // 不能通过 ImageIO 来创建的图片格式 wbmp raw

                // 待定
            } else if (isSupportType(type)) { // 从 G2 目录读取模板 然后输入输出 完成文件的创建
                File typeFile = getCurrentTemplateTypeFile(type);
                generalTemplateFile(curFile, type, typeFile);
            } else { // 其他格式 创建空的 后缀文件
                generalTemplateEmptyFile(curFile, type);
            }

        }

        void generalTemplateEmptyFile(ArrayList<File> picFileList, String pointtype) {
            String type = pointtype.replace(".", "");
            for (int i = 0; i < picFileList.size(); i++) {
                File curFile = picFileList.get(i);
                try {
                    curFile.createNewFile();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }

        }

        void generalTemplateFile(ArrayList<File> picFileList, String type, File templateFile) {
            if (templateFile == null) {
                return;
            }
            for (int i = 0; i < picFileList.size(); i++) {
                int mCurIndex = i;
                File mCurFile = picFileList.get(i);
                fileCopy(templateFile, mCurFile);
            }

        }

        File getCurrentTemplateTypeFile(String pointtype) {
            String type = pointtype.replace(".", "");
            String curType = type.toLowerCase(); // zbin/E5/txt/txt.txt
            File typeFile = new File(
                    getG2ZbinDirPath() + File.separator + curType + File.separator + curType + "." + curType);
            if (!typeFile.exists()) {
                System.out.println("当前类型文件:  type:" + type + " 模板文件缺失无法批量创建文件 请创建模板！ 执行失败！");
                return null;
            }
            return typeFile;
        }

        String getG2ZbinDirPath() {
            String path = System.getProperties().getProperty("user.home") + File.separator + "Desktop" + File.separator
                    + "zbin" + File.separator + "G2";
            return path;
        }

        void generalPicture(ArrayList<File> picFileList, String pointtype) {

            showParams();
            String type = pointtype.replace(".", "");
            for (int i = 0; i < picFileList.size(); i++) {
                int mCurIndex = i;
                File mCurFile = picFileList.get(i);
                int width = jpg_width;
                int heigh = jpg_width;
                BufferedImage bi = new BufferedImage(width, heigh, BufferedImage.TYPE_INT_RGB);// INT精确度达到一定,RGB三原色，高度70,宽度150
                // 得到它的绘制环境(这张图片的笔)
                Graphics2D g2 = (Graphics2D) bi.getGraphics();
                g2.fillRect(0, 0, jpg_width, jpg_width);// 填充一个矩形 左上角坐标(0,0),宽500,高500;填充整张图片
                g2.setColor(new Color(jpg_Back_R, jpg_Back_G, jpg_Back_B));// 设置颜色
                g2.fillRect(0, 0, width, heigh);// 填充整张图片(其实就是设置背景颜色)
                int frontSize = jpg_front_size;
                int centerx = jpg_width / 2;
                int centery = jpg_hight / 2;
                int showIndex = i + 1;
                g2.setColor(new Color(jpg_R, jpg_G, jpg_B));
                Font f = new Font("宋体", Font.BOLD, frontSize);
                g2.setFont(f); // 设置字体:字体、字号、大小
                FontRenderContext context = g2.getFontRenderContext();
                Rectangle2D bounds = f.getStringBounds(showIndex + "", context);
                if (isShowNumber) {
                    g2.drawString(showIndex + "", (float) (centerx - bounds.getCenterX()),
                            (float) (centery - bounds.getCenterY())); // 向图片上写字符串
                }
                try {
                    mCurFile.createNewFile();
                    ImageIO.write(bi, "jpg", new FileOutputStream(mCurFile));// 保存图片 JPEG表示保存格式
                    System.out.println("创建文件[" + i + "]  = " + mCurFile.getAbsolutePath() + "成功");
                } catch (Exception e) {
                    System.out.println("复制图片格式出现异常！");
                }

            }
            showParams();

        }

        public ArrayList<File> getTypeFileListRule31(String dirAbsPath, String typeName, int fileCount) {
            ArrayList<File> curFileList = new ArrayList<File>();
            String typeNameNoPoint = typeName.replace(".", "");

            SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd_HHmmss");// 设置日期格式
            String date = df.format(new Date());// new Date()为获取当前系统时间，也可使用当前时间戳
            String typeDir = dirAbsPath + File.separator + typeNameNoPoint + "_" + date;
            File typeDirFile = new File(typeDir);
            typeDirFile.mkdirs();
            for (int i = 1; i < fileCount + 1; i++) {
                String itemFileStr = typeDirFile.getAbsolutePath() + File.separator + i + "." + typeNameNoPoint;
                File itemFile = new File(itemFileStr);
                curFileList.add(itemFile);
            }
            return curFileList;

        }

        boolean isSupportType(String type) {
            boolean flag = false;
            if ("jpg".equals(type) || "jpeg".equals(type) || "bmp".equals(type) || "png".equals(type)
                    || "wbmp".equals(type) || "gif".equals(type) || ("txt".equals(type)) || ("md".equals(type))
                    || ("java".equals(type)) || ("cpp".equals(type)) || ("c".equals(type)) || ("xml".equals(type))
                    || ("json".equals(type)) || ("bat".equals(type)) || ("sh".equals(type)) || ("zip".equals(type))
                    || ("rar".equals(type)) || ("xlsx".equals(type)) || ("xls".equals(type)) || ("html".equals(type))
                    || ("db".equals(type)) || ("js".equals(type)) || ("dll".equals(type)) || ("exe".equals(type))
                    || ("gitignore".equals(type)) || ("h".equals(type)) || ("jar".equals(type)) || ("py".equals(type))
                    || ("pkt".equals(type)) || ("7z".equals(type)) || ("pdf".equals(type)) || ("doc".equals(type))
                    || ("apk".equals(type)) || ("pcapng".equals(type)) || ("conf".equals(type))
                    || ("properties".equals(type)) || ("prop".equals(type)) || ("css".equals(type))
                    || ("so".equals(type)) || ("bin".equals(type)) || ("raw".equals(type)) || ("ppt".equals(type))
                    || ("pptx".equals(type)) || ("docx".equals(type))

            ) {
                flag = true;
            }

            return flag;

        }

    }

    // 对文件的名称进行修改
    class FileRenameOperation_Rule_30 extends Basic_Rule {

        String firstParamStr; // 第一个参数

        int DIR_OPERA_TYPE_APPEND = 1; // 后缀增加
        String appendStr_1;
        int DIR_OPERA_TYPE_PREFIX = 2; // 前缀增加
        String prefixStr_2;

        int DIR_OPERA_TYPE_CREATE = 3; // 创建文件
        int beginIndex_3;
        int endIndex_3;
        String prefixStr_3;
        String appendStr_3;

        int DIR_OPERA_TYPE_REPLACE = 4; // 替换文件夹名称
        String replacedStr_4;
        String newNameStr_4;

        // 识别当前用户 指定的操作类型 1后缀增加 2前缀增加 3创建文件 4替换文件夹名称
        int currentOperaType = 0;

        ArrayList<String> fliterTypeList;

        FileRenameOperation_Rule_30() {
            super("#", 30, 4);
            prefixStr_3 = "";
            appendStr_3 = "";
            fliterTypeList = new ArrayList<String>();
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            boolean falg = true;

            for (int i = 0; i < inputParamList.size(); i++) {
                String inputTypeItem = inputParamList.get(i).trim();
                if (inputTypeItem.startsWith(".")) {
                    fliterTypeList.add(inputTypeItem);

                }
            }
            if (currentOperaType == 1) {
                appendStr_1 = inputParamList.get(inputParamList.size() - 1);
            } else if (currentOperaType == 2) {
                prefixStr_2 = inputParamList.get(inputParamList.size() - 1);
            } else if (currentOperaType == 4) {
                String inputStr = inputParamList.get(inputParamList.size() - 1);
                if (!inputStr.contains("_")) {
                    falg = false;
                }

                if (inputStr.endsWith("_")) {

                    replacedStr_4 = inputStr.substring(0, inputStr.length() - 1);
                    newNameStr_4 = "";

                } else {
                    String[] inputArr = inputStr.split("_");
                    // item__

                    if (inputArr.length >= 2) {

                        replacedStr_4 = inputArr[0];
                        newNameStr_4 = inputArr[inputArr.length - 1];
                    } else {
                        falg = false;
                    }

                }

            } else if (currentOperaType == 3) {

                for (int i = 0; i < inputParamList.size(); i++) {

                    String paramItem = inputParamList.get(i);
                    if (paramItem != null && paramItem.equals(firstParamStr)) {
                        continue; // 第一个参数不操作
                    }

                    if (!paramItem.contains("_")) {
                        falg = false;
                        continue;
                    }
                    String fixedParam = paramItem.replace("_", "");

                    if (isNumeric(fixedParam)) { // 如果是 字母 说明是起始的那个参数
                        String[] IndexArr = paramItem.split("_");

                        if (IndexArr.length >= 2) {

                            String beginIndex_3_Str = IndexArr[0];
                            String endIndex_3_Str = IndexArr[IndexArr.length - 1];
                            if (isNumeric(beginIndex_3_Str)) {
                                beginIndex_3 = Integer.parseInt(beginIndex_3_Str);

                            } else {
                                falg = false;
                            }

                            if (isNumeric(endIndex_3_Str)) {
                                endIndex_3 = Integer.parseInt(endIndex_3_Str);
                            } else {
                                falg = false;
                            }

                        } else {
                            falg = false;
                        }
                    } else { // 名称的参数
                        if (paramItem.endsWith("_")) {
                            appendStr_3 = "";
                            String[] NamePreArr = paramItem.split("_");
                            prefixStr_3 = NamePreArr[0];
                            System.out.println("appendStr_3=" + appendStr_3 + "   prefixStr_3=" + prefixStr_3);

                        } else {
                            String[] NamePreArr = paramItem.split("_");
                            if (NamePreArr.length >= 2) {
                                prefixStr_3 = NamePreArr[0];
                                appendStr_3 = NamePreArr[1];
                                System.out.println("appendStr_3=" + appendStr_3 + "   prefixStr_3=" + prefixStr_3);

                            }

                        }

                    }

                }

            }

            return super.initParamsWithInputList(inputParamList) || falg;
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
// 	// 识别当前用户 指定的操作类型 1后缀增加 2前缀增加 3创建文件 4替换文件夹名称

            ArrayList<File> slectedFileList = getRealFileWithDirAndPointType(curDirFile, fliterTypeList);

            System.out.println("Rule30 修改文件  currentOperaType = " + currentOperaType + "   ");

            switch (currentOperaType) {

                case 1:
                    for (int i = 0; i < slectedFileList.size(); i++) {
                        File selectFile = slectedFileList.get(i);
                        String selectFileName = selectFile.getName();
                        String pointType = getFileTypeWithPoint(selectFileName);
                        String FileNameWithNoLower = getFileNameNoPoint(selectFileName);
                        String newselectFileName = FileNameWithNoLower + appendStr_1 + pointType;
                        tryReName(selectFile, newselectFileName);
                    }
                    break;

                case 2:
                    for (int i = 0; i < slectedFileList.size(); i++) {
                        File selectFile = slectedFileList.get(i);
                        String selectFileName = selectFile.getName();
                        String newselectFileName = prefixStr_2 + selectFileName;
                        tryReName(selectFile, newselectFileName);
                    }
                    break;

                case 3:
                    System.out.println("beginIndex_3 = " + beginIndex_3 + "   endIndex_3=" + endIndex_3);
                    for (int j = 0; j < fliterTypeList.size(); j++) {
                        String typeStr = fliterTypeList.get(j);
                        for (int i = beginIndex_3; i < endIndex_3 + 1; i++) {
                            String absDirPath = curDirFile.getAbsolutePath();

                            String selectFilePath = absDirPath + File.separator + prefixStr_3 + i + appendStr_3 + typeStr;
                            File curFileItem = new File(selectFilePath);
                            System.out.println("创建空 " + typeStr + " 文件 [" + i + "] = " + curFileItem.getName());
                            try {
                                curFileItem.createNewFile();
                            } catch (IOException e) {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                            }
                        }

                    }

                    break;

                // 4替换文件夹名称
                case 4:
                    System.out.println("replacedStr_4 = " + replacedStr_4 + "   newNameStr_4=" + newNameStr_4);

                    for (int i = 0; i < slectedFileList.size(); i++) {
                        File realFile = slectedFileList.get(i);
                        String realFileName = realFile.getName();

                        String newRealName = realFileName.replace(replacedStr_4, newNameStr_4 == null ? "" : newNameStr_4);
                        tryReName(realFile, newRealName);
                    }

                    break;

                default:
                    System.out.println("当前 currentOperaType = " + currentOperaType + "  没有找到合适的操作类型去处理 Rule30 ");
            }

            return curDirList;
        }

        @Override
        boolean initParams4InputParam(String inputParam) {

            firstParamStr = inputParam;
            if (inputParam.contains("append")) {
                currentOperaType = 1;
            } else if (inputParam.contains("prefix")) {
                currentOperaType = 2;

            } else if (inputParam.contains("replace")) {
                currentOperaType = 4;

            } else if (inputParam.contains("create")) {
                currentOperaType = 3;

            }

            return super.initParams4InputParam(inputParam);
        }

        @Override
        String simpleDesc() {
            return "只对文件的文件名进行操作" + "\n" + Cur_Bat_Name + "  #_30_append  _over   ###往当前文件夹后缀增加 _over \n" + Cur_Bat_Name
                    + "  #_30_append .jpg  _over   ###往当前所有文件前缀增加 xx_over.png \n" + Cur_Bat_Name
                    + "  #_30_prefix  temp   ###往当前所有文件前缀增加 temp \n" + Cur_Bat_Name
                    + "  #_30_prefix .jpg temp   ###往当前所有png文件前缀增加 temp tempxxx.png \n" + Cur_Bat_Name
                    + " #_30_create .jpg 1_100   ###创建一个序列号从1.jpg到100.jpg的100个文件   \n" + Cur_Bat_Name
                    + " #_30_create  .pptx   temp_  1_100   ###创建一个序列号从temp1.pptx到temp100.pptx的100个文件 \n" + Cur_Bat_Name
                    + " #_30_create .doc .jpg  _temp  1_100   ###创建一个序列号从1temp.doc到100temp.doc 1temp.jpg到100temp.jpg 的100个文件 \n"
                    + Cur_Bat_Name
                    + " #_30_create .jpg  j_temp  1_100   ###创建一个序列号从 j_1_temp.jpg 到100temp的 j_100_temp.jpg 的文件 \n"
                    + Cur_Bat_Name + " #_30_create .jpg   7000_7100  ###创建一个序列号从7000.png开始的到7100.png结束的文件  \n"
                    + Cur_Bat_Name + " #_30_replace  abc_DEF  ###把当前文件名称中的  abc 转为 DEF \n" + Cur_Bat_Name
                    + " #_30_replace .jpg .png abc_DEF  ###把当前文件夹下的.jpg .png 名称中的  abc 转为 DEF \n";
        }

    }

    class mergeSomePPTXAsOne_Rule_29 extends Basic_Rule { // 把 当前 目录的 多个 pptx 合并成 一个 pptx 文件
        boolean isDeteleOrigin = false; // 是否把原pptx文件删除

        mergeSomePPTXAsOne_Rule_29() {
            super("#", 29, 4);
            isDeteleOrigin = false;
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

//			param0[#_28]
//			param1[name_90]

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramStr = inputParamList.get(i);
                String paramStr_lower_trim = paramStr.toLowerCase().trim();
                System.out.println("param" + i + "[" + paramStr + "] ");

                if (paramStr_lower_trim.startsWith("delete")) {
                    isDeteleOrigin = true;

                }
            }

            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            ArrayList<File> pptxFileList = new ArrayList<File>();
            int pptx_index = 1;
            for (int i = 0; i < curRealFileList.size(); i++) {
                File curFile = curRealFileList.get(i);
                String currentFileName = curFile.getName().toLowerCase();
                if (currentFileName.endsWith(".pptx") || currentFileName.endsWith(".ppt")) {
                    pptxFileList.add(curFile);
                    System.out.println("pptx_index[" + pptx_index + "] = " + curFile.getAbsolutePath());
                    pptx_index++;
                }

            }

            if (pptxFileList.size() == 0) {
                System.out.println("当前目录就没有  pptx文件 请检查! PATH = " + curDirPath);
                return null;
            }

            if (pptxFileList.size() == 1) {
                System.out.println("当前目录只有1个  pptx文件  无需合并pptx操作! PATH = " + curDirPath);
                return null;
            }

            if (pptxFileList.size() > 1) {
                try {
                    XMLSlideShow ppt = new XMLSlideShow();
                    for (int i = 0; i < pptxFileList.size(); i++) {
                        File pptxFileItem = pptxFileList.get(i);
                        FileInputStream inputstream;

                        inputstream = new FileInputStream(pptxFileItem);

                        XMLSlideShow src;

                        src = new XMLSlideShow(inputstream);
                        int currentWidth = src.getPageSize().width;
                        int currentHeight = src.getPageSize().height;
                        ppt.setPageSize(new Dimension(currentWidth, currentHeight));
//				        System.out.println("currentWidth = "+currentWidth+"    currentHeight="+currentHeight);

                        for (XSLFSlide srcSlide : src.getSlides()) {
                            ppt.createSlide().importContent(srcSlide);

                        }
                    }

                    String result_pptx = curDirPath + File.separator + "Z_PPTX_Merge" + pptxFileList.size() + "_"
                            + getTimeStamp() + ".pptx";
                    File resultPPTX_File = new File(result_pptx);
                    // creating the file object
                    FileOutputStream out = new FileOutputStream(resultPPTX_File);

                    // saving the changes to a file
                    ppt.write(out);
                    System.out.println("Merging done successfully");
                    out.close();

                    if (resultPPTX_File.exists() && resultPPTX_File.length() > 100 && isDeteleOrigin) {
                        for (int i = 0; i < pptxFileList.size(); i++) {
                            File pptxFileItem = pptxFileList.get(i);
                            System.out.println("删除原始 pptx_" + i + "=[" + pptxFileItem.getAbsolutePath() + "]");

                            pptxFileItem.delete();
                        }

                    }
                } catch (Exception e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                    System.out.println("当前程序出现异常！！ Rule29 合并多 pdf操作 ");
                }

            }

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name + "  #_29     ## 把当前目录下的 pptx文件合并为一个 pptx文件  【保留原有】的pptx文件 \n" + Cur_Bat_Name
                    + " #_29  delete  ##把当前目录下的 pptx文件合并为一个 pptx文件  【删除原有】的pptx文件 \n"

                    ;
        }

    }

    // 把当前的 图片 文件 jpg png 等 转为 一个 PPTX 文件 方便 分享 查看
    class makeJpg2PPTX_Rule_28 extends Basic_Rule {
        // 把文件后缀中的中文给去除掉 不包含文件夹 不包含孙文件

        File TemplatePPTX_File;
        int begin_index; // 由于 免费版本的 Presentation 最大创建 pptx页面为 10页 所以 才出现这些属性 尼玛
        int end_index; // 由于 免费版本的 Presentation 最大创建 pptx页面为 10页 所以 才出现这些属性 尼玛

        boolean isShowName;
        int rotate_value; // 旋转的角度
        boolean bigkeep; // 那些 与 电脑尺寸相同的 照片 保持正向的 比例

        ArrayList<String> mInputParamList; // 记录当前的所有输入的参数
        
        boolean drawname ;  //  在 图片的开头  打印出当前图片的名字

        makeJpg2PPTX_Rule_28() {
            super("#", 28, 4);
            TemplatePPTX_File = new File(zbinPath + File.separator + "G2_EmptyPPTX_Rule28.pptx");
            rotate_value = 0;
            isShowName = false;
            bigkeep = false;
            begin_index = 0;
            end_index = 0;
            mInputParamList = new ArrayList<String>();
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

//				param0[#_28]
//				param1[name_90]
            mInputParamList.addAll(inputParamList);

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramStr = inputParamList.get(i);
                System.out.println("param" + i + "[" + paramStr + "] ");
                if (paramStr.toLowerCase().contains("name")) {
                    isShowName = true;
                }
                if (paramStr.toLowerCase().contains("keepbig")) {
                    bigkeep = true;
                }
                
                
                if (paramStr.toLowerCase().contains("drawname_true")) {
                	drawname = true;
                }
                

                if (paramStr.contains("_") && isNumeric(paramStr.replace("_", "").trim())) {
                    String[] indesArr = paramStr.split("_");
                    if (indesArr != null && indesArr.length == 2) {
                        if (isNumeric(indesArr[0])) {
                            begin_index = Integer.parseInt(indesArr[0]);
                        }

                        if (isNumeric(indesArr[1])) {
                            end_index = Integer.parseInt(indesArr[1]);
                        }

                    }

                }

                if (paramStr != null && isNumeric(paramStr.trim())) {

                    rotate_value = Integer.parseInt(paramStr.trim());
                }
            }
            /*
             * String lastParams = inputParamList.get(inputParamList.size()-1);
             * if(lastParams != null && !lastParams.startsWith("#") &&
             * lastParams.contains("_")) { String[] arrStr = lastParams.split("_");
             * if(arrStr != null && arrStr.length > 0) { String lastNumStr =
             * arrStr[arrStr.length-1]; if(isNumeric(lastNumStr)) { rotate_value =
             * Integer.parseInt(lastNumStr); } }
             *
             * }else
             */

            System.out.println("isShowName=" + isShowName + "   rotate_value=" + rotate_value + " drawname:"+ drawname);
            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            System.out.println("makeJpg2PPTX_Rule_28   搜索到的实体文件个数:" + curRealFileList.size());

            ArrayList<File> pictureFileList = new ArrayList<File>();
            int picture_index = 1;
            for (int i = 0; i < curRealFileList.size(); i++) {
                File curFile = curRealFileList.get(i);
                String currentFileName = curFile.getName().toLowerCase();
                if (currentFileName.endsWith(".jpg") || currentFileName.endsWith(".png")) {
                    pictureFileList.add(curFile);
                    System.out.println("picture_index[" + picture_index + "] = " + curFile.getAbsolutePath());
                    picture_index++;
                }

            }

            if (pictureFileList.size() > 0) {
                Presentation ppt = new Presentation();
                File tempPPTXFile = null;
                try {
                    tempPPTXFile = new File(TemplatePPTX_File.getAbsolutePath());
                    if (!tempPPTXFile.exists()) {
                        System.out.println(" 当前 PPTX的模板文件不存在 PATH = " + tempPPTXFile.getAbsolutePath());
                        tempPPTXFile.createNewFile();
                    }

                    ppt.loadFromFile(tempPPTXFile.getAbsolutePath());

                    Rectangle2D rect_fullSize = new Rectangle2D.Double(0, 0, ppt.getSlideSize().getSize().getWidth(),
                            ppt.getSlideSize().getSize().getHeight());
                    double PPT_Width = rect_fullSize.getWidth();
                    double PPT_Height = rect_fullSize.getHeight();

                    System.out.println("PPT_Width = " + PPT_Width + "   PPT_Height=" + PPT_Height);
                    ISlide slide = ppt.getSlides().get(0);

                    //
                    if (begin_index == 0 && end_index == 0 && pictureFileList.size() > 10) {
                        // 通过长度 计算 以及 输入 参数 inputParamList 动态计算 全部解析的命令
                        // buildCommandWIth(pictureFileList.size()，inputParamList)
                        System.out.println("当前目录图片文件大于10 个 !! 需要动态 动态创建 pptx 文件 请执行如下文件");
                        buildDynamic(pictureFileList.size(), mInputParamList);

                        return null;
                    }
                    System.out.println("begin_index = " + begin_index + "   end_index=" + end_index);

                    SortFileWithName(pictureFileList);
                    for (int i = 0; i < pictureFileList.size(); i++) {
                        System.out.println("Format_Index[" + i + "] = " + pictureFileList.get(i).getAbsolutePath());
                    }

                    for (int i = 0; i < pictureFileList.size(); i++) {
                        if (pictureFileList.size() > 10) {
                            if (i < begin_index) {
                                continue;
                            } else if (i > end_index) {
                                continue;
                            }
                        }

                        System.out.println("For_Index_i=" + i);
                        File imageFile = pictureFileList.get(i);
                        String FileName = imageFile.getName();
                        String fileNameNoPoint = getFileNameNoPoint(FileName);
                        Image img = ImageIO.read(imageFile); // 构造Image对象
                        int picture_width = img.getWidth(null);
                        int picture_height = img.getHeight(null);
                        if (picture_width >= picture_height) {
                            // 横屏的情况 使用全覆盖
                            System.out.println("fullSize(0,0," + PPT_Width + "," + PPT_Height + ") -> "
                                    + "PictureIndex[" + (i + 1) + "]   " + " picture_width=[" + picture_width
                                    + "]  picture_height=[" + picture_height + "]  " + "PPT_Width =[" + PPT_Width
                                    + "]   PPT_Height=[" + PPT_Height + "]");

                            BufferedImage buffImage = rotate(img, bigkeep == true ? 0 : rotate_value);

                            ByteArrayOutputStream bs = new ByteArrayOutputStream();
                            ImageOutputStream imOut = ImageIO.createImageOutputStream(bs);
                            ImageIO.write(buffImage, "jpg", imOut);
                            InputStream ImageInputStream = new ByteArrayInputStream(bs.toByteArray());

                            IEmbedImage image = slide.getShapes().appendEmbedImage(ShapeType.RECTANGLE,
                                    ImageInputStream, rect_fullSize);
                            image.getLine().setFillType(FillFormatType.PICTURE);

                            // 获取第一张幻灯片，添加指定大小和位置的矩形文本框

                            if (isShowName) {
                                System.out.println("i-begin_index = " + (i - begin_index));
                                IAutoShape shape = ppt.getSlides().get(i - begin_index).getShapes().appendShape(
                                        ShapeType.RECTANGLE,
                                        new Rectangle((int) (PPT_Width / 2 - PPT_Width / 2), 0, (int) PPT_Width, 50));

                                // 设置shape样式
                                shape.getFill().setFillType(FillFormatType.NONE);
                                shape.getShapeStyle().getLineColor().setColor(Color.red);
//						        shape.setRotation(-45);
                                shape.getLocking().setSelectionProtection(true);
                                shape.getLine().setFillType(FillFormatType.NONE);

                                // 添加文本到shape
                                shape.getTextFrame().setText(fileNameNoPoint);
                                PortionEx textRange = shape.getTextFrame().getTextRange();

                                // 设置文本水印样式
                                textRange.getFill().setFillType(FillFormatType.SOLID);
                                textRange.getFill().getSolidColor().setColor(Color.red);
                                textRange.setFontHeight(50);
                                System.out.println(" fileNameNoPoint = " + fileNameNoPoint);

                            }

                        } else {

                            BufferedImage buffImage = rotate(img, rotate_value);
                            System.out.println("rotate90(0,0," + PPT_Width + "," + PPT_Height + ") -> "
                                    + "PictureIndex[" + (i + 1) + "]   " + " picture_width=[" + picture_width
                                    + "]  picture_height=[" + picture_height + "]  " + " rotate_width=["
                                    + buffImage.getWidth() + "]  rotate_height=[" + buffImage.getHeight() + "]  "
                                    + "PPT_Width =[" + PPT_Width + "]   PPT_Height=[" + PPT_Height + "]");

                            ByteArrayOutputStream bs = new ByteArrayOutputStream();
                            ImageOutputStream imOut = ImageIO.createImageOutputStream(bs);
                            ImageIO.write(buffImage, "jpg", imOut);
                            InputStream ImageInputStream = new ByteArrayInputStream(bs.toByteArray());

                            // 方式1 竖屏的情况 保持比例 宽 小于 长 // 从 原有的 高 变为 最高的情况
                            // 把 图片旋转 90 ° 再 全尺寸加入
                            int picture_height_fixed = (int) PPT_Height;
                            int picture_width_fixed = (int) (picture_width * (PPT_Height / picture_height));
                            Rectangle2D selected_rect = null;
                            if (rotate_value == 0 || rotate_value == 180) {
                                selected_rect = new Rectangle2D.Double(PPT_Width / 2 - picture_width_fixed / 2, 0,
                                        picture_width_fixed, picture_height_fixed);

                            } else {

                                selected_rect = rect_fullSize;
                            }

                            System.out.println("selectedSize(" + (PPT_Width / 2 - picture_width_fixed / 2) + ",0,"
                                    + picture_width_fixed + "," + picture_height_fixed + ") -> " + "PictureIndex["
                                    + (i + 1) + "]   " + " picture_width=[" + picture_width + "]  picture_height=["
                                    + picture_height + "]  " + "PPT_Width =[" + PPT_Width + "]   PPT_Height=["
                                    + PPT_Height + "]");

                            IEmbedImage image = slide.getShapes().appendEmbedImage(ShapeType.RECTANGLE,
                                    ImageInputStream, selected_rect);
                            image.getLine().setFillType(FillFormatType.PICTURE);

                            /*
                             * // 方式2 IEmbedImage image =
                             * slide.getShapes().appendEmbedImage(ShapeType.RECTANGLE,
                             * ImageInputStream,rect_fullSize);
                             * image.getLine().setFillType(FillFormatType.PICTURE);
                             */

                            if (isShowName) {

                                IAutoShape shape = ppt.getSlides().get(i - begin_index).getShapes().appendShape(
                                        ShapeType.RECTANGLE,
                                        new Rectangle((int) (PPT_Width / 2 - PPT_Width / 2), 0, (int) PPT_Width, 50));

                                // 设置shape样式
                                shape.getFill().setFillType(FillFormatType.NONE);
                                shape.getShapeStyle().getLineColor().setColor(Color.red);
//						        shape.setRotation(-45);
                                shape.getLocking().setSelectionProtection(true);
                                shape.getLine().setFillType(FillFormatType.NONE);

                                // 添加文本到shape
                                shape.getTextFrame().setText(fileNameNoPoint);
                                PortionEx textRange = shape.getTextFrame().getTextRange();

                                // 设置文本水印样式
                                textRange.getFill().setFillType(FillFormatType.SOLID);
                                textRange.getFill().getSolidColor().setColor(Color.red);
                                textRange.setFontHeight(50);
                                System.out.println(" fileNameNoPoint = " + fileNameNoPoint);

                            }

                        }

                        if (i == 0) {
                            slide = ppt.getSlides().append();
                            System.out.println("AA for 1 ppt.getSlides().size() = " + ppt.getSlides().size());
                            continue;
                        }
                        if (i != pictureFileList.size() - 1 && i != end_index) {
                            slide = ppt.getSlides().append();
                            System.out.println("AA ppt.getSlides().size() = " + ppt.getSlides().size());

                        }
                        System.out.println("BB ppt.getSlides().size() = " + ppt.getSlides().size());

                    }
                    String local_pptx_path = curDirPath + File.separator + "PPTX_" + getTimeStamp() + ".pptx";
                    ppt.saveToFile(local_pptx_path, FileFormat.PPTX_2013);

                    System.out.println("当前目录所有图片的 PPTX 文件以及生成!  PATH = " + local_pptx_path);
                } catch (Exception e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }
            } else {
                System.out.println("当前目录下 " + curDirPath + " 不存在 jpg 和 png 照片 无法合成 pptx文件!");
            }

            return curRealFileList;
        }

        void buildDynamic(int size, ArrayList<String> params) {
            System.out.println("═══════════════════════════════════" + "动态命令" + "═══════════════════════════════════");
            int forCount = (int) (size / 10) + 1; //

            StringBuilder allCommandSB = new StringBuilder();
            for (int i = 0; i < forCount; i++) {
                ArrayList<String> commandList = new ArrayList<String>();
                StringBuilder tempSB = new StringBuilder();
                commandList.add(Cur_Bat_Name);
                commandList.addAll(params);

                int begin_index = i * 10;
                int end_index = i * 10 + 9;
                if (end_index > size) {
                    end_index = size - 1;
                }

                if (begin_index > end_index) {
                    continue;
                }
                String order_str = begin_index + "_" + end_index;

                commandList.add(" " + order_str + "");

                for (int j = 0; j < commandList.size(); j++) {
                    String itemStr = commandList.get(j);
                    tempSB.append(itemStr + "  ");
                }

                if (i != forCount - 1) {
                    tempSB.append("  &&  ");
                }

                allCommandSB.append(tempSB.toString());

            }
            if (allCommandSB.toString().trim().endsWith("&&")) {
                System.out.println(allCommandSB + "   " + Cur_Bat_Name + "  #_29  delete");
            } else {
                System.out.println(allCommandSB + "  &&  " + Cur_Bat_Name + "  #_29  delete");
            }

        }

        @Override
        String simpleDesc() {
            return " // 把当前目录下文件 下的picture媒体文件 生成 PPTX文件   \n" + Cur_Bat_Name
                    + " #_28     [索引28]   // 把当前目录下文件 旋转0度 不显示文件名 下的picture媒体文件 生成 PPTX文件   \n" + Cur_Bat_Name
                    + " #_28 0     [索引28]   // 把当前目录下文件 下的picture媒体文件 旋转0度 生成 PPTX文件   \n" + Cur_Bat_Name
                    + " #_28 90     [索引28]   // 把当前目录下文件 下的picture媒体文件 旋转90度 生成 PPTX文件   \n" + Cur_Bat_Name
                    + " #_28 180     [索引28]   // 把当前目录下文件 下的picture媒体文件 旋转180度 生成 PPTX文件   \n" + Cur_Bat_Name
                    + " #_28 270     [索引28]   // 把当前目录下文件 下的picture媒体文件 并旋转270度 生成 PPTX文件   \n" + Cur_Bat_Name
                    + " #_28 name     [索引28]   // 把当前目录下文件 下的picture媒体文件 并添加文件名 生成 PPTX文件   \n" + Cur_Bat_Name
                    + " #_28 name 0     [索引28]   // 把当前目录下文件 下的picture媒体文件 旋转0度 并添加文件名 生成 PPTX文件   \n" + Cur_Bat_Name
                    + " #_28 name 90     [索引28]   // 把当前目录下文件 下的picture媒体文件 旋转90度 并添加文件名 生成 PPTX文件   \n" + Cur_Bat_Name
                    + " #_28 name 180     [索引28]   // 把当前目录下文件 下的picture媒体文件 旋转180度 并添加文件名 生成 PPTX文件   \n"
                    + Cur_Bat_Name
                    + " #_28 name 270     [索引28]   // 把当前目录下文件 下的picture媒体文件 旋转270度 并添加文件名 生成 PPTX文件   \n"
                    + Cur_Bat_Name
                    + " #_28 keepbig name 0     [索引28]   // 把当前目录下文件  图片比例与电脑尺寸相同(PC 宽>高)的保持正向 比例不同的(手机 宽<高) 旋转0度 并添加文件名 生成 PPTX文件   \n"
                    + Cur_Bat_Name
                    + " #_28 keepbig name 90     [索引28]   // 把当前目录下文件  图片比例与电脑尺寸相同(PC 宽>高)的保持正向 比例不同的(手机 宽<高) 旋转90度 并添加文件名 生成 PPTX文件   \n"
                    + Cur_Bat_Name
                    + " #_28 keepbig name 180     [索引28]   // 把当前目录下文件  图片比例与电脑尺寸相同(PC 宽>高)的保持正向 比例不同的(手机 宽<高) 旋转180度 并添加文件名 生成 PPTX文件   \n"
                    + Cur_Bat_Name
                    + " #_28 keepbig name 270     [索引28]   // 把当前目录下文件  图片比例与电脑尺寸相同(PC 宽>高)的保持正向 比例不同的(手机 宽<高) 旋转270度 并添加文件名 生成 PPTX文件   \n"

                    ;

        }
    }

    // 在 包含 mp4 文件夹名称 把 无类型的文件 改为 mp4 , 对应 gif jpg
    class Rercovery_Type_By_DirName_Rule_27 extends Basic_Rule {
        String originType;
        String targetType;

        Rercovery_Type_By_DirName_Rule_27() {
            super("#", 27, 5);
        }

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name + "  #_27  _jpg   把包含 jpg 文件夹名称中的无类型文件改为 jpg格式名称\n" + Cur_Bat_Name
                    + " #_27  _gif  把包含 gif 文件夹名称中的无类型文件改为 gif格式名称\n" + Cur_Bat_Name
                    + " #_27  _mp4  把包含 mp4 文件夹名称中的无类型文件改为 mp4格式名称\n";
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            boolean Flag = true;

            // 获取到装换的类型
            String inputFileTypeParams = inputParamList.get(inputParamList.size() - 1);

            if (!inputFileTypeParams.contains("_")) {
                Flag = false;
                System.out.println("无法检测到当前 第27 Rule   原始类型_目标类型参数   请检查后重新执行");
            } else {

                if (inputFileTypeParams.endsWith("_")) {
                    String target = "";
                    String[] parmas = inputFileTypeParams.split("_");
                    String origin = parmas[0];
                    System.out.println("item=" + inputFileTypeParams + "   origin=" + origin + "     target=" + target);
                    originType = origin;
                    targetType = target;

                } else {
                    String[] parmas = inputFileTypeParams.split("_");
                    System.out.println(
                            "item=" + inputFileTypeParams + "   origin=" + parmas[0] + "     target=" + parmas[1]);
                    originType = parmas[0];
                    targetType = parmas[1];
                }

                Flag = true;

            }
            curFilterFileTypeList.add(originType);

            return super.initParamsWithInputList(inputParamList) && Flag;
        }

        @Override
        ArrayList<File> applyDir_SubFileListRule5(ArrayList<File> allSubDirFileList,
                                                  ArrayList<File> allSubRealFileList) {

            for (int i = 0; i < allSubDirFileList.size(); i++) {
                File curDirFile = allSubDirFileList.get(i);
                String curDirName = curDirFile.getName();
                String curDirAbsPath = curDirFile.getAbsolutePath();
                // 如果当前文件夹 包含 过滤类型的名称 如 mp4 gif jpg 那么才往下走
//				System.out.println("A i["+i+"] curDirName=" + curDirName );
                if (!curDirName.contains(targetType) && !curDirAbsPath.toLowerCase().contains(targetType)) {
                    continue;
                }

                File[] listFile = curDirFile.listFiles();
//				System.out.println("B i["+i+"] curDirName=" + curDirName );
                if (listFile == null || listFile.length <= 0) {

                    continue;
                }

                // jpg_xxx_port/AI/aaaaaaaaaaaa.jpg
                // 1.当遍历 jpg_xxx_port 时发现 里面只有文件夹
                // 2. 当遍历 AI时发现 它又不是 包含jpg 的文件夹名名称 (完全路径 需要 包含 jpg)
                for (int j = 0; j < listFile.length; j++) {
                    File mRealFile = listFile[j];
                    if (mRealFile.isFile() && !mRealFile.isDirectory()) {
                        String realFileNmae = mRealFile.getName();
                        String type = getFileTypeWithPoint(realFileNmae);
                        System.out.println("j[" + j + "] realFileNmae=" + realFileNmae + "   type=" + type);
                        if ("".equals(type)) {
                            String newName = realFileNmae + "." + targetType;
                            tryReName(mRealFile, newName);
                        }

                    }
                }

            }

            return super.applyDir_SubFileListRule5(allSubDirFileList, allSubRealFileList);
        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {

            for (int i = 0; i < subFileList.size(); i++) {
                File curFIle = subFileList.get(i);
                String originName = curFIle.getName();
                // 执行 修改文件类型的操作

                // 1. 如果当前文件 过滤类型是 空 那么 可能就是没有任何的类型了
                // 如果当前过滤的类型是 originType 是"" 空的话 那么就会过滤出所有的文件 那么只操作 不包含.的那些文件
                if ("".equals(originType)) {
                    if (originName.contains(".")) {
                        continue; // 包含了 . 说明有类型 那么 不操作
                    }
                    String newName = originName + "." + targetType;
                    tryReName(curFIle, newName);
                } else {
                    // 有具体的 过滤的文件
                    String oldType = "." + originType;
                    String newType = "." + targetType;
                    if ("".equals(targetType)) {
                        newType = "";
                    }

                    if (originName.contains(oldType)) {
                        String newName = originName.replace(oldType, newType);
                        tryReName(curFIle, newName);
                    }

                }

            }

            return subFileList;
        }
    }

    // operation_type 操作类型 1--读取文件内容字符串 进行修改 2--对文件对文件内容(字节)--进行修改 3.对全体子文件进行的随性的操作
    // 属性进行修改(文件名称)
//     // 4.对当前子文件(包括子目录 子文件 --不包含孙目录 孙文件) 5. 从shell 中获取到的路径 去对某一个文件进行操作

    class Rename_By_Dir_Rule_26 extends Basic_Rule {

        ArrayList<String> inputTypeList;
        // zrule_apply_G2.bat #_26 jpg 把当前所有的jpg格式文件生在该文件夹下依次重命名

        // 可能从参数输入的 单一文件
        ArrayList<File> inputParamFileList; // .mp4 .jpg 对单独类型进行重命名

        boolean isSearchAllFile2CurDirFlag = false; // 是否检索 所有类型(空输入就是检索所有类型)

        Rename_By_Dir_Rule_26() {
            super("#", 26, 5);
            inputTypeList = new ArrayList<String>();
            inputParamFileList = new ArrayList<File>();
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {
                String strInput = inputParamList.get(i);
                if (strInput.equals(firstInputIndexStr)) {
                    continue;
                }
                if (!strInput.startsWith(".")) {
                    inputTypeList.add("." + strInput.trim());
                } else {
                    inputTypeList.add(strInput.trim());
                }

                File tempFile = new File(curDirPath + File.separator + strInput);
                if (tempFile.exists() && !tempFile.isDirectory()) {
                    inputParamFileList.add(tempFile);

                }
            }

            if (inputTypeList.size() == 0 && inputParamFileList.size() == 0) {
                isSearchAllFile2CurDirFlag = true;
            }
            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        ArrayList<File> applyDir_SubFileListRule5(ArrayList<File> allSubDirFileList,
                                                  ArrayList<File> allSubRealFileList) {
            if (isSearchAllFile2CurDirFlag) {
                // 比那里所有 类型的 文件 并 重新命名
                tryReNameByDir(allSubDirFileList);

            } else {
                tryReNameByDir_Type(allSubDirFileList, inputTypeList);
                /*
                 * for (int i = 0; i < inputTypeList.size(); i++) { String type =
                 * inputTypeList.get(i);
                 *
                 * ArrayList<File> targetFileList = fileTypeMap.get(type);
                 *
                 * if (targetFileList == null || targetFileList.size() == 0) {
                 * System.out.println(" 当前路径 " + curDirPath + " 不存在类型 " + type + "的文件!");
                 * continue; }
                 *
                 * for (int j = 0; j < targetFileList.size(); j++) { File targetTypeFile =
                 * targetFileList.get(j); String originName = targetTypeFile.getName(); String
                 * mdName = getMD5Three(targetTypeFile.getAbsolutePath()); String mdtype =
                 * getFileTypeWithPoint(targetTypeFile.getName()); String new_md_Name = mdName +
                 * mdtype; tryReName(targetTypeFile, new_md_Name);
                 *
                 * }
                 *
                 * }
                 *
                 * for (int i = 0; i < inputParamFileList.size(); i++) { File targetTypeFile =
                 * inputParamFileList.get(i); String originName = targetTypeFile.getName();
                 * String mdName = getMD5Three(targetTypeFile.getAbsolutePath()); String mdtype
                 * = getFileTypeWithPoint(targetTypeFile.getName()); String new_md_Name = mdName
                 * + mdtype; tryReName(targetTypeFile, new_md_Name); }
                 */

            }

            return super.applyDir_SubFileListRule5(allSubDirFileList, allSubRealFileList);
        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {

            SimpleDateFormat df = new SimpleDateFormat("MMdd_HHmmss");// 设置日期格式
//            SimpleDateFormat df_hms = new SimpleDateFormat("HHmmss");//设置日期格式
            Date curDate = new Date();
            String date = df.format(curDate);
//            String preHMS = df.format(df_hms);

            if (isSearchAllFile2CurDirFlag) {
                // 比那里所有 类型的 文件 并 重新命名
                tryReNameOperation(fileTypeMap);

            } else {

                for (int i = 0; i < inputTypeList.size(); i++) {
                    String type = inputTypeList.get(i);

                    ArrayList<File> targetFileList = fileTypeMap.get(type);

                    if (targetFileList == null || targetFileList.size() == 0) {
                        System.out.println(" 当前路径 " + curDirPath + " 不存在类型 " + type + "的文件!");
                        continue;
                    }

                    for (int j = 0; j < targetFileList.size(); j++) {
                        File targetTypeFile = targetFileList.get(j);
                        String originName = targetTypeFile.getName();
                        String mdName = getMD5Three(targetTypeFile.getAbsolutePath());
                        String mdtype = getFileTypeWithPoint(targetTypeFile.getName());
                        String new_md_Name = mdName + mdtype;
                        tryReName(targetTypeFile, new_md_Name);

                    }

                }

                for (int i = 0; i < inputParamFileList.size(); i++) {
                    File targetTypeFile = inputParamFileList.get(i);
                    String originName = targetTypeFile.getName();
                    String mdName = getMD5Three(targetTypeFile.getAbsolutePath());
                    String mdtype = getFileTypeWithPoint(targetTypeFile.getName());
                    String new_md_Name = mdName + mdtype;
                    tryReName(targetTypeFile, new_md_Name);
                }

            }

            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        void tryReNameByDir_Type(ArrayList<File> allDirFile, ArrayList<String> mInputTypes) {

            for (int i = 0; i < allDirFile.size(); i++) {
                File dirFile = allDirFile.get(i);
                File[] subFile = dirFile.listFiles();
                if (subFile == null || subFile.length <= 0) {

                    continue;
                }

                // 用于计数
                Map<String, Integer> orderMap = new HashMap<String, Integer>();

                for (int j = 0; j < subFile.length; j++) {
                    File realFileItem = subFile[j];
                    if (realFileItem.isDirectory()) {
                        continue;
                    }

                    String FileTypeStr = getFileTypeWithPoint_unknow(realFileItem.getName());
                    if (!mInputTypes.contains(FileTypeStr)) { // 如果 有输入类型 那么把不满足输入类型的 文件过滤掉
                        continue;
                    }
                    Integer curIndex = orderMap.get(FileTypeStr);
                    if (curIndex == null) {
                        orderMap.put(FileTypeStr, 1);
                        curIndex = 0;
                    }

                    curIndex = curIndex + 1;
                    orderMap.put(FileTypeStr, curIndex);
                    String newName = curIndex + FileTypeStr;
                    System.out.println("依据文件夹 单独重命名文件");
                    tryReName(realFileItem, newName);

                }
            }

        }

        void tryReNameByDir(ArrayList<File> allDirFile) {

            for (int i = 0; i < allDirFile.size(); i++) {
                File dirFile = allDirFile.get(i);
                File[] subFile = dirFile.listFiles();
                if (subFile == null || subFile.length <= 0) {

                    continue;
                }

                // 用于计数
                Map<String, Integer> orderMap = new HashMap<String, Integer>();

                for (int j = 0; j < subFile.length; j++) {
                    File realFileItem = subFile[j];
                    if (realFileItem.isDirectory()) {
                        continue;
                    }

                    String FileTypeStr = getFileTypeWithPoint_unknow(realFileItem.getName());
                    Integer curIndex = orderMap.get(FileTypeStr);
                    if (curIndex == null) {
                        orderMap.put(FileTypeStr, 1);
                        curIndex = 0;
                    }

                    curIndex = curIndex + 1;
                    orderMap.put(FileTypeStr, curIndex);
                    String newName = curIndex + FileTypeStr;
                    System.out.println("依据文件夹 单独重命名文件");
                    tryReName(realFileItem, newName);

                }
            }

        }

        @SuppressWarnings("unchecked")
        boolean tryReNameOperation(HashMap<String, ArrayList<File>> arrFileMap) {
            boolean executeFlag = false;
            Map.Entry<String, ArrayList<File>> entry;

            if (arrFileMap != null) {
                Iterator iterator = arrFileMap.entrySet().iterator();
                while (iterator.hasNext()) {
                    entry = (Map.Entry<String, ArrayList<File>>) iterator.next();
                    String typeStr = entry.getKey(); // Map的Value
                    ArrayList<File> fileArr = entry.getValue(); // Map的Value

                    for (int i = 0; i < fileArr.size(); i++) {
                        File curFile = fileArr.get(i);
//                        String curFileName = curFile.getName();
                        String mdName = getMD5Three(curFile.getAbsolutePath());
                        String mdtype = getFileTypeWithPoint(curFile.getName());
                        String new_md_Name = mdName + mdtype;
                        tryReName(curFile, new_md_Name);
                    }

                }
            }

            return executeFlag;
        }

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name + "\n" + Cur_Bat_Name
                    + " #_26           ### 把当前所有文件夹下 依据文件夹重新开始把实体文件重命名  ./A/aa.mp4  ./A/bb.mp4   ./A/xx.jpg >>> ./A/1.mp4  ./A/2.mp4   ./A/3.mp4  ./A/1.jpg (依据文件夹重新1开始)!  "
                    + "\n" + Cur_Bat_Name
                    + "#_26  .mp4         ### 把当前所有文件夹下 依据文件夹重新开始把实体文件重命名 .mp4类型文件 其他类型不变  ./A/aa.mp4  ./A/bb.mp4   ./A/xx.jpg >>> ./A/1.mp4  ./A/2.mp4   ./A/3.mp4  ./A/xx.jpg (依据文件夹 mp4类型文件重新1开始)!  "
                    +

                    "";
        }

    }

    class Time_Head_Rule_25 extends Basic_Rule {
        int originType;
        int targetType;

        Time_Head_Rule_25() {
            super("#", 25, 5);
            originType = -1;
            targetType = -1;
        }

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name + "  #_25  1992_" + getCurrentYear() + "   ##打开notepad输出当前1992年至今年"
                    + getCurrentYear() + "年 年月历   MD格式类型(年月里) \n" + Cur_Bat_Name
                    + "  #_25  1992_2020   ##打开notepad输出当前1992年至2020年 年月历   MD格式类型(年月里) \n" + Cur_Bat_Name
                    + "  #_25  1990_   ##打开notepad输出当前1990年至今年" + getCurrentYear() + " 年月历 MD格式类型(年月里) \n"
                    + Cur_Bat_Name + " #_25  _2010   ##打开notepad输出 1992(默认)至2010年年月历 MD格式类型(年月里) \n ";
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            boolean Flag = true;

            // 获取到装换的类型
            String inputFileTypeParams = inputParamList.get(inputParamList.size() - 1);

            if (!inputFileTypeParams.contains("_")) {
                Flag = false;
                System.out.println("无法检测到当前 第25 Rule   起始年份_截止年份   请检查后重新执行");
            } else {

                if (inputFileTypeParams.endsWith("_")) {
                    String target = "";
                    String[] parmas = inputFileTypeParams.split("_");
                    String origin = parmas[0];
                    System.out.println("item=" + inputFileTypeParams + "   origin=" + origin + "     target=" + target);
                    if (isNumeric(origin) && !"".equals(origin)) {
                        originType = Integer.parseInt(origin);
                    }

                    if (isNumeric(target) && !"".equals(target)) {
                        targetType = Integer.parseInt(target);
                    }
                } else {
                    String[] parmas = inputFileTypeParams.split("_");
                    System.out.println(
                            "item=" + inputFileTypeParams + "   origin=" + parmas[0] + "     target=" + parmas[1]);
                    if (parmas.length >= 2) {

                        if (isNumeric(parmas[0])) {
                            originType = Integer.parseInt(parmas[0]);
                        }

                        if (isNumeric(parmas[1])) {
                            targetType = Integer.parseInt(parmas[1]);
                        }

                    }

                }

                Flag = true;

            }

            return super.initParamsWithInputList(inputParamList) && Flag;
        }

        @Override
        ArrayList<File> applyDir_SubFileListRule5(ArrayList<File> allSubDirFileList,
                                                  ArrayList<File> allSubRealFileList) {
            // TODO Auto-generated method stub
            // TODO Auto-generated method stub
            if (originType == -1) { // 没有获取到 初始化值 那么 默认就是 1992
                originType = 1992;
            }

            if (targetType == -1) { // 没有获取到 初始化值 那么 默认就是 1992
                targetType = getCurrentYear();
            }

            // 确保 origin 是 小于 targetType 的
            if (originType > targetType) {
                targetType = originType + targetType;
                originType = targetType - originType;
                targetType = targetType - originType;
            }
            StringBuilder sb = new StringBuilder();
            System.out.println("targetType = " + targetType + "    originType=" + originType);
            for (int i = targetType; i >= originType; i--) {
                sb.append("   \n");
                sb.append("   \n");
                sb.append("   \n");

                for (int j = 12; j >= 1; j--) {
                    sb.append("### " + i + "." + (j > 9 ? "" + j : "0" + j));

                    sb.append("   \n");
                    sb.append("   \n");
                }

                sb.append("## " + i);
                sb.append("   \n");
                sb.append("   \n");

            }
            writeContentToFile(G2_Temp_Text_File, sb.toString());
            NotePadOpenTargetFile(G2_Temp_Text_File.getAbsolutePath());
            return super.applyDir_SubFileListRule5(allSubDirFileList, allSubRealFileList);
        }

    }
    // operation_type 操作类型 1--读取文件内容字符串 进行修改 2--对文件对文件内容(字节)--进行修改 3.对全体子文件进行的随性的操作
    // 属性进行修改(文件名称)
//     // 4.对当前子文件(包括子目录 子文件 --不包含孙目录 孙文件) 5. 从shell 中获取到的路径 去对某一个文件进行操作

    // 对 图片文件进行 裁剪 -20_-20_20_20
    // 上下左右的padding 上 -20 20 图片往下移动20 显示20的空白
    // 上 正-》 显示20的空白 负》 图片缩进20 去掉图片的20距离
    // 下 正-》 下显示20的空白 负》 下图片缩进20 去掉图片的20距离
    // 左 正-》 左显示20的空白 负》 左图片缩进20 去掉图片的20距离
    // 右 正-》 右显示20的空白 负》 右图片缩进20 去掉图片的20距离

    // 在当前的目录 与 子目录 之间 新增 一层文件夹 , 文件夹名称任意 用户输入
    class add_Middle_Dir_Rule_24 extends Basic_Rule {

        add_Middle_Dir_Rule_24() {
            super("#", 24, 4); //
            middle_dir_name = "mp4";
        }

        // 中间文件夹的名称
        String middle_dir_name;

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name + "  #_24  jpg   ##在当前目录与子目录之间加一层目录jpg  1/1.jpg -> 1/jpg/1.jpg \n" + Cur_Bat_Name
                    + "  #_24  mp4   ##在当前目录与子目录之间加一层目录jpg  1/1.mp4 -> 1/mp4/1.mp4  1/1.jpg -> 1/mp4/1.jpg \n"
                    + Cur_Bat_Name
                    + " #_24  gif  ##在当前目录与子目录之间加一层目录jpg  1/1.mp4 -> 1/gif/1.mp4  1/1.jpg -> 1/gif/1.jpg \\n ";
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            boolean Flag = true;

            // 获取到装换的类型
            String inputFileTypeParams = inputParamList.get(inputParamList.size() - 1);

            if (inputFileTypeParams == null || "".equals(inputFileTypeParams) || inputFileTypeParams.contains("#")
                    || inputFileTypeParams.contains("~") || inputFileTypeParams.contains("`")
                    || inputFileTypeParams.contains("@") || inputFileTypeParams.contains("$")
                    || inputFileTypeParams.contains("%") || inputFileTypeParams.contains("^")
                    || inputFileTypeParams.contains("&") || inputFileTypeParams.contains("*")
                    || inputFileTypeParams.contains("(") || inputFileTypeParams.contains(")")
                    || inputFileTypeParams.contains("=") || inputFileTypeParams.contains("+")
                    || inputFileTypeParams.contains("-") || inputFileTypeParams.contains("/")
                    || inputFileTypeParams.contains("?") || inputFileTypeParams.contains("[")
                    || inputFileTypeParams.contains("|") || inputFileTypeParams.contains("{")
                    || inputFileTypeParams.contains("}") || inputFileTypeParams.contains("]")
                    || inputFileTypeParams.contains("|") || inputFileTypeParams.contains(",")
                    || inputFileTypeParams.contains("'") || inputFileTypeParams.contains("!")) {

                Flag = false;
                System.out.println(
                        "无法检测到当前 第24 Rule  创建中间夹层目录的名称不合规 请检查   请检查后重新执行 inputParams = " + inputFileTypeParams);
            } else {
                middle_dir_name = inputFileTypeParams;
            }

            return super.initParamsWithInputList(inputParamList) && Flag;
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            // TODO Auto-generated method stub

            for (int i = 0; i < curFileList.size(); i++) {
                File sonFile = curFileList.get(i);

                File middle_dir = new File(sonFile.getAbsoluteFile() + File.separator + middle_dir_name);
                if (!middle_dir.exists()) {
                    middle_dir.mkdirs();
                    System.out.println(" FFFFF  middle_dir = " + middle_dir.getAbsolutePath());
                }

                File sunFile = new File(middle_dir.getAbsolutePath() + File.separator + sonFile.getName());

                if (sonFile.isDirectory()) {

                    ArrayList<File> searchRealList = getAllSubFile(sonFile);
                    String sonFile_abs = sonFile.getAbsolutePath();

                    for (int j = 0; j < searchRealList.size(); j++) {
                        File realFile = searchRealList.get(j);
                        String realFile_abs = realFile.getAbsolutePath();
                        String fixed_realFile_abs = realFile_abs.replace(sonFile_abs, middle_dir.getAbsolutePath());
                        File targetFile = new File(fixed_realFile_abs);
                        fileCopy(realFile, targetFile);
                        realFile.delete();
                    }

                } else {
//				copyFile(sonFile, sunFile);
                    fileCopy(sonFile, sunFile);
                }
                sonFile.delete();
                System.out.println(" EEEEEE ");

            }

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

    }

    // 检查文件的真实类型 并对 那些 不符合真实类型的文件 进行提示
    class CheckFileRealFormat_Rule_23 extends Basic_Rule {

        final HashMap<String, String> mFileTypes; // 魔数 ----- 类型
        final HashMap<String, ArrayList<String>> mSameMoShu_ArrType_Map; // 使用相同魔数 8位字符的文件
        ArrayList<String> NoMoShuTypeList; // 没有魔数的类型 比如 txt
        boolean isFixToRealType = false;

        CheckFileRealFormat_Rule_23() {
            super("#", 23, 4); //
            mFileTypes = new HashMap<String, String>();
            mSameMoShu_ArrType_Map = new HashMap<String, ArrayList<String>>();
            NoMoShuTypeList = new ArrayList<String>();

            isFixToRealType = false;
            initMoShuTypeMap();
            InitInitSameMoShuMap_NoMoShuTypeList();
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // TODO Auto-generated method stub

            for (int i = 0; i < inputParamList.size(); i++) {
                String inputParam = inputParamList.get(i);
                if (inputParam.trim().toLowerCase().startsWith("fix2real_true")) {
                    isFixToRealType = true;
                } else {
                    isFixToRealType = false;
                }

            }
            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_" + rule_index + "    ### 对当前目录的文件进行真实类型的检测[通过魔数字]并打印那些类型和魔数不一样文件的列表信息  \n"
                    + Cur_Bat_Name + " #_" + rule_index
                    + "  fix2real_false    ### 对当前目录的文件进行真实类型的检测[通过魔数字]并打印那些类型和魔数不一样文件的列表信息 \n"

                    + Cur_Bat_Name + " #_" + rule_index
                    + "  fix2real_true    ### 对当前目录的文件进行真实类型的检测[通过魔数字]并修正那些类型和魔数不一样文件的列表信息 \n"

                    ;
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            // TODO Auto-generated method stub
            int different_type_file_index = 1;
            ArrayList<File> differentRealTypeFileList = new ArrayList<File>();
            System.out.println("════════════════════════" + " 当前目录文件的 魔数情况 Begin " + "════════════════════════");
            curRealFileList.sort(new Comparator<File>() {

                @Override
                public int compare(File o1, File o2) {
                    // TODO Auto-generated method stub
                    String o1_type = getFileTypeWithPoint(o1.getName());
                    String o2_type = getFileTypeWithPoint(o2.getName());
                    return o1_type.compareTo(o2_type);
                }
            });
            for (int i = 0; i < curRealFileList.size(); i++) {

                File realFile = curRealFileList.get(i);
                String originFileType = getFileTypeWithPoint(realFile.getName()).toLowerCase();
                if ("".equals(originFileType)) {
                    originFileType = "unknow";
                }
                String fileNameWithoutPoint = getFileTypeWithPoint(realFile.getName()).trim().toLowerCase();
                String realfileType = getFileType(realFile.getAbsolutePath());

                if (realfileType == null) {

                    realfileType = "unknow";
//		            	if("".equals(originFileType)) {
//		            		fileType = "";
//		            	}else {
//		            		fileType = originFileType;
//		            	}
                }
                String moshu = getFileHeader(realFile.getAbsolutePath());

                System.out.println("Index[" + i + "]     showType=[" + originFileType + "]      realType=[."
                        + realfileType + "]      MoShu=[" + moshu + "]     PATH=[" + realFile.getAbsolutePath() + "]");

                /*
                 * final HashMap<String, String> mFileTypes; // 魔数 ----- 类型 final
                 * HashMap<String, ArrayList<String>> mSameMoShu_ArrType_Map; // 使用相同魔数 8位字符的文件
                 * ArrayList<String> NoMoShuTypeList ; // 没有魔数的类型 比如 txt
                 */

                if (!originFileType.equals(("." + realfileType).toLowerCase())) {

                    if ("unknow".equals(realfileType)
                            && NoMoShuTypeList.contains(originFileType.replace(".", "").toLowerCase())) {
                        continue;
                    }
                    // 如果当前的 文件类型 没有魔术 那么 不对比

                    ArrayList<String> sameTypeList = mSameMoShu_ArrType_Map.get(moshu);

                    // 如果 两个 文件类型 使用 相同的 type 那么 也排除 这样的文件
                    if (sameTypeList != null && sameTypeList.contains(originFileType.replace(".", "").toLowerCase())) {

                        continue;
                    }

                    differentRealTypeFileList.add(realFile);
                    different_type_file_index++;

                }

            }

            System.out.println("════════════════════════" + " 当前目录文件的 魔数情况 End " + "════════════════════════");

            if (differentRealTypeFileList.size() > 0) {
                System.out.println("════════════" + " 打印 【" + differentRealTypeFileList.size()
                        + "】 个 显示的类型 和 真实的类型不同的文件 Begin " + "════════════");

                for (int i = 0; i < differentRealTypeFileList.size(); i++) {
                    File realType_showType_Diff_File = differentRealTypeFileList.get(i);
                    String oldName = realType_showType_Diff_File.getName();
                    String showTypeStr = getFileTypeWithPoint(realType_showType_Diff_File.getName());
                    String realType = getFileType(realType_showType_Diff_File.getAbsolutePath());
                    if (realType == null) {
                        realType = "";
                    }

                    String originFileType = getFileTypeWithPoint(realType_showType_Diff_File.getName());
                    String moshu = getFileHeader(realType_showType_Diff_File.getAbsolutePath());
                    String fileNameNoPoint = getFileNameNoPointNoLowerCase(realType_showType_Diff_File.getName());

                    String realfileType = getFileType(realType_showType_Diff_File.getAbsolutePath());

                    if (realfileType == null) {
                        realfileType = "unknow";
                    }

                    System.out.println("Diff_Index[" + i + "]     showType=[" + originFileType + "]      realType=[."
                            + realfileType + "]      MoShu=[" + moshu + "]     PATH=["
                            + realType_showType_Diff_File.getAbsolutePath() + "]  initMoshuTypeItem(\"" + moshu
                            + "\", \"" + (realfileType.equals("unknow") ? showTypeStr.replace(".", "") : realfileType)
                            + "\"); ");

                }
                System.out.println("════════════" + " 打印 【" + differentRealTypeFileList.size()
                        + "】 个 显示的类型 和 真实的类型不同的文件 End " + "════════════");

            } else {

                System.out.println("════════════恭喜  当前所有文件 真实类型 和 显示类型 全都相同 " + "════════════");

            }

            if (isFixToRealType && differentRealTypeFileList.size() > 0) {
                System.out.println("═══════════════════  执行 [" + differentRealTypeFileList.size()
                        + "]个文件 改为真实类型的 操作 Begin ══════════════════");
                for (int i = 0; i < differentRealTypeFileList.size(); i++) {
                    File realType_showType_Diff_File = differentRealTypeFileList.get(i);
                    String oldName = realType_showType_Diff_File.getName();
                    String showTypeStr = getFileTypeWithPoint(realType_showType_Diff_File.getName());
                    String realType = getFileType(realType_showType_Diff_File.getAbsolutePath());
                    if (realType == null) {
                        realType = "";
                    }
                    String moshu = getFileHeader(realType_showType_Diff_File.getAbsolutePath());
                    String fileNameNoPoint = getFileNameNoPointNoLowerCase(realType_showType_Diff_File.getName());

                    String newFileName = fileNameNoPoint + "." + realType;
                    tryReName(realType_showType_Diff_File, newFileName);
                    System.out.println("Index[" + i + "]     showType=[" + showTypeStr + "]      realType=[." + realType
                            + "]      MoShu=[" + moshu + "]  OldName=[" + oldName + "]    NewName[" + newFileName
                            + "]     isFixToRealType=[" + isFixToRealType + "]    PATH=["
                            + realType_showType_Diff_File.getAbsolutePath() + "]");

                }
                System.out.println("═══════════════════  执行 [" + differentRealTypeFileList.size()
                        + "]个文件 改为真实类型的 操作 End ══════════════════");

            }

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        void initMoShuTypeMap() {

            // images
            initMoshuTypeItem("FFD8FF", "jpg");
            initMoshuTypeItem("89504E47", "png");
            initMoshuTypeItem("47494638", "gif");
            initMoshuTypeItem("49492A00", "tif");
            initMoshuTypeItem("424D", "bmp");
            initMoshuTypeItem("424D", "bmp");
            initMoshuTypeItem("424D228C010000000000", "bmp"); // 16色位图(bmp)
            initMoshuTypeItem("424D8240090000000000", "bmp"); // 24色位图(bmp)
            initMoshuTypeItem("424D8E1B030000000000", "bmp"); // 256色位图(bmp)

            //
            initMoshuTypeItem("41433130", "dwg"); // CAD
            initMoshuTypeItem("38425053", "psd");
            initMoshuTypeItem("7B5C727466", "rtf"); // 日记本
            initMoshuTypeItem("7B5C7274", "rtf"); // 日记本
            initMoshuTypeItem("504B0304", "zip"); // 日记本
            initMoshuTypeItem("3C3F786D6C", "xml");
            initMoshuTypeItem("3C3F786D", "xml");

            initMoshuTypeItem("68746D6C3E", "html");
            initMoshuTypeItem("68746D6C", "html");

            initMoshuTypeItem("44656C69766572792D646174653A", "eml"); // 邮件
            initMoshuTypeItem("44656C69", "eml"); // 邮件

            initMoshuTypeItem("D0CF11E0", "doc");

            initMoshuTypeItem("CFAD12FEC5FD746F", "dbx"); /** Outlook Express (dbx) */
            initMoshuTypeItem("CFAD12FE", "dbx");

            initMoshuTypeItem("2142444E", "pst"); // /** Outlook (pst)*/
            initMoshuTypeItem("FF575043", "wpb"); /** Word Perfect (wpd) */

            initMoshuTypeItem("252150532D41646F6265", "esp");
            initMoshuTypeItem("25215053", "esp");
            initMoshuTypeItem("252150532D41646F6265", "PS");
            initMoshuTypeItem("25215053", "PS");
            initMoshuTypeItem("255044462D312E", "PDF");
            initMoshuTypeItem("25504446", "PDF");
            initMoshuTypeItem("AC9EBD8F", "qdf");
            initMoshuTypeItem("458600000600", "qbb");
            initMoshuTypeItem("45860000", "qbb");
            initMoshuTypeItem("E3828596", "PWL");
            initMoshuTypeItem("504B0304", "zip");
            initMoshuTypeItem("52617221", "RAR");
            initMoshuTypeItem("57415645", "WAV");
            initMoshuTypeItem("41564920", "AVI");
            initMoshuTypeItem("2E7261FD", "RAM");
            initMoshuTypeItem("2E524D46", "RM");
            initMoshuTypeItem("2E524D46000000120001", "RMVB");
            initMoshuTypeItem("2E524D46", "RMVB");
            initMoshuTypeItem("000001BA", "MPG");
            initMoshuTypeItem("6D6F6F76", "MOV");
            initMoshuTypeItem("3026B2758E66CF11", "ASF");
            initMoshuTypeItem("D7CDC69A", "wmf");
            initMoshuTypeItem("3026B275", "ASF");
            initMoshuTypeItem("000060EA", "ARJ");
            initMoshuTypeItem("4D546864", "MID");
            initMoshuTypeItem("00000020667479706D70", "MP4");
            initMoshuTypeItem("00000020", "MP4");
            initMoshuTypeItem("49443303000000002176", "MP3");
            initMoshuTypeItem("49443303", "MP3");
            initMoshuTypeItem("464C5601050000000900", "FLV");
            initMoshuTypeItem("464C5601", "FLV");
            initMoshuTypeItem("1F8B0800", "GZ");
            initMoshuTypeItem("48544D4C207B0D0A0942", "CSS");
            initMoshuTypeItem("48544D4C", "CSS");
            initMoshuTypeItem("696B2E71623D696B2E71", "JS");
            initMoshuTypeItem("696B2E71", "JS");
            initMoshuTypeItem("d0cf11e0a1b11ae10000", "VSD");
            initMoshuTypeItem("d0cf11e0", "VSD");
            initMoshuTypeItem("d0cf11e0a1b11ae10000", "WPS");
            initMoshuTypeItem("d0cf11e0", "WPS");
            initMoshuTypeItem("6431303A637265617465", "TORRENT");
            initMoshuTypeItem("6431303A", "TORRENT");
            initMoshuTypeItem("3C2540207061676520", "JSP");
            initMoshuTypeItem("3C254020", "JSP");
            initMoshuTypeItem("7061636B61676520", "JAVA");
            initMoshuTypeItem("7061636B", "JAVA");
            initMoshuTypeItem("2F2A0A20", "JAVA");

            initMoshuTypeItem("CAFEBABE0000002E00", "CLASS");
            initMoshuTypeItem("CAFEBABE", "CLASS");
            initMoshuTypeItem("504B03040A000000", "JAR");
            initMoshuTypeItem("504B0304", "JAR");
            initMoshuTypeItem("4D616E69666573742D56", "MF");
            initMoshuTypeItem("4D616E69", "MF");
            initMoshuTypeItem("4D5A9000030000000400", "EXE");
            initMoshuTypeItem("4D5A9000", "EXE");
            initMoshuTypeItem("7F454C4601010100", "ELF");
            initMoshuTypeItem("7F454C46", "ELF");
            initMoshuTypeItem("2000604060", "WK1");
            initMoshuTypeItem("20006040", "WK1");
            initMoshuTypeItem("00001A0000100400", "WK3");
            initMoshuTypeItem("00001A00", "WK3");
            initMoshuTypeItem("00001A0002100400", "WK4");
            initMoshuTypeItem("576F726450726F", "LWP");
            initMoshuTypeItem("576F7264", "LWP");
            initMoshuTypeItem("53520100", "SLY");

            initMoshuTypeItem("D0CF11E0", "ppt");
            initMoshuTypeItem("D0CF11E0", "xls");// excel2003版本文件
            initMoshuTypeItem("5374616E64617264204A", "mdb");
            initMoshuTypeItem("5374616E", "mdb");
            initMoshuTypeItem("252150532D41646F6265", "ps");
            initMoshuTypeItem("25215053", "ps");
            initMoshuTypeItem("255044462D312E", "pdf");
            initMoshuTypeItem("25504446", "pdf");
            initMoshuTypeItem("504B0304", "pptx");
            initMoshuTypeItem("504B0304", "docx");
            initMoshuTypeItem("504B0304", "xlsx");// excel2007以上版本文件
            initMoshuTypeItem("52617221", "rar");
            initMoshuTypeItem("57415645", "wav");
            initMoshuTypeItem("41564920", "avi");
            initMoshuTypeItem("2E524D46", "rm");
            initMoshuTypeItem("000001BA", "mpg");
            initMoshuTypeItem("000001B3", "mpg");
            initMoshuTypeItem("6D6F6F76", "mov");
            initMoshuTypeItem("3026B2758E66CF11", "asf");
            initMoshuTypeItem("4D546864", "mid");
            initMoshuTypeItem("1F8B08", "gz");
            initMoshuTypeItem("3C21444F", "html");
        }

        void initMoshuTypeItem(String key, String value) {
            mFileTypes.put(key.toUpperCase(), value.toLowerCase());
        }

        /**
         * @param filePath 文件路径
         * @return 文件头信息
         * @author wlx
         *         <p>
         *         方法描述：根据文件路径获取文件头信息
         */
        public String getFileType(String filePath) {
//	        System.out.println(getFileHeader(filePath));
//	        System.out.println(mFileTypes.get(getFileHeader(filePath)));
            return mFileTypes.get(getFileHeader(filePath));
        }

        public void InitInitSameMoShuMap_NoMoShuTypeList() {
//	    	mSameMoShu_ArrType_Map
// NoMoShuTypeList           abcdef

            // ==============================================
            NoMoShuTypeList.add("txt");
            NoMoShuTypeList.add("tmp");
            NoMoShuTypeList.add("vsdconfig");
            NoMoShuTypeList.add("ver");
            NoMoShuTypeList.add("tlog");
            NoMoShuTypeList.add("tcl");
            NoMoShuTypeList.add("swift");
            NoMoShuTypeList.add("sql");
            NoMoShuTypeList.add("sha512");
            NoMoShuTypeList.add("sha1");
            NoMoShuTypeList.add("s");
            NoMoShuTypeList.add("h");
            NoMoShuTypeList.add("rb");
            NoMoShuTypeList.add("py");
            NoMoShuTypeList.add("pm");
            NoMoShuTypeList.add("pkgdef");
            NoMoShuTypeList.add("md");
            NoMoShuTypeList.add("lex");
            NoMoShuTypeList.add("lzz");
            NoMoShuTypeList.add("json");
            NoMoShuTypeList.add("ini");
            NoMoShuTypeList.add("cpp");
            NoMoShuTypeList.add("code");
            NoMoShuTypeList.add("cer");
            NoMoShuTypeList.add("c");
            NoMoShuTypeList.add("admx");
            NoMoShuTypeList.add("adml");
            NoMoShuTypeList.add("vert");
            NoMoShuTypeList.add("tmlanguage");
            NoMoShuTypeList.add("swift");
            NoMoShuTypeList.add("sh");
            NoMoShuTypeList.add("js");
            NoMoShuTypeList.add("idl");
            NoMoShuTypeList.add("expected");

            NoMoShuTypeList.add("exp");
            NoMoShuTypeList.add("def");
            NoMoShuTypeList.add("db");
            NoMoShuTypeList.add("data");
            NoMoShuTypeList.add("dat");
            NoMoShuTypeList.add("bat");
            NoMoShuTypeList.add("at");
            NoMoShuTypeList.add("len");
            NoMoShuTypeList.add("prop");
            NoMoShuTypeList.add("snippet");
            NoMoShuTypeList.add("swift");
            NoMoShuTypeList.add("tmlanguage");
            NoMoShuTypeList.add("ts");
            // ==============================================
            String moshu_zip = "504B0304";
            ArrayList<String> same_zip_TypeList = new ArrayList<String>();
            same_zip_TypeList.add("zip");
            same_zip_TypeList.add("xlsx");
            same_zip_TypeList.add("pptx");
            same_zip_TypeList.add("nupkg");
            same_zip_TypeList.add("jar");
            same_zip_TypeList.add("dotm");
            same_zip_TypeList.add("apk");
            mSameMoShu_ArrType_Map.put(moshu_zip, same_zip_TypeList);

            String moshu_exe = "4D5A9000";
            ArrayList<String> same_exe_TypeList = new ArrayList<String>();
            same_exe_TypeList.add("exe");
            same_exe_TypeList.add("toc");
            same_exe_TypeList.add("node");
            same_exe_TypeList.add("mun");
            same_exe_TypeList.add("mui");
            same_exe_TypeList.add("olb");
            same_exe_TypeList.add("iltoc");
            same_exe_TypeList.add("ildll");
            same_exe_TypeList.add("dll");
            same_exe_TypeList.add("sys");
            mSameMoShu_ArrType_Map.put(moshu_exe, same_exe_TypeList);

            String moshu_so = "7F454C46";
            ArrayList<String> same_so_TypeList = new ArrayList<String>();
            same_so_TypeList.add("so");
            same_so_TypeList.add("elf");
            mSameMoShu_ArrType_Map.put(moshu_so, same_so_TypeList);

            String moshu_xls = "D0CF11E0";
            ArrayList<String> same_xls_TypeList = new ArrayList<String>();
            same_xls_TypeList.add("xls");
            same_xls_TypeList.add("doc");
            same_xls_TypeList.add("ptt");
            mSameMoShu_ArrType_Map.put(moshu_xls, same_xls_TypeList);

            String moshu_xml = "3C3F786D";
            ArrayList<String> same_xml_TypeList = new ArrayList<String>();
            same_xml_TypeList.add("xml");
            same_xml_TypeList.add("pom");
            same_xml_TypeList.add("manifest");
            same_xml_TypeList.add("iml");
            same_xml_TypeList.add("filters");
            same_xml_TypeList.add("config");
            same_xml_TypeList.add("vcxproj");

            mSameMoShu_ArrType_Map.put(moshu_xml, same_xml_TypeList);

            String moshu_JAVA = "2F2A0A20";
            ArrayList<String> same_Java_TypeList = new ArrayList<String>();
            same_Java_TypeList.add("java");
            same_Java_TypeList.add("kt");
            same_Java_TypeList.add("groovy");
            same_Java_TypeList.add("pm");

            mSameMoShu_ArrType_Map.put(moshu_JAVA, same_Java_TypeList);

            String moshu_inf = "FFFE5B00";
            ArrayList<String> same_inf_TypeList = new ArrayList<String>();
            same_inf_TypeList.add("inf");
            same_inf_TypeList.add("inf_loc");
            mSameMoShu_ArrType_Map.put(moshu_inf, same_inf_TypeList);

            String moshu_pdb = "4D696372";
            ArrayList<String> same_pdb_TypeList = new ArrayList<String>();
            same_pdb_TypeList.add("pdb");
            same_pdb_TypeList.add("ilpdb");
            same_pdb_TypeList.add("iltocpdb");

            mSameMoShu_ArrType_Map.put(moshu_pdb, same_pdb_TypeList);

            String moshu_admx = "EFBBBF3C";
            ArrayList<String> same_admx_TypeList = new ArrayList<String>();
            same_admx_TypeList.add("nuspec");
            same_admx_TypeList.add("admx");
            mSameMoShu_ArrType_Map.put(moshu_admx, same_pdb_TypeList);

            String moshu_swift = "7F454C46";
            ArrayList<String> same_swift_TypeList = new ArrayList<String>();
            same_swift_TypeList.add("swift");
            same_swift_TypeList.add("gyb");
            same_swift_TypeList.add("sil");
            mSameMoShu_ArrType_Map.put(moshu_swift, same_so_TypeList);

            // ==============================================
            initMoshuTypeItem("FFFE5B00", "inf_loc");
            initMoshuTypeItem("22205669", "vim");
            initMoshuTypeItem("6C657420", "vim");
            initMoshuTypeItem("00010000", "ttf");
            initMoshuTypeItem("3C737667", "svg");
            initMoshuTypeItem("6F2F636F", "bin");

            initMoshuTypeItem("D4C3B2A1", "cap");
            initMoshuTypeItem("2F2F3D3D", "mm");
            initMoshuTypeItem("2F2A2120", "ts");
            initMoshuTypeItem("4D5A9000", "exe");
            initMoshuTypeItem("23707261", "mof");
            initMoshuTypeItem("482E517F", "ipdb");
            initMoshuTypeItem("2F2F2052", "gyb");
            initMoshuTypeItem("D4C3B2A1", "pcap");
            initMoshuTypeItem("23232323", "properties");
            initMoshuTypeItem("7F454C46", "so");
            initMoshuTypeItem("64862300", "iobj");
            initMoshuTypeItem("FFD8FFE0", "jpeg");
            initMoshuTypeItem("2E636C61", "smali");
            initMoshuTypeItem("4F424A43", "rst");
            initMoshuTypeItem("4155544F", "rst");
            initMoshuTypeItem("420D0D0A", "pyc");
            initMoshuTypeItem("692F6A61", "bin");
            initMoshuTypeItem("D0CF11E0", "xls");
            initMoshuTypeItem("3C3F786D", "xml");
            initMoshuTypeItem("23202121", "pl");
            initMoshuTypeItem("4D696372", "pdb");
            initMoshuTypeItem("04000000", "pak");
            initMoshuTypeItem("626F6479", "out");
            initMoshuTypeItem("05000000", "aux");
            initMoshuTypeItem("4D534654", "olb");
            initMoshuTypeItem("EFBBBF3C", "nuspec");
            initMoshuTypeItem("24504D54", "nma");
            initMoshuTypeItem("6E006F00", "nlp");
            initMoshuTypeItem("23206372", "msg");
            initMoshuTypeItem("0000001C", "mp4");
            initMoshuTypeItem("00000018", "mp4");
            initMoshuTypeItem("213C6172", "lib");
            initMoshuTypeItem("7B7B2320", "jst");
            initMoshuTypeItem("2F2F203D", "js");
            initMoshuTypeItem("4D696372", "iltocpdb");
            initMoshuTypeItem("4D696372", "ilpdb");
            initMoshuTypeItem("00000100", "ico");
            initMoshuTypeItem("2320456E", "enc");
        }

        boolean isTypeUsedSameMoShu(String showType, String realType) {
            boolean isSameMoShu = false;

            return false;
        }

        /**
         * @param filePath 文件路径
         * @return 文件头信息
         * @author wlx
         *         <p>
         *         方法描述：根据文件路径获取文件头信息
         */
        public String getFileHeader(String filePath) {
            FileInputStream is = null;
            String value = null;
            try {
                is = new FileInputStream(filePath);
                byte[] b = new byte[4];
                /*
                 * int read() 从此输入流中读取一个数据字节。int read(byte[] b) 从此输入流中将最多 b.length 个字节的数据读入一个
                 * byte 数组中。 int read(byte[] b, int off, int len) 从此输入流中将最多 len 个字节的数据读入一个 byte
                 * 数组中。
                 */
                is.read(b, 0, b.length);
                value = bytesToHexString(b);
                value = value.toUpperCase();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                if (null != is) {
                    try {
                        is.close();
                    } catch (IOException e) {
                        e.printStackTrace();
                    }
                }
            }
//			System.out.println("文件:" + filePath + "    魔数byte[4]_value_moshu = " + value);

            return value;
        }



    }

    /**
     * @param src 要读取文件头信息的文件的byte数组
     * @return 文件头信息
     * @author wlx
     *         <p>
     *         方法描述：将要读取文件头信息的文件的byte数组转换成string类型表示
     */
    static String bytesToHexString(byte[] src) {
        StringBuilder builder = new StringBuilder();
        if (src == null || src.length <= 0) {
            return null;
        }
        String hv;
        for (byte aSrc : src) {
            // 以十六进制（基数 16）无符号整数形式返回一个整数参数的字符串表示形式，并转换为大写
            hv = Integer.toHexString(aSrc & 0xFF).toUpperCase();
            if (hv.length() < 2) {
                builder.append(0);
            }
            builder.append(hv);
        }
//        System.out.println(builder.toString());
        return builder.toString();
    }


    class ReSize_Img_Rule_22 extends Basic_Rule {

        ArrayList<String> fliterTypeList;
        ArrayList<File> mSrcFileImage; // 符合 过滤 条件的 当前目录的文件夹的集合
        ArrayList<Integer> up_down_left_right;

        ReSize_Img_Rule_22() {
            super("#", 22, 4); //
            mSrcFileImage = new ArrayList<File>();
            fliterTypeList = new ArrayList<String>();
            up_down_left_right = new ArrayList<Integer>();

            fliterTypeList.add(".jpg");
            fliterTypeList.add(".png");
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {
                System.out.println("initParamsWithInputList_inputParamList[" + i + "] = " + inputParamList.get(i));

                if (i == 1) {
                    String one_param = inputParamList.get(1);
                    if (!one_param.contains("_")) { // 当前的第一个参数不是 上_下_左_右 参数
                        System.out.println("当前的第二个参数不是 上_下_左_右 参数");
                        return false;
                    }
                    up_down_left_right = calculSize(one_param);
                    continue;
                }

                System.out.println("File[" + i + "] = " + curDirPath + File.separator + inputParamList.get(i));
                File inputFile = new File(curDirPath + File.separator + inputParamList.get(i));
                String fileName_lower = inputFile.getName().toLowerCase();
                if (inputFile.exists() && (fileName_lower.endsWith(".jpg") || fileName_lower.endsWith(".png"))) {
                    mSrcFileImage.add(inputFile);
                }
            }
            if (mSrcFileImage.size() == 0 && inputParamList.size() >= 3) {
                System.out.println("用户输入了 无效的文件  请检查输入的文件名称！ ");
                return false;
            }
            return super.initParamsWithInputList(inputParamList);
        }

        // -20_-20_-20_-20
        ArrayList<Integer> calculSize(String size_str) {
            ArrayList<Integer> size_4_List = new ArrayList<Integer>();
            String checkStr = size_str.replaceAll("_", "").replace("+", "").replaceAll("-", "");
            if (!isNumeric(checkStr.trim())) {
                System.out.println("当前的 上_下_左_右 参数 输入错误(1):" + size_str);
                return size_4_List;
            }
            String[] arr = size_str.split("_");
            if (arr == null || arr.length != 4) {
                System.out.println("当前的 上_下_左_右 参数 输入错误(2):" + size_str);
                return size_4_List;
            }

            Integer up_int = Integer.parseInt(arr[0]);
            Integer down_int = Integer.parseInt(arr[1]);
            Integer left_int = Integer.parseInt(arr[2]);
            Integer right_int = Integer.parseInt(arr[3]);

            size_4_List.add(up_int);
            size_4_List.add(down_int);
            size_4_List.add(left_int);
            size_4_List.add(right_int);

            return size_4_List;

        }

        boolean checkInFlitterList(String fileName) {
            boolean result = false;

            for (int i = 0; i < fliterTypeList.size(); i++) {
                if (fileName.endsWith(fliterTypeList.get(i))) {
                    result = true;
                    break;
                }
            }
            return result;
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            ArrayList<File> operationFileList = new ArrayList<File>();
            ArrayList<File> newOperationFileList = new ArrayList<File>();
            if (mSrcFileImage.size() > 0) {
                System.out.println("═══════════════════ 只对当前输入 Img 文件进行处理");
                operationFileList.addAll(mSrcFileImage);
                for (int i = 0; i < operationFileList.size(); i++) {
                    File inputFile = operationFileList.get(i);
                    System.out.println("inputFile[" + i + "] = " + inputFile.getName());
                }
            } else {
                System.out.println("═══════════════════ 用户输入文件为空--对本地所有Img jpg png 文件进行处理");

                for (int i = 0; i < curRealFileList.size(); i++) {
                    File fileItem = curRealFileList.get(i);
                    String fileName = fileItem.getName();
                    String fileName_lower = fileName.toLowerCase();

                    boolean isTypeInList = checkInFlitterList(fileName_lower);
                    if (isTypeInList) {
                        operationFileList.add(fileItem);
                    }
                }

            }

            String Dir_Name_Padding = "Img_Padding_" + getTimeStamp();
            File dirPaddingFile = new File(curDirPath + File.separator + Dir_Name_Padding);
            if (!dirPaddingFile.exists()) {
                dirPaddingFile.mkdirs();
            }

            for (int i = 0; i < operationFileList.size(); i++) {
                File srcFile = operationFileList.get(i);
                String fileName = srcFile.getName();
                File newFileItem = new File(dirPaddingFile.getAbsolutePath() + File.separator + fileName);
                fileCopy(srcFile, newFileItem);
                newOperationFileList.add(newFileItem);
            }

            int up_int = up_down_left_right.get(0);
            int down_int = up_down_left_right.get(1);
            int left_int = up_down_left_right.get(2);
            int right_int = up_down_left_right.get(3);
            String up_str = up_int > 0 ? "【上增加" + up_int + "空白】" : "【上减少" + up_int + "内容】";
            String down_str = down_int > 0 ? "【下增加" + down_int + "空白】" : "【下减少" + down_int + "内容】";
            String left_str = left_int > 0 ? "【左增加" + left_int + "空白】" : "【左减少" + left_int + "内容】";
            String right_str = right_int > 0 ? "【右增加" + right_int + "空白】" : "【右减少" + right_int + "内容】";

            System.out.println("当前批操作集合:" + up_str + down_str + left_str + right_str);
            System.out.println("当前操作文件数量: " + newOperationFileList.size());
            for (int i = 0; i < newOperationFileList.size(); i++) {
                File imageFile = newOperationFileList.get(i);
                String fileName = imageFile.getName();
                System.out.println("FIle[" + i + "] =" + fileName + "  开始执行操作！ ");
                ImageIcon imageIcon = new ImageIcon(imageFile.getAbsolutePath());

                BufferedImage originImage = getBufferedImage(imageFile);
                int h = originImage.getHeight();
                int w = originImage.getWidth();
                int high = originImage.getHeight();
                int width = originImage.getWidth();
                int up_down_sum = up_int + down_int;
                int left_right_sum = left_int + right_int;

                int target_width = width + left_right_sum;
                int target_high = high + up_down_sum;
                // 显示图片的起始位置

                int width_input = target_width;
                int height_input = target_high;

                int srcImage_x = left_int; // 原画的 起始x坐标
                int srcImage_width = width + right_int; // 原画的 起始坐标

                int srcImage_y = up_int; // 原画的 起始y坐标
                int srcImage_high = high + down_int; // 原画的 起始y坐标

                double ratiox = 1.0;
                double ratioy = 1.0;

                ratiox = w * ratiox / width_input;
                ratioy = h * ratioy / height_input;

                // 缩小图片
                if (ratiox >= 1) {
                    if (ratioy < 1) {
                        ratiox = height_input * 1.0 / h;
                    } else {
                        if (ratiox > ratioy) {
                            ratiox = height_input * 1.0 / h;
                        } else {
                            ratiox = width_input * 1.0 / w;
                        }
                    }
                } else {
                    // 放大图片
                    if (ratioy < 1) {
                        if (ratiox > ratioy) {
                            ratiox = height_input * 1.0 / h;
                        } else {
                            ratiox = width_input * 1.0 / w;
                        }
                    } else {
                        ratiox = width_input * 1.0 / w;
                    }
                }

                // 子截图 先搞定
                // X的起始坐标 如果大于0的话 那么就使用原有的坐标系0
                // 如果小于0的话 说明x起始坐标需要移动到 Math.abs(left_int)
                int origin_subImage_x = left_int >= 0 ? 0 : Math.abs(left_int);
                int origin_subImage_y = up_int >= 0 ? 0 : Math.abs(up_int);

                int origin_subImage_width = width; // 默认为图片的宽度
                if (left_int < 0 && right_int < 0) {
                    origin_subImage_width = width + left_int + right_int;
                } else if (left_int < 0) {
                    origin_subImage_width = width + left_int;
                } else if (right_int < 0) {
                    origin_subImage_width = width + right_int;
                }

                int origin_subImage_high = high;
                if (up_int < 0 && down_int < 0) {
                    origin_subImage_high = high + up_int + down_int;
                } else if (up_int < 0) {
                    origin_subImage_high = high + up_int;
                } else if (down_int < 0) {
                    origin_subImage_high = high + down_int;
                }

                // AffineTransformOp op = new
                // AffineTransformOp(AffineTransform.getScaleInstance(ratiox, ratiox), null);
                // originImage = op.filter(originImage, null);
                System.out.println("width=" + width + "    high=" + high);

                System.out.println("up_int=" + up_int + "    down_int=" + down_int + "     left_int=" + left_int
                        + "     right_int=" + right_int);
                System.out.println("origin_subImage_x=" + origin_subImage_x + "    origin_subImage_y="
                        + origin_subImage_y + "  origin_subImage_width =" + origin_subImage_width
                        + "  origin_subImage_high=" + origin_subImage_high);

//                originImage = originImage.getSubimage(0, origin_subImage_y, width, origin_subImage_high);
//                originImage = originImage.getSubimage(origin_subImage_x, 0, origin_subImage_width, originImage.getHeight());

                // originImage = originImage.getSubimage(origin_subImage_x, origin_subImage_y,
                // origin_subImage_width, origin_subImage_high);

                BufferedImage whiteSpace_BuffImage = generalBufferedImage_WhitePicture(target_width, target_high);

                BufferedImage combined = new BufferedImage(target_width, target_high, BufferedImage.TYPE_INT_RGB);
                // paint both images, preserving the alpha channels
                Graphics g = combined.getGraphics();
//                g.setColor(new Color(255, 255, 255));
                try {

//                    int fixed_width = srcImage_width>width?width:srcImage_width;
//                    int fixed_high = srcImage_high>high?high:srcImage_high;
//                    System.out.println("src_width="+width +"    src_high="+high);
//                    System.out.println("WhitePicture_target_width="+target_width +"    WhitePicture_target_high="+target_high);
//                    System.out.println("up_int="+up_int +"    down_int="+down_int+"     left_int="+left_int+"     right_int="+ right_int);
//                    System.out.println("srcImage_x="+srcImage_x +"    srcImage_y="+srcImage_y+"   fixed_width="+fixed_width+ "  fixed_high="+ fixed_high);
//
//                    g.drawImage(originImage, srcImage_x,srcImage_y,fixed_width , fixed_high ,null);
//                    // Save as new image
//                    ImageIO.write(combined, "jpg", imageFile);

                    // ImageIO.write(originImage, "jpg", imageFile);
                    int big_rect_y = up_int >= 0 ? up_int : 0;
                    int big_rect_x = left_int >= 0 ? left_int : 0;

                    System.out.println("输出路径下宽:" + whiteSpace_BuffImage.getWidth() + "   输出路径下高:"
                            + whiteSpace_BuffImage.getHeight());
                    ImageUtil.cut(imageFile, imageFile, new Rectangle(origin_subImage_x, origin_subImage_y,
                            origin_subImage_width, origin_subImage_high));

                    // BufferedImage originImage = getBufferedImage(imageFile);
                    BufferedImage originImage_fixed = getBufferedImage(imageFile);
                    g.drawImage(whiteSpace_BuffImage, 0, 0, null);
                    g.drawImage(originImage_fixed, big_rect_x, big_rect_y, null);
                    System.out.println("big_rect_x = " + big_rect_x + "    big_rect_y=" + big_rect_y);
                    ImageIO.write(combined, "jpg", imageFile);

                } catch (Exception e) {
                    System.out.println("发生异常! ");

                } finally {
//                    if (g != null) {
//                        g.dispose();
//                    }
                }

            }

            System.out.println(" Img Padding 执行完成! ");

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        public BufferedImage getBufferedImage(File file) {
            Image img = null;
            try {
                img = ImageIO.read(file); // 构造Image对象
            } catch (Exception e) {
                System.out.println(e);
                return null;
            }

            int width = img.getWidth(null); // 得到源图宽
            int height = img.getHeight(null); // 得到源图长

//    return resizeFix(400, 492);
            return resize(img, width, height);
        }

        public BufferedImage resize(Image mImage, int w, int h) {
            // SCALE_SMOOTH 的缩略算法 生成缩略图片的平滑度的 优先级比速度高 生成的图片质量比较好 但速度慢
            BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
            Graphics g = image.getGraphics();
            try {
                g.drawImage(mImage, 0, 0, w, h, null); // 绘制缩小后的图
            } finally {
                if (g != null) {
                    g.dispose();
                }
            }
            return image;
            // File destFile = new File("C:\\temp\\456.jpg");
            // FileOutputStream out = new FileOutputStream(destFile); // 输出到文件流
            // // 可以正常实现bmp、png、gif转jpg
            // JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);
            // encoder.encode(image); // JPEG编码
            // out.close();
        }

        public BufferedImage generalBufferedImage_WhitePicture(int p_width, int p_heigh) {
            BufferedImage imgBuf = null;
            int width = p_width;
            int heigh = p_heigh;
            Color currentColor = new Color(255, 255, 255);
            /*
             *
             * BufferedImage bi = new BufferedImage(width,heigh,
             * BufferedImage.TYPE_INT_RGB);//INT精确度达到一定,RGB三原色，高度70,宽度150 //得到它的绘制环境(这张图片的笔)
             * Graphics2D g2 = (Graphics2D) bi.getGraphics(); int frontSize = 550;
             *
             * g2.setBackground(currentColor); g2.fillRect(0,0,width,heigh);//填充一个矩形
             * 左上角坐标(0,0),宽500,高500;填充整张图片 g2.fillRect(0,0,width,heigh);//填充整张图片(其实就是设置背景颜色)
             * g2.setColor(currentColor);
             *
             */

            imgBuf = new BufferedImage(width, heigh, BufferedImage.TYPE_INT_RGB);
            Graphics curGraphic = imgBuf.getGraphics();
            // 设置颜色
            curGraphic.setColor(currentColor);
            // 填充
            curGraphic.fillRect(0, 0, imgBuf.getWidth(), imgBuf.getHeight());

            return imgBuf;
            /*
             *
             * try { mCurFile.createNewFile(); ImageIO.write(imgBuf, "jpg", new
             * FileOutputStream(mCurFile));//保存图片 JPEG表示保存格式 //
             * System.out.println("创建 RGB "+"R="+r+"  G="+g+"  B="+b+" 图片成功！");
             *
             * } catch (Exception e) { System.out.println("创建 RGB 图片格式出现异常！"+
             * mCurFile.getAbsolutePath()); }
             */

        }

        String ruleTip(String type, int index, String batName, OS_TYPE curType) {
            String itemDesc = "";
            String desc_A = " 无输入参数 默认对本目录下的所有 png jpg  进行 20_20_20_20 上_下_左_右的裁剪";
            String desc_B = " 对给定的图片进行 20_20_20_20 上_下_左_右的裁剪  ";
            String desc_C = " 对给定的图片进行 200_0_0_0 上_下_左_右的裁剪(顶部增加200空白像素空间)  ";
            String desc_D = " 对给定的图片进行 0_0_0_200 上_下_左_右的裁剪(底部增加200空白像素空间)  ";
            String desc_E = " 对给定的图片进行 0_200_0_200 上_下_左_右的裁剪(底部增加200 右部增加200 空白像素空间)  ";
            String desc_F = " 对给定的图片进行 -100_-100_-100_-100 上_下_左_右的裁剪(上下左右 都裁剪100 空白像素空间)  ";
            String desc_G = " 对给定的图片进行 0_-125_0_0 上_下_左_右的裁剪( 底部裁剪125 像素空间)  ";
            String desc_H = " 对给定的图片进行 0_-110_0_0 上_下_左_右的裁剪( 底部裁剪110 像素空间)  ";
            itemDesc = batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "  20_20_20_20" + "    #### [索引 "
                    + index + "]  描述: " + desc_A + "\n";
            itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "  20_20_20_20" + "   <ImgFile>  "
                    + "    #### [索引 " + index + "]  描述: " + desc_B + "\n";
            itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "  200_0_0_0"
                    + "    <ImgFile>   #### [索引 " + index + "]  描述: " + desc_C + "\n";
            itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "  0_0_0_200"
                    + "    <ImgFile>   #### [索引 " + index + "]  描述: " + desc_D + "\n";
            itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "  0_200_0_200"
                    + "    <ImgFile>   #### [索引 " + index + "]  描述: " + desc_E + "\n";
            itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "  -100_-100_-100_-100"
                    + "    <ImgFile>   #### [索引 " + index + "]  描述: " + desc_F + "\n";
            itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "  0_-125_0_0"
                    + "    <ImgFile>   #### [索引 " + index + "]  描述: " + desc_G + "\n";
            itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "  0_-110_0_0"
                    + "    <ImgFile>   #### [索引 " + index + "]  描述: " + desc_H + "\n";

            return itemDesc;

        }

    }

    class Rename_Img_WithSize_Rule_21 extends Basic_Rule {

        ArrayList<String> fliterTypeList;
        ArrayList<File> mSrcFileImage; // 符合 过滤 条件的 当前目录的文件夹的集合
        boolean isPortLandNamed; // 是否 以 port 和 Name 添加前缀

        boolean isClearBlank; // 是否是把当前目录的文件中包含的空格去除 另外的操作逻辑

        Rename_Img_WithSize_Rule_21() {
            super("#", 21, 4); //
            fliterTypeList = new ArrayList<String>();
            mSrcFileImage = new ArrayList<File>();
            isPortLandNamed = false;
            isClearBlank = false;

        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            // TODO Auto-generated method stub
            boolean isEmptyTypeInput = false;
            for (int i = 0; i < inputParamList.size(); i++) {
                String inputParam = inputParamList.get(i);

                if (inputParam.contains("portland_true")) {
                    isPortLandNamed = true;

                }

                if (inputParam.contains("clearblank_true")) {
                    isClearBlank = true;

                }

                boolean isGifInput = false;
                if (inputParam.contains("gif")) {
                    fliterTypeList.add(".gif");
                    isGifInput = true;
                }

                boolean isJpgInput = false;
                if (inputParam.contains("jpg")) {
                    fliterTypeList.add(".jpg");
                    isJpgInput = true;
                }

                boolean isPngInput = false;
                if (inputParam.contains("png")) {
                    fliterTypeList.add(".png");
                    isPngInput = true;
                }

                boolean isWebpInput = false;
                if (inputParam.contains("webp")) {
                    fliterTypeList.add(".webp");
                    isWebpInput = true;
                }

                isEmptyTypeInput = isEmptyTypeInput || !(isGifInput || isWebpInput || isPngInput || isJpgInput);
                if (isEmptyTypeInput) {
                    fliterTypeList.add(".webp");
                    fliterTypeList.add(".jpg");
                    fliterTypeList.add(".png");
                    fliterTypeList.add(".gif");
                }

            }

            if (isClearBlank) {
                fliterTypeList.clear();
                fliterTypeList.add("*");
            }

            System.out.println("isPortLandNamed = " + isPortLandNamed + "  isEmptyTypeInput=" + isEmptyTypeInput);

            return super.initParamsWithInputList(inputParamList);
        }

        /*
         * @Override boolean initParams4InputParam(String inputParam) { boolean
         * isEmptyTypeInput = false;
         *
         * boolean isGifInput = false; if (inputParam.contains("gif")) {
         * fliterTypeList.add(".gif"); isGifInput = true; }
         *
         * boolean isJpgInput = false; if (inputParam.contains("jpg")) {
         * fliterTypeList.add(".jpg"); isJpgInput = true; }
         *
         * boolean isPngInput = false; if (inputParam.contains("png")) {
         * fliterTypeList.add(".png"); isPngInput = true; }
         *
         * boolean isWebpInput = false; if (inputParam.contains("webp")) {
         * fliterTypeList.add(".webp"); isWebpInput = true; }
         *
         * isEmptyTypeInput = !(isGifInput || isWebpInput || isPngInput || isJpgInput);
         * if (isEmptyTypeInput) { fliterTypeList.add(".webp");
         * fliterTypeList.add(".jpg"); fliterTypeList.add(".png");
         * fliterTypeList.add(".gif"); }
         *
         * return super.initParams4InputParam(inputParam); }
         */
        boolean checkInFlitterList(String fileName) {
            boolean result = false;

            for (int i = 0; i < fliterTypeList.size(); i++) {
                if (fileName.endsWith(fliterTypeList.get(i))) {
                    result = true;
                    break;
                }
            }
            return result;
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            if (isClearBlank) {
                int blankIndex = 0;

                for (int i = 0; i < curRealFileList.size(); i++) {
                    File fileItem = curRealFileList.get(i);
                    String fileName = fileItem.getName();
                    String fileName_lower = fileName.toLowerCase();
                    if (fileItem.isDirectory()) {
                        continue;
                    }

                    if (fileName.contains(" ")) {
                        // 去除 名称 中的 空格
                        String newName = fileName.replace(" ", "");
                        tryReName(fileItem, newName);
                        System.out.println(
                                "去除空格文件[" + blankIndex + "] oldname[" + fileName + "]  newname[" + newName + "]");
                        blankIndex++;
                    }

                }

                System.out.println("RealFile Clear Blank  实体文件 清除空格 执行完成! ");

                return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);

            }

            for (int i = 0; i < curRealFileList.size(); i++) {
                File fileItem = curRealFileList.get(i);
                String fileName = fileItem.getName();
                String fileName_lower = fileName.toLowerCase();

                boolean isTypeInList = checkInFlitterList(fileName_lower);
                if (isTypeInList) {
                    mSrcFileImage.add(fileItem);
                }
            }
            StringBuffer typtSb = new StringBuffer();
            for (int i = 0; i < mSrcFileImage.size(); i++) {
                typtSb.append(mSrcFileImage.get(i) + " ");
            }
            System.out.println("══════════开始执行 " + typtSb.toString() + "类型 1960x1280 宽x高操作 " + "══════════");

            for (int i = 0; i < mSrcFileImage.size(); i++) {
                File imageFile = mSrcFileImage.get(i);
                String fileName = imageFile.getName();
                ImageIcon imageIcon = new ImageIcon(imageFile.getAbsolutePath());
                int high = imageIcon.getIconHeight();
                int width = imageIcon.getIconWidth();

                boolean isPort = getRotateAngleForPhoto(imageFile.getAbsolutePath());

                if (!isPort) {
                    int temp = high;
                    high = width;
                    width = temp;
                }

                // 当前文件的 宽高
                String str_width_x_high = calculateSizeStr(width, high);
                String newName = str_width_x_high + "_" + fileName;
                if (isPortLandNamed) {
                    if (width > high) {
                        newName = "Land_" + newName;
                    } else {
                        newName = "Port_" + newName;

                    }
                }
                tryReName(imageFile, newName);
                System.out.println("File[" + i + "] =  SrcName【" + fileName + "】  TargetName【" + newName + "】");

            }

            System.out.println("Img Size Rename 执行完成! ");

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        // 宽x高 1000x0900 1280x0720
        String calculateSizeStr(int widthValue, int highValue) {
            String sizeStr = "";
            int fixWidthValue = 0;
            int fixHighValue = 0;

            if (widthValue > 9999) { // 宽高最大只能 9999 大了 受不了
                fixWidthValue = 9999;
            } else {
                fixWidthValue = widthValue;
            }
            if (highValue > 9999) { // 宽高最大只能 9999 大了 受不了
                fixHighValue = 9999;
            } else {
                fixHighValue = highValue;
            }
            String widthStr = addForZeroStr(fixWidthValue);
            String highStr = addForZeroStr(fixHighValue);

            // fixWidthValue 和 fixHighValue 进行补零操作

            return widthStr + "x" + highStr;

        }

        String addForZeroStr(int value) {
            String valueStr = "";
            if (value > 9999) {
                valueStr = "9999";
            } else if (value >= 1000) {
                valueStr = (value + "").trim();
            } else if (value >= 100) {
                valueStr = ("0" + value).trim();
            } else if (value >= 10) {
                valueStr = ("00" + value).trim();
            } else if (value >= 0) {
                valueStr = ("000" + value).trim();
            }
            return valueStr;
        }

        String ruleTip(String type, int index, String batName, OS_TYPE curType) {
            String itemDesc = "";
            String desc_A = " 对当前目录下的图片文件 指定类型图片(参数输入)(png)(jpg)(webp)(gif)进行 进行以 宽x高 类似 1960x1280_原名 的操作";
            String desc_B = " 对当前目录下的图片文件 指定类型图片(参数输入)(png)(jpg)(webp)(gif)进行 进行以 宽x高 类似 Land_1960x1280_原名  Port_600x900 的操作";

            if (curType == OS_TYPE.Windows) {
                itemDesc = batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "" + "    #### [索引 " + index
                        + "]  描述: " + desc_A + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "_jpg" + "    #### [索引 "
                        + index + "]  描述: " + desc_A + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "_png" + "    #### [索引 "
                        + index + "]  描述: " + desc_A + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "_gif" + "    #### [索引 "
                        + index + "]  描述: " + desc_A + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "_webp" + "    #### [索引 "
                        + index + "]  描述: " + desc_A + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "_jpg_png" + "    #### [索引 "
                        + index + "]  描述: " + desc_A + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "_jpg_png_gif_webp"
                        + "    #### [索引 " + index + "]  描述: " + desc_A + "\n";

                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "_jpg_png_gif_webp"
                        + "  portland_true " + "    #### [索引 " + index + "]  描述: " + desc_B + "\n";

                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "" + "  clearblank_true "
                        + "    #### [索引 " + index + "]  描述: " + "## 清除当前目录下的包含有空格的文件名称 去除空格" + "\n";

            } else {
                itemDesc = batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "" + "    #### [索引 " + index
                        + "]  描述: " + desc_A + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "_jpg" + "    #### [索引 "
                        + index + "]  描述: " + desc_A + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "_png" + "    #### [索引 "
                        + index + "]  描述: " + desc_A + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "_gif" + "    #### [索引 "
                        + index + "]  描述: " + desc_A + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "_webp" + "    #### [索引 "
                        + index + "]  描述: " + desc_A + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "_jpg_png" + "    #### [索引 "
                        + index + "]  描述: " + desc_A + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "_jpg_png_gif_webp"
                        + "    #### [索引 " + index + "]  描述: " + desc_A + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "_jpg_png_gif_webp"
                        + "    #### [索引 " + index + "]  描述: " + desc_B + "\n";

                itemDesc += batName.trim() + Cur_Batch_End + "  " + type + "_" + index + "" + "  clearblank_true "
                        + "    #### [索引 " + index + "]  描述: " + "## 清除当前目录下的包含有空格的文件名称 去除空格" + "\n";

            }
            return itemDesc;

        }

    }

    class Land_Port_Classify_Rule_20 extends Basic_Rule {

        boolean isTimeStampDir = true; // Land_Port 新建的文件夹是否存有时间戳

        // false ---》 对 png 和 jpg 文件进行过滤
        boolean isGifClassfly = false; // true ---》 只对 gif 文件 进行 过滤

        ArrayList<File> mSrcFileImage; // Shell 目录下原始文件目录
        ArrayList<File> mLandImageFileList; // Shell/Land_Port_TimeStamp/Land/ 文件夹下的文件
        ArrayList<File> mPortImageFileList; // Shell/Land_Port_TimeStamp/Land/ 文件夹下的文件
        HashMap<File, File> src_target_FileMap; // src为 原始文件 target为目标文件 进行 copy时 会使用到

        Land_Port_Classify_Rule_20() {
            super("#", 20, 4); //
            isTimeStampDir = true;

            mSrcFileImage = new ArrayList<File>();
            mLandImageFileList = new ArrayList<File>();
            mPortImageFileList = new ArrayList<File>();

            src_target_FileMap = new HashMap<File, File>();
        }

        @Override
        boolean initParams4InputParam(String inputParam) {
            if (inputParam.contains("notime")) {
                isTimeStampDir = false;
            } else {
                isTimeStampDir = true;
            }

            if (inputParam.contains("gif")) {
                isGifClassfly = true;
            } else {
                isGifClassfly = false;
            }

            return super.initParams4InputParam(inputParam);
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            for (int i = 0; i < curRealFileList.size(); i++) {
                File fileItem = curRealFileList.get(i);
                String fileName = fileItem.getName();
                String fileName_lower = fileName.toLowerCase();
                if (isGifClassfly) {
                    if (fileName_lower.endsWith(".gif")) {
                        mSrcFileImage.add(fileItem);
                    }
                } else {
                    if (fileName_lower.endsWith(".jpg") || fileName_lower.endsWith(".png")) {
                        mSrcFileImage.add(fileItem);
                    }
                }

            }

            for (int i = 0; i < mSrcFileImage.size(); i++) {
                File imageFile = mSrcFileImage.get(i);

                int high = 0;
                int width = 0;
                ImageIcon imageIcon = new ImageIcon(imageFile.getAbsolutePath());
                high = imageIcon.getIconHeight();
                width = imageIcon.getIconWidth();
                boolean isPort = getRotateAngleForPhoto(imageFile.getAbsolutePath());

                if (!isPort) {
                    int temp = high;
                    high = width;
                    width = temp;
                }
                /*
                 * try { BufferedImage sourceImg = ImageIO.read(new
                 * FileInputStream(imageFile.getAbsolutePath())); high = sourceImg.getHeight();
                 * width = sourceImg.getWidth(); } catch (IOException e) { e.printStackTrace();
                 * }
                 */

                System.out.println("1_Rule20_Land_Port Index[" + i + "]  width[" + width + "]" + " high[" + high
                        + "]   high >= width[" + (high >= width) + "]  Path[" + imageFile.getAbsolutePath() + "]");
                if (high >= width) {
                    mPortImageFileList.add(imageFile);
                } else {
                    mLandImageFileList.add(imageFile);
                }
            }

            String PreDirName = "Land_Port_";
            if (isGifClassfly) {
                PreDirName += "Gif";
            } else {
                PreDirName += "Img";
            }

            String dir_1 = isTimeStampDir ? PreDirName + "_" + getTimeStamp() : PreDirName;
            String dir_1_Land_str = dir_1 + File.separator + "Land";
            String dir_1_Port_str = dir_1 + File.separator + "Port";
            File dir_Port = new File(curDirFile.getAbsoluteFile() + File.separator + dir_1_Port_str);
            File dir_Land = new File(curDirFile.getAbsoluteFile() + File.separator + dir_1_Land_str);
            System.out.println("══════════" + dir_Land.getAbsolutePath() + "  Land文件开始过滤执行" + "══════════");
            TryClassifyImage(mLandImageFileList, dir_Land);
            System.out.println("══════════" + dir_Port.getAbsolutePath() + "  Port文件开始过滤执行" + "══════════");
            TryClassifyImage(mPortImageFileList, dir_Port);

            System.out.println("zzfile_3" + Cur_Batch_End + "  " + curDirFile.getAbsoluteFile() + File.separator + dir_1
                    + "                        ####  过滤 Land  Port 文件夹已经生成！");

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        void TryClassifyImage(ArrayList<File> srcFileImageList, File targetDirFile) {
            if (!targetDirFile.exists()) {
                targetDirFile.mkdirs();
            }
            for (int i = 0; i < srcFileImageList.size(); i++) {
                File imgFile = srcFileImageList.get(i);
                String fileName = imgFile.getName();
                File targetFile = new File(targetDirFile.getAbsoluteFile() + File.separator + fileName);

                fileCopy(imgFile, targetFile);
                System.out.println("File[" + i + "] = " + "SrcFile【" + imgFile.getAbsolutePath() + "】" + " TargetFile【"
                        + targetFile.getAbsolutePath() + "】");
            }

        }

        String ruleTip(String type, int index, String batName, OS_TYPE curType) {
            String itemDesc = "";
            String desc_A = " 对当前目录下的图片文件(png)(jpg)进行 Land横屏 和 Port竖直 分类 并放置在新建Land_Port_Img_TimeStamp 文件夹中";
            String desc_B = " 对当前目录下的图片文件(png)(jpg)进行 Land横屏 和 Port竖直 分类 并放置在新建Land_Port_Img文件夹中(文件夹名称固定)";
            String desc_C = " 对当前目录下的图片文件(gif)进行 Land横屏 和 Port竖直 分类 并放置在新建Land_Port_Gif_TimeStamp 文件夹中";
            String desc_D = " 对当前目录下的图片文件(gif)进行 Land横屏 和 Port竖直 分类 并放置在新建Land_Port_Gif 文件夹中(文件夹名称固定)";

            if (curType == OS_TYPE.Windows) {
                itemDesc = batName.trim() + ".bat  " + type + "_" + index + "" + "    #### [索引 " + index + "]  描述: "
                        + desc_A + "\n";
                itemDesc += batName.trim() + ".bat  " + type + "_" + index + "_notime" + "    #### [索引 " + index
                        + "]  描述: " + desc_B + "\n";
                itemDesc += batName.trim() + ".bat  " + type + "_" + index + "_gif" + "    #### [索引 " + index
                        + "]  描述: " + desc_C + "\n";
                itemDesc += batName.trim() + ".bat  " + type + "_" + index + "_gif_notime" + "    #### [索引 " + index
                        + "]  描述: " + desc_D + "\n";

            } else {
                itemDesc = batName.trim() + Cur_Batch_End + " " + type + "_" + index + "       ### [索引 " + index
                        + "]  描述:" + desc_A + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + " " + type + "_" + index + "_notime" + "       ### [索引 "
                        + index + "]  描述:" + desc_B + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + " " + type + "_" + index + "_gif" + "       ### [索引 "
                        + index + "]  描述:" + desc_C + "\n";
                itemDesc += batName.trim() + Cur_Batch_End + " " + type + "_" + index + "_gif_notime"
                        + "       ### [索引 " + index + "]  描述:" + desc_C;
            }

            return itemDesc;
        }

    }

    // 把当前 文件 使用 默认的 密码 752025 进行 压缩 成 7z 文件
    class ExpressTo7z_PassWord_Rule_19 extends Basic_Rule {

        ArrayList<String> inputTypeList;
        // zrule_apply_G2.bat #_14 jpg 把当前所有的jpg格式文件生成快捷方式到 jpg_时间戳 文件夹内

        // 可能从参数输入的 单一文件
        ArrayList<File> inputParamFileList;
        File z7exeFile;

        boolean isSearchAllFile2CurDirFlag = false;

        ExpressTo7z_PassWord_Rule_19() {
            super("#", 19, 3);
            inputTypeList = new ArrayList<String>();
            inputParamFileList = new ArrayList<File>();
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {
                String strInput = inputParamList.get(i);
                if (strInput.equals(firstInputIndexStr)) {
                    continue;
                }
                if (!strInput.startsWith(".")) {
                    inputTypeList.add("." + strInput.trim());
                } else {
                    inputTypeList.add(strInput.trim());
                }

                File tempFile = new File(curDirPath + File.separator + strInput);
                if (tempFile.exists() && !tempFile.isDirectory()) {
                    inputParamFileList.add(tempFile);

                }
            }

            if (inputTypeList.size() == 0 && inputParamFileList.size() == 0) {
                isSearchAllFile2CurDirFlag = true;

            }

            z7exeFile = new File(Win_Lin_Mac_ZbinPath + File.separator + "7z" + curOS_ExeTYPE);
            System.out.println("Win_Lin_Mac_ZbinPath = " + Win_Lin_Mac_ZbinPath);
            if (!z7exeFile.exists() || z7exeFile.isDirectory()) {
                System.out.println(
                        "当前 7z 压缩程序不存在! 请检查当前的 7z程序 一般位于 Desktop/zbin/win_zbin/  mac_zbin lin_zbin 中  z7exeFile = "
                                + z7exeFile.getAbsolutePath());
                return false;
            }
            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {

            SimpleDateFormat df = new SimpleDateFormat("MMdd_HHmmss");// 设置日期格式
//            SimpleDateFormat df_hms = new SimpleDateFormat("HHmmss");//设置日期格式
            Date curDate = new Date();
            String date = df.format(curDate);
//            String preHMS = df.format(df_hms);

            if (isSearchAllFile2CurDirFlag) {
                // 比那里所有 类型的 文件 并 重新命名
                try7zExpressOperation(fileTypeMap);

            } else {

                for (int i = 0; i < inputTypeList.size(); i++) {
                    String type = inputTypeList.get(i);

                    ArrayList<File> targetFileList = fileTypeMap.get(type);

                    if (targetFileList == null || targetFileList.size() == 0) {
                        System.out.println(" 当前路径 " + curDirPath + " 不存在类型 " + type + "的文件!");
                        continue;
                    }

                    for (int j = 0; j < targetFileList.size(); j++) {
                        File targetTypeFile = targetFileList.get(j);
                        String originName = targetTypeFile.getName();
                        String noPointName = getFileNameNoPoint(targetTypeFile);
//                        String mdName = getMD5Three(targetTypeFile.getAbsolutePath());
//                        String mdtype = getFileTypeWithPoint(targetTypeFile.getName());
//                        String new_md_Name = mdName+mdtype;
//                        tryReName(targetTypeFile,new_md_Name);

                        String z7_command = z7exeFile.getAbsolutePath() + "  a -tzip  " + noPointName + ".7z" + " -p"
                                + strZ7DefaultKey_PSW_Rule19 + "  " + originName;
                        System.out.println("执行\n");
                        System.out.println(z7_command);
                        execCMD(z7_command);
                    }

                }

                for (int i = 0; i < inputParamFileList.size(); i++) {
                    File targetTypeFile = inputParamFileList.get(i);
                    String originName = targetTypeFile.getName();
                    String noPointName = getFileNameNoPoint(targetTypeFile);

//                    tryReName(targetTypeFile,new_md_Name);

                    String z7_command = z7exeFile.getAbsolutePath() + "  a -tzip  " + noPointName + ".7z" + " -p"
                            + strZ7DefaultKey_PSW_Rule19 + "  " + originName;

                    System.out.println("执行\n");
                    System.out.println(z7_command);

                    execCMD(z7_command);

                }

            }

            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        @SuppressWarnings("unchecked")
        boolean try7zExpressOperation(HashMap<String, ArrayList<File>> arrFileMap) {
            boolean executeFlag = false;
            Map.Entry<String, ArrayList<File>> entry;

            if (arrFileMap != null) {
                Iterator iterator = arrFileMap.entrySet().iterator();
                while (iterator.hasNext()) {
                    entry = (Map.Entry<String, ArrayList<File>>) iterator.next();
                    String typeStr = entry.getKey(); // Map的Value
                    ArrayList<File> fileArr = entry.getValue(); // Map的Value

                    for (int i = 0; i < fileArr.size(); i++) {
                        File curFile = fileArr.get(i);
//                        String curFileName = curFile.getName();
//                        String mdName = getMD5Three(curFile.getAbsolutePath());
//                        String mdtype = getFileTypeWithPoint(curFile.getName());
//                        String new_md_Name = mdName+mdtype;
//                        tryReName(curFile,new_md_Name);

                        String originName = curFile.getName();
                        String noPointName = getFileNameNoPoint(curFile);

                        String z7_command = z7exeFile.getAbsolutePath() + "  a -tzip  " + noPointName + ".7z" + " -p"
                                + strZ7DefaultKey_PSW_Rule19 + "  " + originName;

                        System.out.println("执行\n");
                        System.out.println(z7_command);
                        execCMD(z7_command);
                    }

                }
            }

            return executeFlag;
        }

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name + " #_19            ### 把当前文件夹下所有文件单独 压缩为 .7z 文件 文件名不变化   密码默认为 752025 !  "
                    + "\n" + Cur_Bat_Name
                    + " #_19  mp4          ###  把当前文件夹下 .mp4   单独 压缩为 .7z 文件 文件名不变化   密码默认为 752025 !   " + "\n"
                    + Cur_Bat_Name + " #_19  .mp4         ### 把当前文件夹下 .mp4  单独 压缩为 .7z 文件 文件名不变化   密码默认为 752025 !   "
                    + "\n" + Cur_Bat_Name
                    + " #_19  .gif         ### 把当前文件夹下 .gif  单独 压缩为 .7z 文件 文件名不变化   密码默认为 752025 !   " + "\n"
                    + Cur_Bat_Name + " #_19  png          ### 把当前文件夹下 .png  单独 压缩为 .7z 文件 文件名不变化   密码默认为 752025 !   "
                    + "\n" + Cur_Bat_Name
                    + " #_19  zip  7z      ### 把当前文件夹下  .zip  .7z   单独 压缩为 .7z 文件 文件名不变化   密码默认为 752025 !   " + "\n"
                    + Cur_Bat_Name
                    + " #_19  .zip .7z     ###  把当前文件夹下  .zip  .7z   单独 压缩为 .7z 文件 文件名不变化   密码默认为 752025 !   " + "\n"
                    + Cur_Bat_Name + " #_19  jpg          ###  把当前文件夹下  .jpg   单独压缩为 .7z 文件 文件名不变化   密码默认为 752025 !   "
                    + "\n" + Cur_Bat_Name
                    + " #_19  .jpg  .png  .webp .gif                          ### 把当前文件夹下  .jpg  .png  .webp .gif  单独压缩为 .7z 文件 文件名不变化   密码默认为 752025 !   "
                    + "\n" + Cur_Bat_Name
                    + " #_19  .mp4  .avi   .wmv .rmvb  .flv .3gp              ### 把当前文件夹下  .mp4  .avi   .wmv .rmvb  .flv .3gp  单独压缩为 .7z 文件 文件名不变化   密码默认为 752025 !   "
                    + "\n" + Cur_Bat_Name
                    + " #_19  .jpg  .png  .gif  .webp .mp4 .avi .flv .wmv     ### 把当前文件夹下  .jpg  .png  .gif  .webp .mp4 .avi .flv .wmv  单独压缩为 .7z 文件 文件名不变化   密码默认为 752025 !   "
                    + "\n" + Cur_Bat_Name
                    + " #_19  <指定文件A> <指定文件B>          ### 把当前文件夹下 指定文件名称 单独压缩为 .7z 文件 文件名不变化   密码默认为 752025 !   \"+ "

                    ;
        }

    }

    // operation_type 操作类型 1--读取文件内容字符串 进行修改 2--对文件对文件内容(字节)--进行修改 3.对全体子文件进行的随性的操作
    // 属性进行修改(文件名称)
//     // 4.对当前子文件(包括子目录 子文件 --不包含孙目录 孙文件) 5. 从shell 中获取到的路径 去对某一个文件进行操作

    // 以文件的md数字进行重命名 文件 改名字 改后缀 不影响 这个属性
    class MD_ReName_Rule_18 extends Basic_Rule {

        ArrayList<String> inputTypeList;
        // zrule_apply_G2.bat #_14 jpg 把当前所有的jpg格式文件生成快捷方式到 jpg_时间戳 文件夹内

        // 可能从参数输入的 单一文件
        ArrayList<File> inputParamFileList;

        boolean isSearchAllFile2CurDirFlag = false;

        MD_ReName_Rule_18() {
            super("#", 18, 3);
            inputTypeList = new ArrayList<String>();
            inputParamFileList = new ArrayList<File>();
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {
                String strInput = inputParamList.get(i);
                if (strInput.equals(firstInputIndexStr)) {
                    continue;
                }
                if (!strInput.startsWith(".")) {
                    inputTypeList.add("." + strInput.trim());
                } else {
                    inputTypeList.add(strInput.trim());
                }

                File tempFile = new File(curDirPath + File.separator + strInput);
                if (tempFile.exists() && !tempFile.isDirectory()) {
                    inputParamFileList.add(tempFile);

                }
            }

            if (inputTypeList.size() == 0 && inputParamFileList.size() == 0) {
                isSearchAllFile2CurDirFlag = true;

            }
            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {

            SimpleDateFormat df = new SimpleDateFormat("MMdd_HHmmss");// 设置日期格式
//            SimpleDateFormat df_hms = new SimpleDateFormat("HHmmss");//设置日期格式
            Date curDate = new Date();
            String date = df.format(curDate);
//            String preHMS = df.format(df_hms);

            if (isSearchAllFile2CurDirFlag) {
                // 比那里所有 类型的 文件 并 重新命名
                tryReNameOperation(fileTypeMap);

            } else {

                for (int i = 0; i < inputTypeList.size(); i++) {
                    String type = inputTypeList.get(i);

                    ArrayList<File> targetFileList = fileTypeMap.get(type);

                    if (targetFileList == null || targetFileList.size() == 0) {
                        System.out.println(" 当前路径 " + curDirPath + " 不存在类型 " + type + "的文件!");
                        continue;
                    }

                    for (int j = 0; j < targetFileList.size(); j++) {
                        File targetTypeFile = targetFileList.get(j);
                        String originName = targetTypeFile.getName();
                        String mdName = getMD5Three(targetTypeFile.getAbsolutePath());
                        String mdtype = getFileTypeWithPoint(targetTypeFile.getName());
                        String new_md_Name = mdName + mdtype;
                        tryReName(targetTypeFile, new_md_Name);

                    }

                }

                for (int i = 0; i < inputParamFileList.size(); i++) {
                    File targetTypeFile = inputParamFileList.get(i);
                    String originName = targetTypeFile.getName();
                    String mdName = getMD5Three(targetTypeFile.getAbsolutePath());
                    String mdtype = getFileTypeWithPoint(targetTypeFile.getName());
                    String new_md_Name = mdName + mdtype;
                    tryReName(targetTypeFile, new_md_Name);
                }

            }

            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        @SuppressWarnings("unchecked")
        boolean tryReNameOperation(HashMap<String, ArrayList<File>> arrFileMap) {
            boolean executeFlag = false;
            Map.Entry<String, ArrayList<File>> entry;

            if (arrFileMap != null) {
                Iterator iterator = arrFileMap.entrySet().iterator();
                while (iterator.hasNext()) {
                    entry = (Map.Entry<String, ArrayList<File>>) iterator.next();
                    String typeStr = entry.getKey(); // Map的Value
                    ArrayList<File> fileArr = entry.getValue(); // Map的Value

                    for (int i = 0; i < fileArr.size(); i++) {
                        File curFile = fileArr.get(i);
//                        String curFileName = curFile.getName();
                        String mdName = getMD5Three(curFile.getAbsolutePath());
                        String mdtype = getFileTypeWithPoint(curFile.getName());
                        String new_md_Name = mdName + mdtype;
                        tryReName(curFile, new_md_Name);
                    }

                }
            }

            return executeFlag;
        }

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name
                    + " #_18            ### 把当前文件夹下 文件全部改名为 MD5属性命名的文件 【(32)位16进制.type】 32aeefa9924afb8be0da50976f1a2405.mp4 !  "
                    + "\n" + Cur_Bat_Name
                    + " #_18  mp4          ###  把当前文件夹下 .mp4 文件全部改名为 MD5属性命名的文件 【(32)位16进制.type】 !   " + "\n"
                    + Cur_Bat_Name + " #_18  .mp4         ### 把当前文件夹下 .mp4 文件全部改名为 MD5属性命名的文件 【(32)位16进制.type】 !   "
                    + "\n" + Cur_Bat_Name
                    + " #_18  .gif         ### 把当前文件夹下 .gif 文件全部改名为 MD5属性命名的文件 【(32)位16进制.type】 32aeefa9924afb8be0da50976f1a2405.gif !   "
                    + "\n" + Cur_Bat_Name
                    + " #_18  png          ### 把当前文件夹下 .png 文件全部改名为 MD5属性命名的文件 【(32)位16进制.type】 !   " + "\n"
                    + Cur_Bat_Name
                    + " #_18  zip  7z      ### 把当前文件夹下  .zip  .7z  文件全部改名为 MD5属性命名的文件 【(32)位16进制.type】 !   32aeefa9924afb8be0da50976f1a2405.7z  "
                    + "\n" + Cur_Bat_Name
                    + " #_18  .zip .7z     ###  把当前文件夹下  .zip  .7z  文件全部改名为 MD5属性命名的文件 【(32)位16进制.type】 !   32aeefa9924afb8be0da50976f1a2405.7z "
                    + "\n" + Cur_Bat_Name
                    + " #_18  jpg          ###  把当前文件夹下  .jpg  文件全部改名为 MD5属性命名的文件 【(32)位16进制.type】 !" + "\n"
                    + Cur_Bat_Name
                    + " #_18  .jpg  .png  .webp .gif                          ### 把当前文件夹下  .jpg  .png  .webp .gif 文件全部改名为 MD5属性命名的文件 【(32)位16进制.type】 "
                    + "\n" + Cur_Bat_Name
                    + " #_18  .mp4  .avi   .wmv .rmvb  .flv .3gp              ### 把当前文件夹下  .mp4  .avi   .wmv .rmvb  .flv .3gp 文件全部改名为 MD5属性命名的文件 【(32)位16进制.type】 "
                    + "\n" + Cur_Bat_Name
                    + " #_18  .jpg  .png  .gif  .webp .mp4 .avi .flv .wmv     ### 把当前文件夹下  .jpg  .png  .gif  .webp .mp4 .avi .flv .wmv 文件全部改名为 MD5属性命名的文件 【(32)位16进制.type】 "
                    + "\n" + Cur_Bat_Name
                    + " #_18  <指定文件A> <指定文件B>          ### 把当前文件夹下 指定文件名称  文件全部改名为 MD5属性命名的文件 【(32)位16进制.type】 "

                    ;
        }

    }

    public static String getMD5Three(String path) {
        BigInteger bi = null;
        try {
            byte[] buffer = new byte[8192];
            int len = 0;
            MessageDigest md = MessageDigest.getInstance("MD5");
            File f = new File(path);
            FileInputStream fis = new FileInputStream(f);
            while ((len = fis.read(buffer)) != -1) {
                md.update(buffer, 0, len);
            }
            fis.close();
            byte[] b = md.digest();
            bi = new BigInteger(1, b);
        } catch (NoSuchAlgorithmException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        } catch (Exception e) {
            e.printStackTrace();
        }
        if (bi == null) {
            return "MD5_Null";
        }
        return bi.toString(16);
    }
    // operation_type 操作类型 1--读取文件内容字符串 进行修改 2--对文件对文件内容(字节)--进行修改 3.对全体子文件进行的随性的操作
    // 属性进行修改(文件名称)
//     // 4.对当前子文件(包括子目录 子文件 --不包含孙目录 孙文件) 5. 从shell 中获取到的路径 去对某一个文件进行操作

    class Make_ZRuleDir_Rule_17 extends Basic_Rule {
        ArrayList<String> dirNameList;

        Make_ZRuleDir_Rule_17() {
            super("#", 17, 4); //
            dirNameList = new ArrayList<String>();
            dirNameList.add("0_Temp_Dir");
            dirNameList.add("1_C_Install_Dir");
            dirNameList.add("1_Loveon_Place");
            dirNameList.add("2_WebSite_Download");
            dirNameList.add("3_BaiduNetdiskDownload");
            dirNameList.add("4_Software");
            dirNameList.add("5_WorkCodePlace");
            dirNameList.add("6_Jpg_Video");
            dirNameList.add("7_Txt_PDF_DOC_Book");
            dirNameList.add("8_Git_Dir");
            dirNameList.add("9_Version");
            dirNameList.add("10_Jira_Work");
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            if (curDirFile != null) {
                for (int i = 0; i < dirNameList.size(); i++) {
                    String dirName = dirNameList.get(i);
                    String dirAbsPath = curDirFile.getAbsolutePath() + File.separator + dirName;
                    File newDirTemp = new File(dirAbsPath);
                    newDirTemp.mkdirs();
                    System.out.println("创建目录 " + newDirTemp.getAbsolutePath() + " 成功! ");
                }
                return null;
            } else {
                System.out.println("Make_ZRuleDir_Rule_17   当前获取到的Shell目录为空!   无法创建 Z规则文件夹!  ");
            }
            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        String ruleTip(String type, int index, String batName, OS_TYPE curType) {
            String itemDesc = "";
            String desc_true = " 在当前目录下创建 固定的文件夹 ZDir -> 《 0_Loveon_Place 1_C_Install_Dir  2_WebSite_Download  3_BaiduNetdiskDownload  4_Software  5_WorkPlace   6_Jpg_Video  7_Txt_PDF_DOC_Book  0_Temp_Dir  9_Version  10_Jira_Work  ";

            if (curType == OS_TYPE.Windows) {
                itemDesc = batName.trim() + ".bat  " + type + "_" + index + "       【 创建 Z规则目录】 [索引 " + index
                        + "]  描述: " + desc_true + "\n";

            } else {
                itemDesc = batName.trim() + ".sh " + type + "_" + index + "       【 创建 Z规则目录】   [索引 " + index + "]  描述:"
                        + desc_true;
            }

            return itemDesc;
        }

    }

    class File_TimeName_Rule_16 extends Basic_Rule {

        // key = type value = 符合过滤文件规则的名称的文件的集合
        // HashMap<String, ArrayList<File>> arrFileMap;
        boolean keepOriginalName = false;
        int inputBeginIndex = 0;

        // true 1.jpg 2,jpg 3.png 4.png 依次命名
        // false 1.jpg 2,jpg 1.png 2.png 类型来命名
        boolean isOrder = false;

        File_TimeName_Rule_16() {
            super("#", 16, 3); //
        }

        @SuppressWarnings("unchecked")
        boolean tryReNameOperation(HashMap<String, ArrayList<File>> arrFileMap) {
            boolean executeFlag = false;
            Map.Entry<String, ArrayList<File>> entry;
            int fileOrderIndex = 0;

            if (arrFileMap != null) {
                Iterator iterator = arrFileMap.entrySet().iterator();
                while (iterator.hasNext()) {
                    entry = (Map.Entry<String, ArrayList<File>>) iterator.next();
                    String typeStr = entry.getKey(); // Map的Value
                    ArrayList<File> fileArr = entry.getValue(); // Map的Value

                    for (int i = 0; i < fileArr.size(); i++) {
                        fileOrderIndex++;
                        int index = i + 1;
                        String newNamePre = index + "_" + getTimeStamp();
                        File curFile = fileArr.get(i);
                        String curFileName = curFile.getName();
                        String newName = "";
                        if (keepOriginalName) {
                            if (isOrder) { // 按顺序依次 不按 type了 一直走
                                newName = fileOrderIndex + "_" + curFileName + "_" + getTimeStampLong() + typeStr;
                            } else {
                                newName = newNamePre + curFileName + "_" + getTimeStampLong() + typeStr;
                            }
                        } else {
                            // 如果不保留名称 那么没有类型的文件 将只有 序号 没有类型
                            if ("unknow".equals(typeStr)) {
                                newName = index + "_" + getTimeStamp() + "_" + getTimeStampLong();
                            } else {
                                if (isOrder) { // 按顺序依次 不按 type了 一直走
                                    newName = fileOrderIndex + "_" + getTimeStampLong() + typeStr;
                                } else {
                                    newName = index + "_" + getTimeStampLong() + typeStr;
                                }

                            }
                        }
                        if (tryReName(curFile, newName)) {
                            executeFlag = true;
                        }
                    }

                }
            }

            return executeFlag;
        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {

            if (tryReNameOperation(fileTypeMap)) {
                return curFixedFileList;
            }

            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        String ruleTip(String type, int index, String batName, OS_TYPE curType) {
            String itemDesc = "";
            String desc_true = "  (不保留当前名称 按类型重命名当前目录下的文件) 文件命名格式为:    依据类型 序号_时间戳.类型   1_201841094.jpg 2_201841094.jpg 3_2018413131.jpg 1_201804021145.png";

            if (curType == OS_TYPE.Windows) {
                itemDesc = batName.trim() + ".bat  " + type + "_" + index
                        + "       【 index_timestamp.type 序号_时间戳.类型 命名】针对所有文件  [索引 " + index + "]  描述: " + desc_true
                        + "\n";

            } else {
                itemDesc = batName.trim() + ".sh " + type + "_" + index
                        + "       【 index_timestamp.type 序号_时间戳.类型 命名】针对所有文件   [索引 " + index + "]  描述:" + desc_true;
            }

            return itemDesc;
        }

    }

    // operation_type 操作类型 1--读取文件内容字符串 进行修改 2--对文件对文件内容(字节)--进行修改 3.对全体子文件进行的随性的操作
    // 属性进行修改(文件名称)
    // // 4.对当前子文件(包括子目录 子文件 --不包含孙目录 孙文件) 5. 从shell 中获取到的路径 去对某一个文件进行操作

    class Webp_To_Jpg_Gif_Rule_15 extends Basic_Rule {
        ArrayList<File> webpFileList;
        ArrayList<File> gif_webpFileList;
        String G2_webp2gif_exe_path = "";

        Webp_To_Jpg_Gif_Rule_15() {
            super("#", 15, 4);
            webpFileList = new ArrayList<File>();
            gif_webpFileList = new ArrayList<File>();
            PushFile2JDKBIN();
            if (CUR_OS_TYPE == OS_TYPE.Windows) {
                G2_webp2gif_exe_path = zbinPath + File.separator + "G2_webp2gif.exe";
            }

        }

        void PushFile2JDKBIN() {
            if ("".equals(JDK_BIN_PATH)) {
                return;
            }
            String webpLibraryFilePath = null;
            String G2_LibraryPath = null;
            // G2_File_Path
            if (CUR_OS_TYPE == OS_TYPE.Windows) {
                webpLibraryFilePath = JDK_BIN_PATH + File.separator + "webp-imageio.dll";
                G2_LibraryPath = G2_File_Path + File.separator + "webp-imageio.dll";
                Win_Lin_Mac_ZbinPath = zbinPath + File.separator + "win_zbin";
            } else if (CUR_OS_TYPE == OS_TYPE.MacOS) {
                webpLibraryFilePath = JDK_BIN_PATH + File.separator + "libwebp-imageio.dylib";
                G2_LibraryPath = G2_File_Path + File.separator + "libwebp-imageio.dylib";
                Win_Lin_Mac_ZbinPath = zbinPath + File.separator + "mac_zbin";
            } else if (CUR_OS_TYPE == OS_TYPE.Linux) {
                webpLibraryFilePath = JDK_BIN_PATH + File.separator + "libwebp-imageio.so";
                G2_LibraryPath = G2_File_Path + File.separator + "libwebp-imageio.so";
                Win_Lin_Mac_ZbinPath = zbinPath + File.separator + "lin_zbin";
            }

            File webpLibraryFile = new File(webpLibraryFilePath);
            File G2_LibraryFile = new File(G2_LibraryPath);
            if (!G2_LibraryFile.exists()) {
                System.out.println("本地 库文件 " + G2_LibraryPath + "不存在 请重新填充 zbin/G2/.so .dll 文件!");
                return;
            }
            if (webpLibraryFile.exists() && webpLibraryFile.length() > 100) {
                System.out.println("当前 库文件 " + webpLibraryFilePath + "已经加载到 jre/bin 路径下!");
                return;
            }
            fileCopy(G2_LibraryFile, webpLibraryFile);
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            ArrayList<File> webpFile = subFileTypeMap.get(".webp");
            if (webpFile == null) {
                System.out.println("当前文件夹中不存在 webp文件的格式");
                return null;
            }
            webpFileList.addAll(webpFile);
            String stampStr = getTimeStamp();
            for (int i = 0; i < webpFileList.size(); i++) {

                File webpFileItem = webpFileList.get(i);
                System.out.println("当前 webp索引[" + i + "] = " + webpFileItem.getAbsolutePath());
                String newFilePath = webpFileItem.getAbsolutePath().replace(".webp", "_" + stampStr + ".jpg");
                File jpgFileItem = new File(newFilePath);
                revertWebp2Jpg(webpFileItem, jpgFileItem);

            }

            for (int i = 0; i < gif_webpFileList.size(); i++) {
                File gif_webpFileItem = gif_webpFileList.get(i);
                String originName = gif_webpFileItem.getName();
                String curParentPath = gif_webpFileItem.getParent();
                boolean needRename = false;
                String absPath = gif_webpFileItem.getAbsolutePath();
                String gif_absPath = absPath.replace(".webp", ".gif");
                File gif_absPath_File = new File(gif_absPath);
                String fileName = gif_webpFileItem.getName();

                // 如果 加载后的gif 存在 那么 需要 添加时间戳 以免覆盖
//             if(gif_absPath_File.exists()){

                fileName = fileName.replace(".webp", "_" + stampStr + ".webp");
                tryReName(gif_webpFileItem, fileName);
                needRename = true;
//              }

                System.out.println("动图 索引[" + i + "] = " + fileName);
                System.out.println("执行动图转为 gif的命令! ");
                if ("".equals(G2_webp2gif_exe_path)) {
                    System.out.println("当前 webp2gif 为空 请检查!  可能当前系统 Linux MacOS 还没实现该功能!");
                    return null;
                }
                String command = G2_webp2gif_exe_path + " " + fileName;
                execCMD(command);
                if (needRename) {
                    tryReName(new File(curParentPath + File.separator + fileName), originName);
                }

            }

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        void revertWebp2Jpg(File webpFile, File jpgFile) {
            // webp 动态图 会报错 Decode returned code VP8_STATUS_UNSUPPORTED_FEATURE
            // Obtain a WebP ImageReader instance
            ImageReader reader = ImageIO.getImageReadersByMIMEType("image/webp").next();
            System.out.println("如果报错,将 webp-imageio.dll 等三个文件放入 win_zbin 中继续执行 !! ");
            // Configure decoding parameters
            WebPReadParam readParam = new WebPReadParam();
            readParam.setBypassFiltering(true);
            BufferedImage image = null;
            try {

                // Configure the input on the ImageReader
                reader.setInput(new FileImageInputStream(webpFile));

                // Decode the image
                image = reader.read(0, readParam);
            } catch (IOException e) {

                System.out.println("解析失败   可能是webp动图!   放入 ArrayList<File> gifList 列表中!");
                gif_webpFileList.add(webpFile);
            }

            try {
                ImageIO.write(image, "png", jpgFile);
            } catch (Exception e) {
                System.out.println("写入文件 " + jpgFile.getAbsolutePath() + " 失败");
            }

        }

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name + " webp_15            ### 对当前目录下的 webp文件进行转换  静态图-> jpg   动态图-> gif \n";
        }

    }

    // 创建快捷方式
    static boolean makeShellLink(File targetFile, File iconFile) {
        boolean isOK = false;
        String targetFilePath = targetFile.getAbsolutePath();
        JShellLink link = new JShellLink();
        if (!iconFile.exists()) {

            /*
             * try { iconFile.createNewFile(); } catch (IOException e) {
             * e.printStackTrace(); }
             */
        }

        try {
            String parentAbsPath = iconFile.getParentFile().getAbsolutePath();
            link.setFolder(parentAbsPath);
            String iconName = iconFile.getName();
            link.setName(iconName);
            link.setPath(targetFilePath);
            link.save();
            if (isKuaiJieIcon(iconFile)) {
                isOK = true;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        return isOK;

    }

    static String getTargetFilePath(File iconFile) {
        String targetFilePath = "";
        if (!isKuaiJieIcon(iconFile)) {
            return null; // 不是 快捷方式 那么 返回 "" 或者 null
        }
        String parentAbsPath = iconFile.getParentFile().getAbsolutePath();
        String fileName = iconFile.getName();
        JShellLink linkFile = new JShellLink(parentAbsPath, fileName);
        linkFile.load();
        targetFilePath = linkFile.getPath();
        return targetFilePath;
    }

    static boolean isKuaiJieIcon(File kuaijieFile) {
        String absPath = kuaijieFile.getAbsolutePath();
        String parentAbsPath = kuaijieFile.getParentFile().getAbsolutePath();
        String fileName = kuaijieFile.getName();
        JShellLink linkFile = new JShellLink(parentAbsPath, fileName);
        linkFile.load();
        String linkedPath = linkFile.getPath();

        if (absPath.equals(linkedPath)) {
            return false;
        }
        return true;
    }

    class CreateIconFile_KuaiJieFangShi_Rule_14 extends Basic_Rule {

        ArrayList<String> inputTypeList;
        // zrule_apply_G2.bat #_14 jpg 把当前所有的jpg格式文件生成快捷方式到 jpg_时间戳 文件夹内

        CreateIconFile_KuaiJieFangShi_Rule_14() {
            super("#", 14, 3);
            inputTypeList = new ArrayList<String>();
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            for (int i = 0; i < inputParamList.size(); i++) {
                String strInput = inputParamList.get(i);
                if (strInput.equals(firstInputIndexStr)) {
                    continue;
                }
                if (!strInput.startsWith(".")) {
                    inputTypeList.add("." + strInput.trim());
                } else {
                    inputTypeList.add(strInput.trim());
                }
            }
            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {

            SimpleDateFormat df = new SimpleDateFormat("MMdd_HHmmss");// 设置日期格式
//            SimpleDateFormat df_hms = new SimpleDateFormat("HHmmss");//设置日期格式

            Date curDate = new Date();
            String date = df.format(curDate);
//            String preHMS = df.format(df_hms);
            for (int i = 0; i < inputTypeList.size(); i++) {
                String type = inputTypeList.get(i);

                ArrayList<File> targetFileList = fileTypeMap.get(type);

                if (targetFileList == null || targetFileList.size() == 0) {
                    System.out.println(" 当前路径 " + curDirPath + " 不存在类型 " + type + "的文件!");
                    continue;
                }

                int fileCount = targetFileList.size();
                // 创建文件夹 大小
//                String dirName = preHMS+"_"+type.replace(".","").toUpperCase().trim()+"_"+date;
                String dirName = date + "_" + type.replace(".", "").toUpperCase().trim() + "[" + fileCount + "]";
                // MP4_4232414141
                File iconDirFile = new File(curDirPath + File.separator + dirName);
                iconDirFile.mkdirs();

                System.out.println("════════" + "文件类型" + type + "创建快捷方式 Begin" + "════════");
                for (int j = 0; j < targetFileList.size(); j++) {
                    File targetTypeFile = targetFileList.get(j);
                    String targetName = targetTypeFile.getName();
                    int IconIndex = j + 1;
                    String targetOrderName = IconIndex + "_" + targetName;
                    if (tryReName(targetTypeFile, targetOrderName)) {
                        targetTypeFile = new File(
                                targetTypeFile.getParentFile().getAbsolutePath() + File.separator + targetOrderName);
                    }

                    String iconName = IconIndex + "_" + targetName;
                    File iconFile = new File(iconDirFile.getAbsolutePath() + File.separator + iconName);
                    if (makeShellLink(targetTypeFile, iconFile)) {

                        System.out.println("Index[" + IconIndex + "]目标文件:" + targetTypeFile.getAbsolutePath()
                                + " 创建快捷方式成功:" + "./" + dirName + File.separator + iconName);
                    } else {
                        System.out.println("Index[" + IconIndex + "]目标文件:" + targetTypeFile.getAbsolutePath()
                                + " 创建快捷方式失败:" + "./" + dirName + File.separator + iconName);
                    }
                }
                System.out.println("════════" + "文件类型" + type + "创建快捷方式 End" + "════════");

            }

            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name
                    + " #_14  mp4          ### 源文件被按顺序重命名 1_ 2_ 动态计算当前文件夹中所有子文件中的mp4文件 并在当前目录生成 MP4_20200522_154600 字样的文件夹 \n"
                    + "\n" + Cur_Bat_Name
                    + " #_14  .mp4         ### 源文件被按顺序重命名 1_ 2_动态计算当前文件夹中所有子文件中的mp4文件 并在当前目录生成 MP4_20200522_154600 字样的文件夹 \n"
                    + "\n" + Cur_Bat_Name
                    + " #_14  .gif         ### 源文件被按顺序重命名 1_ 2_动态计算当前文件夹中所有子文件中的gif文件 并在当前目录生成 GIF_20200522_154600 字样的文件夹 \n"
                    + "\n" + Cur_Bat_Name
                    + " #_14  png          ### 源文件被按顺序重命名 1_ 2_ 动态计算当前文件夹中所有子文件中的png文件 并在当前目录生成 PNG_20200522_154600 字样的文件夹 \n"
                    + "\n" + Cur_Bat_Name
                    + " #_14  zip  7z      ### 源文件被按顺序重命名 1_ 2_ 动态计算当前文件夹中所有子文件中的 文件夹中的 7z zip文件   并在当前目录生成 7Z_20200522_154600  ZIP_20200522_154600 字样的文件夹 \n"
                    + "\n" + Cur_Bat_Name
                    + " #_14  .zip .7z     ### 源文件被按顺序重命名 1_ 2_ 动态计算当前文件夹中所有子文件中的 文件夹中的 7z zip文件   并在当前目录生成 7Z_20200522_154600  ZIP_20200522_154600 字样的文件夹 \n"
                    + "\n" + Cur_Bat_Name
                    + " #_14  jpg          ### 源文件被按顺序重命名 1_ 2_ 动态计算当前文件夹中所有子文件中的JPG文件 并在当前目录生成 JPG_20200522_154600 字样的文件夹 \n"
                    + "\n" + Cur_Bat_Name
                    + " #_14  .jpg  .png  .webp .gif                          ### 生成图片格式文件集合  PNG_时间戳  JPG_20200522_154600 字样的文件夹 \n"
                    + "\n" + Cur_Bat_Name
                    + " #_14  .mp4  .avi   .wmv .rmvb  .flv .3gp              ### 生成视频格式文件集合    源文件被按顺序重命名 1_ 2_ 动态计算当前文件夹中所有子文件中的JPG文件 并在当前目录生成 MP4_20200522_154600 字样的文件夹 \n"
                    + "\n" + Cur_Bat_Name
                    + " #_14  .jpg  .png  .gif  .webp .mp4 .avi .flv .wmv     ### 生成 视频 + 图片 格式文件集合  源文件被按顺序重命名 1_ 2_ 动态计算当前文件夹中所有子文件中的视频文件 并在当前目录生成 JPG_20200522_154600 MP4_20200522_154600 字样的文件夹 \n"

                    ;
        }
    }

    // operation_type 操作类型 1--读取文件内容字符串 进行修改 2--对文件对文件内容(字节)--进行修改 3.对全体子文件进行的随性的操作
    // 属性进行修改(文件名称)
    // // 4.对当前子文件(包括子目录 子文件 --不包含孙目录 孙文件) 5. 从shell 中获取到的路径 去对某一个文件进行操作

    class CalMP4_DIR_HTML_Rule_13 extends Basic_Rule {
        String Type_DIR_NAME = "";
        ArrayList<File> inputDirList;
        ArrayList<File> htmlModelList;
        // G2_Rule13_mp4_3x5.html
        File mp4_3x5_File;

        // G2_Rule13_mp4__3d.html
        File mp4_3d_File;

        // G2_Rule13_mp4_2x2.html
        File mp4_2x2_File;
        // G2_Rule13_mp4_3x3.html
        File mp4_3x3_File;

        String newReplaceName; // G2_Rule13_mp4_3x5 期中 G2_Rule13 替换的名称

        CalMP4_DIR_HTML_Rule_13() {
            super("#", 13, 4);
            inputDirList = new ArrayList<File>();
            htmlModelList = new ArrayList<File>();
            mp4_3x5_File = new File(zbinPath + File.separator + "G2_Rule13_mp4_3x5.html");
            mp4_3d_File = new File(zbinPath + File.separator + "G2_Rule13_mp4__3d.html");
            mp4_2x2_File = new File(zbinPath + File.separator + "G2_Rule13_mp4_2x2.html");
            mp4_3x3_File = new File(zbinPath + File.separator + "G2_Rule13_mp4_3x3.html");

            newReplaceName = "";
            htmlModelList.add(mp4_3x5_File);
            htmlModelList.add(mp4_3d_File);
            htmlModelList.add(mp4_2x2_File);
            htmlModelList.add(mp4_3x3_File);

        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {

            for (int i = 0; i < inputParamList.size(); i++) {
                String paramItem = inputParamList.get(i);
                // 检查是否有 paramItem 名称的文件夹
                System.out.println("paramItem = " + paramItem);
                File curDir = checkType2Dir(curDirFile, paramItem);
                if (curDir != null && curDir.isDirectory()) {
                    inputDirList.add(curDir); //
                }

            }

            for (int i = 0; i < inputDirList.size(); i++) {
                String dirName = inputDirList.get(i).getName();
                newReplaceName = newReplaceName + "_" + dirName;
            }
            while (newReplaceName.endsWith("_")) {
                newReplaceName = newReplaceName.substring(0, newReplaceName.length() - 1);
            }

            while (newReplaceName.startsWith("_")) {
                newReplaceName = newReplaceName.substring(1, newReplaceName.length());
            }

            if ("".equals(newReplaceName)) {
                newReplaceName = "" + curDirFile.getName();

            }

            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        boolean initParams4InputParam(String inputParam) {
            if (!(inputParam.contains("jpg") || inputParam.contains("mp4") || inputParam.contains("gif"))) {
                System.out.println("当前输入参数不包含 jpg || mp4 || gif  请重新输入");
                return false;
            }

            String[] params = inputParam.split("_");
            if (params == null) {
                System.out.println("当前输入参数不包含 jpg || mp4 || gif  请重新输入");
                return false;
            }
            String TypeDir = params[params.length - 1];

            if (!(("jpg").equals(TypeDir) || ("mp4").equals(TypeDir) || ("gif").equals(TypeDir))) {
                System.out.println("当前输入参数不包含 jpg || mp4 || gif  请重新输入");
                return false;
            }
            Type_DIR_NAME = TypeDir.toLowerCase().trim();
            return super.initParams4InputParam(inputParam);
        }

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name
                    + "  #_13_mp4    ### 动态计算当前文件夹中所有子文件中的mp4文件夹中的 mp4文件个数(孙文件夹名称必须是mp4)  并在当前shell目录生成html文件 \n"
                    + Cur_Bat_Name
                    + "  #_13_jpg    ### 动态计算当前文件夹中所有子文件中的jpg文件夹中的 jpg文件个数(孙文件夹名称必须是jpg) 并在当前目录生成html文件\n"
                    + Cur_Bat_Name
                    + "  #_13_gif    ### 动态计算当前文件夹中所有子文件中的gif文件夹中的 gif文件个数(孙文件夹名称必须是gif) 并在当前目录生成html文件\n"
                    + Cur_Bat_Name
                    + "  #_13_mp4  <单个子件夹参数>  ### 同没有参数(但shell路径不同) 动态计算当前文件夹中所有子文件中的mp4文件夹中的 mp4文件个数 并在当前目录生成html文件\n"
                    + Cur_Bat_Name
                    + "  #_13_jpg  <单个子件夹参数>  ### 同没有参数(但shell路径不同) 动态计算当前文件夹中所有子文件中的jpg文件夹中的 jpg文件个数 并在当前目录生成html文件\n"
                    + Cur_Bat_Name
                    + "  #_13_gif  <单个子件夹参数>  ### 同没有参数(但shell路径不同) 动态计算当前文件夹中所有子文件中的gif文件夹中的 gif文件个数 并在当前目录生成html文件\n"
                    + Cur_Bat_Name
                    + "  #_13_mp4  <子文件夹参数1> <子文件夹参数2> ....<子文件夹参数N>  ### 多输入参数 动态计算给定路径下的文件夹中所有子文件中的mp4文件夹中的 gif文件个数 并在当前目录生成html文件\n"
                    + Cur_Bat_Name
                    + "  #_13_jpg <子文件夹参数1> <子文件夹参数2> ....<子文件夹参数N>   ### 同没有参数(但shell路径不同) 动态计算当前文件夹中所有子文件中的mp4文件夹中的 gif文件个数 并在当前目录生成html文件\n";
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            ArrayList<File> operaDirList = new ArrayList<File>();
            boolean isMultiDirInput = false;
            String curBasePath = "";

            if (inputDirList.size() == 0) { // 如果没有输入Dir参数 那么 就在当前目录操作
                operaDirList.addAll(curDirList);
                curBasePath = curDirFile.getAbsolutePath();
            } else if (inputDirList.size() == 1) { // 如果只有一个参数 那么operaDirList 放入 当前参数的子目录
                File curInputDir = inputDirList.get(0);
                curBasePath = curInputDir.getAbsolutePath();
                operaDirList.addAll(getCurrentSubDirFile(curInputDir));
                System.out.println(" curInputDir = " + curInputDir);
            } else {
                for (int i = 0; i < inputDirList.size(); i++) {
                    operaDirList.addAll(getCurrentSubDirFile(inputDirList.get(i)));
                }
                isMultiDirInput = true;
                curBasePath = curDirFile.getAbsolutePath();
            }
            System.out.println(" inputDirList.size = " + inputDirList.size());
            System.out.println(" curBasePath = " + curBasePath);

//// hoderplace -begin
//zukgitPlaceHolderArrayDefine
//var objectArr = [ zukgitPlaceHolderArrayAdd ];
//// hoderplace -end

            StringBuilder defineArrWord = new StringBuilder();
            StringBuilder defineAdd = new StringBuilder();

            // 如果有参数 那么 当前的 curDirList
            int index = 0;
            for (int i = 0; i < operaDirList.size(); i++) {
                File cur1DirFileItem = operaDirList.get(i);
                File mTypeDirFile = checkType2Dir(cur1DirFileItem, Type_DIR_NAME);
                int typeFileNum = 0;
                if (mTypeDirFile != null && 0 != (typeFileNum = checkType3File(mTypeDirFile, Type_DIR_NAME))) {
                    // 检测到了 对应的 type 文件
                    // 1.获取当前 第一层目录名称
                    String dir1DirName = cur1DirFileItem.getName();
                    // 2. 获取对应命令的文件
                    String dir2TypeDieName = dir1DirName + File.separator + Type_DIR_NAME;
                    dir2TypeDieName = dir2TypeDieName.replace("\\", "/");
                    // 3. typeFileNum 对应的当前 孙子目录中的文件的个数
                    int length = typeFileNum;
                    String people = "person" + index;

//                    person0 = { index:0 , path:"./7001/mp4/",length:22,};
//                    person0 = { index:0 , path:"./7001\mp4,length:22,};
                    String defineItem = "";
                    if (!isMultiDirInput) { // 如果是单独的 文件
                        defineItem = people + " = { index:" + index + " , path:\"./" + dir2TypeDieName + "/\",length:"
                                + length + ",};\n";
                    } else { // 如果是两个 量入的文件 那么 path就要加入对应的 当前目录的路径
                        String targetDirName = calculBeginDir(mTypeDirFile.getAbsolutePath());
                        if (!"".equals(targetDirName)) {
                            targetDirName = targetDirName + "/";
                        }
                        defineItem = people + " = { index:" + index + " , path:\"./" + targetDirName + dir2TypeDieName
                                + "/\",length:" + length + ",};\n";
                    }
                    defineArrWord.append(defineItem);
                    defineAdd.append(people + ",");
                    index++;
                }

            }

            // 定义people
            String defineArrWordStr = defineArrWord.toString().trim();
            while (defineArrWordStr.endsWith(",")) {
                defineArrWordStr = defineArrWordStr.substring(0, defineArrWordStr.length() - 1);
            }

            // 把 people 编为 数组 array
            String defineAddStr = defineAdd.toString();

            for (int i = 0; i < htmlModelList.size(); i++) {
                // 获取 html文件的内容
                File htmlModelFile = htmlModelList.get(i);

                // G2_Rule13_mp4_3x5
                String html_old_name = htmlModelFile.getName();
                String readHtmlContent = ReadFileContent(htmlModelFile);

//            String readHtmlContent = "";
                System.out.println("defineAddStr  = " + defineAddStr);
                System.out.println("defineArrWordStr  = " + defineArrWordStr);
                readHtmlContent = readHtmlContent.replace("zukgitPlaceHolderArrayAdd", defineAddStr);
                readHtmlContent = readHtmlContent.replace("zukgitPlaceHolderArrayDefine", defineArrWordStr);

                // 把文件写入 对应的目录
                // 当前 文件名称
                String newName = html_old_name.replace("G2_Rule13", newReplaceName);

                File curHtmlTargetFile = new File(curBasePath + File.separator + newName);

                // 写入哪个文件夹

                // 1. 无参数 写入当前的 shell 路径下
                // 2. 一个参数的情况

                writeContentToFile(curHtmlTargetFile, readHtmlContent);
                System.out.println("输出文件:" + curHtmlTargetFile.getAbsolutePath());
            }

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        String calculBeginDir(String mediaPath) {
            String inputDirStr = "";
            for (int i = 0; i < inputDirList.size(); i++) {
                File inputDir = inputDirList.get(i);
                String inputDirPath = inputDir.getAbsolutePath();
                if (mediaPath.startsWith(inputDirPath)) {
                    inputDirStr = inputDir.getName();
                    break;
                }

            }

            return inputDirStr;

        }

        // 检测当前的 dirFile 目录中是否存在 第二个参数名称相同的文件名
        File checkType2Dir(File dirFile, String typeName) {
            String dirNameA = typeName;
            while (dirNameA.endsWith("\\")) {
                dirNameA = dirNameA.substring(0, dirNameA.length() - 1);
            }
            File typeDirFile = null;
            File[] fileList = dirFile.listFiles();
            if (fileList == null) {
                return typeDirFile;
            }
            for (int i = 0; i < fileList.length; i++) {
                File dirFileItem = fileList[i];
                String dirName = dirFileItem.getName();
                if (dirNameA.equals(dirName)) {
                    typeDirFile = dirFileItem;
                    break;
                }
            }
            return typeDirFile;
        }

        // 检查当前目录下是否存在对应类型typeName 的具体的文件 的文件名称的个数
        int checkType3File(File dirFile, String typeName) {
            int existNum = 0;

            File[] fileList = dirFile.listFiles();
            if (fileList == null) {
                return existNum;
            }
            for (int i = 0; i < fileList.length; i++) {
                File dirFileItem = fileList[i];
                String dirName = dirFileItem.getName();
                // 当前文件不是文件夹 并且当前文件名称的后缀 是 .【type】 例如 .gif .jpg .mp4
                if (!dirFileItem.isDirectory() && dirFileItem.getName().endsWith("." + typeName)) {
                    existNum++;
                }

            }
            return existNum;
        }

    }
    // // zrule_apply_G2.bat 12_mp4 <目标文件夹目录> ### 把当前目录mp4文件生成 html 播放文件
    // // zrule_apply_G2.bat 12_jpg <目标文件夹目录> ### 把没有类型的文件名称修改为 jpg格式名称
    // // zrule_apply_G2.bat 12_gif <目标文件夹目录> ### 把没有类型的文件名称修改为 jpg格式名称

    class CalCulMediaHtml_Rule_12 extends Basic_Rule {

        ArrayList<File> operaDirFileList; // 当前从参数获得的目录文件集合
        int operaType; // 0-unknow 1--mp4 2--jpg 3--gif // 4--allmp4 把当前所有的mp4文件转为一个数组 放入到html页面

        ArrayList<File> allMp4FileList; // 当前目录的所有的mp4文件的列表 operaType=4--allmp4 适用

        ArrayList<File> mp4AllHtmlTemplate_FileList;

        ArrayList<File> mp4HtmlTemplate_FileList;
        ArrayList<File> jpgHtmlTemplate_FileList;
        ArrayList<File> gifHtmlTemplate_FileList;

        File Mp4_All_2x2_Html_TemplateFile;
        File Mp4_All_2x3_Html_TemplateFile;
        File Mp4_All_2x4_Html_TemplateFile;
        File Mp4_All_2x5_Html_TemplateFile;

        File Mp4_All_3x2_Html_TemplateFile;
        File Mp4_All_3x3_Html_TemplateFile;
        File Mp4_All_3x4_Html_TemplateFile;
        File Mp4_All_3x5_Html_TemplateFile;

        File Mp4_All_4x2_Html_TemplateFile;
        File Mp4_All_4x3_Html_TemplateFile;
        File Mp4_All_4x4_Html_TemplateFile;
        File Mp4_All_4x5_Html_TemplateFile;

        File Mp4_All_5x2_Html_TemplateFile;
        File Mp4_All_5x3_Html_TemplateFile;
        File Mp4_All_5x4_Html_TemplateFile;
        File Mp4_All_5x5_Html_TemplateFile;

        File Mp4_2x2_Html_TemplateFile;
        File Mp4_3x3_Html_TemplateFile;
        File Mp4_3x5_Html_TemplateFile;
        File Mp4_3d_Html_TemplateFile;
        File Mp4_2x2_Html_SameTempFile;
        File Mp4_3x3_Html_SameTempFile;
        File Mp4_3x5_Html_SameTempFile;

        File Gif_3d_Html_TemplateFile;
        File Gif_1x1_Html_TemplateFile_Left;
        File Gif_1x1_Html_TemplateFile_Right;
        File Gif_2x2_Html_TemplateFile;
        File Gif_2x2_Html_TemplateFile_Left;
        File Gif_2x2_Html_TemplateFile_Right;
        File Gif_2x2_Html_SameTempFile;
        File Gif_3x3_Html_TemplateFile;
        File Gif_3x3_Html_TemplateFile_Left;
        File Gif_3x3_Html_TemplateFile_Right;
        File Gif_3x3_Html_SameTempFile;
        File Gif_3x5_Html_TemplateFile;
        File Gif_3x5_Html_SameTempFile;
        File Gif_2x4_Html_TemplateFile_Left;
        File Gif_2x4_Html_TemplateFile_Right;
        File Gif_4x3_Html_TemplateFile_Left;
        File Gif_4x3_Html_TemplateFile_Right;
        File Gif_4x4_Html_TemplateFile_Left;
        File Gif_4x4_Html_TemplateFile_Right;
        File Gif_3x5_Html_TemplateFile_Left;
        File Gif_3x5_Html_TemplateFile_Right;
        File Gif_4x5_Html_TemplateFile_Left;
        File Gif_4x5_Html_TemplateFile_Right;

        File Jpg_3d_Html_TemplateFile;
        File Jpg_4x3_Html_TemplateFile_Left;
        File Jpg_4x3_Html_TemplateFile_Right;
        File Jpg_1x1_Html_TemplateFile_Left;
        File Jpg_1x1_Html_TemplateFile_Right;
        File Jpg_2x2_Html_TemplateFile;
        File Jpg_2x2_Html_TemplateFile_Left;
        File Jpg_2x2_Html_TemplateFile_Right;
        File Jpg_2x2_Html_SameTempFile;
        File Jpg_3x3_Html_TemplateFile;
        File Jpg_3x3_Html_TemplateFile_Left;
        File Jpg_3x3_Html_TemplateFile_Right;
        File Jpg_3x3_Html_SameTempFile;
        File Jpg_3x5_Html_TemplateFile;
        File Jpg_3x5_Html_SameTempFile;
        File Jpg_2x4_Html_TemplateFile_Left;
        File Jpg_2x4_Html_TemplateFile_Right;
        File Jpg_4x4_Html_TemplateFile_Left;
        File Jpg_4x4_Html_TemplateFile_Right;
        File Jpg_3x5_Html_TemplateFile_Left;
        File Jpg_3x5_Html_TemplateFile_Right;
        File Jpg_4x5_Html_TemplateFile_Left;
        File Jpg_4x5_Html_TemplateFile_Right;

        CalCulMediaHtml_Rule_12() {

            super("#", 12, 5);
            operaType = 0;
            operaDirFileList = new ArrayList<File>();
            mp4AllHtmlTemplate_FileList = new ArrayList<File>();
            mp4HtmlTemplate_FileList = new ArrayList<File>();
            jpgHtmlTemplate_FileList = new ArrayList<File>();
            gifHtmlTemplate_FileList = new ArrayList<File>();

            Mp4_All_2x2_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_2x2.html");
            Mp4_All_2x3_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_2x3.html");
            Mp4_All_2x4_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_2x4.html");
            Mp4_All_2x5_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_2x5.html");

            Mp4_All_3x2_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_3x2.html");
            Mp4_All_3x3_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_3x3.html");
            Mp4_All_3x4_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_3x4.html");
            Mp4_All_3x5_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_3x5.html");

            Mp4_All_4x2_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_4x2.html");
            Mp4_All_4x3_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_4x3.html");
            Mp4_All_4x4_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_4x4.html");
            Mp4_All_4x5_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_4x5.html");

            Mp4_All_5x2_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_5x2.html");
            Mp4_All_5x3_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_5x3.html");
            Mp4_All_5x4_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_5x4.html");
            Mp4_All_5x5_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_all_5x5.html");

            mp4AllHtmlTemplate_FileList.add(Mp4_All_2x2_Html_TemplateFile);
            mp4AllHtmlTemplate_FileList.add(Mp4_All_2x3_Html_TemplateFile);
            mp4AllHtmlTemplate_FileList.add(Mp4_All_2x4_Html_TemplateFile);
            mp4AllHtmlTemplate_FileList.add(Mp4_All_2x5_Html_TemplateFile);

            mp4AllHtmlTemplate_FileList.add(Mp4_All_3x2_Html_TemplateFile);
            mp4AllHtmlTemplate_FileList.add(Mp4_All_3x3_Html_TemplateFile);
            mp4AllHtmlTemplate_FileList.add(Mp4_All_3x4_Html_TemplateFile);
            mp4AllHtmlTemplate_FileList.add(Mp4_All_3x5_Html_TemplateFile);

            mp4AllHtmlTemplate_FileList.add(Mp4_All_4x2_Html_TemplateFile);
            mp4AllHtmlTemplate_FileList.add(Mp4_All_4x3_Html_TemplateFile);
            mp4AllHtmlTemplate_FileList.add(Mp4_All_4x4_Html_TemplateFile);
            mp4AllHtmlTemplate_FileList.add(Mp4_All_4x5_Html_TemplateFile);

            mp4AllHtmlTemplate_FileList.add(Mp4_All_5x2_Html_TemplateFile);
            mp4AllHtmlTemplate_FileList.add(Mp4_All_5x3_Html_TemplateFile);
            mp4AllHtmlTemplate_FileList.add(Mp4_All_5x4_Html_TemplateFile);
            mp4AllHtmlTemplate_FileList.add(Mp4_All_5x5_Html_TemplateFile);

            Mp4_2x2_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_2x2.html");
            Mp4_3x3_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_3x3.html");
            Mp4_3x5_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_3x5.html");
            Mp4_2x2_Html_SameTempFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_2x2_same.html");
            Mp4_3x3_Html_SameTempFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_3x3_same.html");
            Mp4_3x5_Html_SameTempFile = new File(zbinPath + File.separator + "G2_Rule12_mp4_3x5_same.html");
            Mp4_3d_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_mp4__3d.html");
            mp4HtmlTemplate_FileList.add(Mp4_2x2_Html_TemplateFile);
            mp4HtmlTemplate_FileList.add(Mp4_3x3_Html_TemplateFile);
            mp4HtmlTemplate_FileList.add(Mp4_3x5_Html_TemplateFile);
            mp4HtmlTemplate_FileList.add(Mp4_2x2_Html_SameTempFile);
            mp4HtmlTemplate_FileList.add(Mp4_3x3_Html_SameTempFile);
            mp4HtmlTemplate_FileList.add(Mp4_3x5_Html_SameTempFile);
            mp4HtmlTemplate_FileList.add(Mp4_3d_Html_TemplateFile);

//-----------------------------JPG--------------------------------------

            Jpg_3d_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_jpg__3d.html");
            Jpg_1x1_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_jpg_1x1_flow_left.html");
            Jpg_1x1_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_jpg_1x1_flow_right.html");
            Jpg_2x2_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_jpg_2x2.html");
            Jpg_2x2_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_jpg_2x2_flow_left.html");
            Jpg_2x2_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_jpg_2x2_flow_right.html");
            Jpg_2x2_Html_SameTempFile = new File(zbinPath + File.separator + "G2_Rule12_jpg_2x2_same.html");
            Jpg_3x3_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_jpg_3x3.html");
            Jpg_3x3_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_jpg_3x3_flow_left.html");
            Jpg_3x3_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_jpg_3x3_flow_right.html");
            Jpg_3x3_Html_SameTempFile = new File(zbinPath + File.separator + "G2_Rule12_jpg_3x3_same.html");
            Jpg_3x5_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_jpg_3x5.html");
            Jpg_3x5_Html_SameTempFile = new File(zbinPath + File.separator + "G2_Rule12_jpg_3x5_same.html");
            Jpg_2x4_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_jpg_4x2_flow_left.html");
            Jpg_2x4_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_jpg_4x2_flow_right.html");
            Jpg_4x3_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_jpg_4x3_flow_left.html");
            Jpg_4x3_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_jpg_4x3_flow_right.html");

            Jpg_4x4_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_jpg_4x4_flow_left.html");
            Jpg_4x4_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_jpg_4x4_flow_right.html");
            Jpg_3x5_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_jpg_5x3_flow_left.html");
            Jpg_3x5_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_jpg_5x3_flow_right.html");
            Jpg_4x5_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_jpg_5x4_flow_right.html");
            Jpg_4x5_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_jpg_5x4_flow_left.html");

            jpgHtmlTemplate_FileList.add(Jpg_3d_Html_TemplateFile);
            jpgHtmlTemplate_FileList.add(Jpg_1x1_Html_TemplateFile_Left);
            jpgHtmlTemplate_FileList.add(Jpg_1x1_Html_TemplateFile_Right);
            jpgHtmlTemplate_FileList.add(Jpg_2x2_Html_TemplateFile);
            jpgHtmlTemplate_FileList.add(Jpg_2x2_Html_TemplateFile_Left);
            jpgHtmlTemplate_FileList.add(Jpg_2x2_Html_TemplateFile_Right);
            jpgHtmlTemplate_FileList.add(Jpg_2x2_Html_SameTempFile);
            jpgHtmlTemplate_FileList.add(Jpg_3x3_Html_TemplateFile);
            jpgHtmlTemplate_FileList.add(Jpg_3x3_Html_TemplateFile_Left);
            jpgHtmlTemplate_FileList.add(Jpg_3x3_Html_TemplateFile_Right);
            jpgHtmlTemplate_FileList.add(Jpg_3x3_Html_SameTempFile);
            jpgHtmlTemplate_FileList.add(Jpg_3x5_Html_TemplateFile);
            jpgHtmlTemplate_FileList.add(Jpg_3x5_Html_SameTempFile);
            jpgHtmlTemplate_FileList.add(Jpg_2x4_Html_TemplateFile_Left);
            jpgHtmlTemplate_FileList.add(Jpg_2x4_Html_TemplateFile_Right);
            jpgHtmlTemplate_FileList.add(Jpg_4x3_Html_TemplateFile_Left);
            jpgHtmlTemplate_FileList.add(Jpg_4x3_Html_TemplateFile_Right);
            jpgHtmlTemplate_FileList.add(Jpg_4x4_Html_TemplateFile_Left);
            jpgHtmlTemplate_FileList.add(Jpg_4x4_Html_TemplateFile_Right);
            jpgHtmlTemplate_FileList.add(Jpg_3x5_Html_TemplateFile_Left);
            jpgHtmlTemplate_FileList.add(Jpg_3x5_Html_TemplateFile_Right);
            jpgHtmlTemplate_FileList.add(Jpg_4x5_Html_TemplateFile_Left);
            jpgHtmlTemplate_FileList.add(Jpg_4x5_Html_TemplateFile_Right);

            // --------------------GIF--------------------------

            Gif_3d_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_gif__3d.html");
            Gif_1x1_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_gif_1x1_flow_left.html");
            Gif_1x1_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_gif_1x1_flow_right.html");
            Gif_2x2_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_gif_2x2.html");
            Gif_2x2_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_gif_2x2_flow_left.html");
            Gif_2x2_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_gif_2x2_flow_right.html");
            Gif_2x2_Html_SameTempFile = new File(zbinPath + File.separator + "G2_Rule12_gif_2x2_same.html");
            Gif_3x3_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_gif_3x3.html");
            Gif_3x3_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_gif_3x3_flow_left.html");
            Gif_3x3_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_gif_3x3_flow_right.html");
            Gif_3x3_Html_SameTempFile = new File(zbinPath + File.separator + "G2_Rule12_gif_3x3_same.html");
            Gif_3x5_Html_TemplateFile = new File(zbinPath + File.separator + "G2_Rule12_gif_3x5.html");
            Gif_3x5_Html_SameTempFile = new File(zbinPath + File.separator + "G2_Rule12_gif_3x5_same.html");
            Gif_2x4_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_gif_4x2_flow_left.html");
            Gif_2x4_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_gif_4x2_flow_right.html");
            Gif_4x3_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_gif_4x3_flow_left.html");
            Gif_4x3_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_gif_4x3_flow_right.html");
            Gif_4x4_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_gif_4x4_flow_left.html");
            Gif_4x4_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_gif_4x4_flow_right.html");
            Gif_3x5_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_gif_5x3_flow_left.html");
            Gif_3x5_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_gif_5x3_flow_right.html");
            Gif_4x5_Html_TemplateFile_Left = new File(zbinPath + File.separator + "G2_Rule12_gif_5x4_flow_right.html");
            Gif_4x5_Html_TemplateFile_Right = new File(zbinPath + File.separator + "G2_Rule12_gif_5x4_flow_left.html");

            gifHtmlTemplate_FileList.add(Gif_3d_Html_TemplateFile);
            gifHtmlTemplate_FileList.add(Gif_1x1_Html_TemplateFile_Left);
            gifHtmlTemplate_FileList.add(Gif_1x1_Html_TemplateFile_Right);
            gifHtmlTemplate_FileList.add(Gif_2x2_Html_TemplateFile);
            gifHtmlTemplate_FileList.add(Gif_2x2_Html_TemplateFile_Left);
            gifHtmlTemplate_FileList.add(Gif_2x2_Html_TemplateFile_Right);
            gifHtmlTemplate_FileList.add(Gif_2x2_Html_SameTempFile);
            gifHtmlTemplate_FileList.add(Gif_3x3_Html_TemplateFile);
            gifHtmlTemplate_FileList.add(Gif_3x3_Html_TemplateFile_Left);
            gifHtmlTemplate_FileList.add(Gif_3x3_Html_TemplateFile_Right);
            gifHtmlTemplate_FileList.add(Gif_3x3_Html_SameTempFile);
            gifHtmlTemplate_FileList.add(Gif_3x5_Html_TemplateFile);
            gifHtmlTemplate_FileList.add(Gif_3x5_Html_SameTempFile);
            gifHtmlTemplate_FileList.add(Gif_2x4_Html_TemplateFile_Left);
            gifHtmlTemplate_FileList.add(Gif_2x4_Html_TemplateFile_Right);

            gifHtmlTemplate_FileList.add(Gif_4x3_Html_TemplateFile_Left);
            gifHtmlTemplate_FileList.add(Gif_4x3_Html_TemplateFile_Right);
            gifHtmlTemplate_FileList.add(Gif_4x4_Html_TemplateFile_Left);
            gifHtmlTemplate_FileList.add(Gif_4x4_Html_TemplateFile_Right);
            gifHtmlTemplate_FileList.add(Gif_3x5_Html_TemplateFile_Left);
            gifHtmlTemplate_FileList.add(Gif_3x5_Html_TemplateFile_Right);
            gifHtmlTemplate_FileList.add(Gif_4x5_Html_TemplateFile_Left);
            gifHtmlTemplate_FileList.add(Gif_4x5_Html_TemplateFile_Right);

        }

        @Override
        boolean initParams4InputParam(String inputParam) {
            if (inputParam.contains("_mp4")) {
                operaType = 1;
            } else if (inputParam.contains("_jpg")) {
                operaType = 2;
            } else if (inputParam.contains("_gif")) {
                operaType = 3;
            } else if (inputParam.contains("_allmp4")) {
                operaType = 4;
            }

            return super.initParams4InputParam(inputParam);
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            System.out.println("Rule12 inputDirPath [ length ] = " + inputParamList.size());
            for (int i = 0; i < inputParamList.size(); i++) {
                String inputDirPath = inputParamList.get(i);
                System.out.println(
                        "Rule12  inputDirPath [ " + i + " ] = " + inputDirPath + "  curDirFile = " + curDirFile);
                if (inputDirPath.endsWith("\\")) {
                    inputDirPath = inputDirPath.replace("\\", "");
                }

                File inputDir = new File(curDirFile.getAbsoluteFile() + File.separator + inputDirPath);
                if (inputDir != null && inputDir.exists() && inputDir.isDirectory()) {
                    operaDirFileList.add(inputDir);
                }
                System.out.println(" inputDir  = " + inputDir.getAbsolutePath());
            }
            if (operaDirFileList.size() == 0) {
                // ### 检测当前所目录是否存在mp4文件夹 如果有生成 html 播放文件

                System.out.println("当前用户没有输入执行的目录名称,进行检测是否有 mp4文件夹!");
                return true;
            }

            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        ArrayList<File> applyDir_SubFileListRule5(ArrayList<File> allSubDirFileList,
                                                  ArrayList<File> allSubRealFileList) {
            if (operaDirFileList.size() == 0) {
                System.out.println("当前用户没有输入执行的目录名称,请重新输入B!");

                for (int i = 0; i < allSubDirFileList.size(); i++) {
                    File dirFile = allSubDirFileList.get(i);
                    String dirName = dirFile.getName().toLowerCase();
//					int operaType; // 0-unknow 1--mp4 2--jpg 3--gif
                    if (operaType == 1 && dirName.contains("mp4")) {
                        operaDirFileList.add(dirFile);
                    } else if (operaType == 2 && dirName.contains("jpg")) {
                        operaDirFileList.add(dirFile);
                    } else if (operaType == 3 && dirName.contains("gif")) {
                        operaDirFileList.add(dirFile);
                    }

                }

            }

            if (operaType == 4) { // 对当前目录的所有的

                OperationHtmlMedia(curDirFile);

            } else {

                if (operaDirFileList.size() == 0) {
                    System.out.println("当前用户没有输入执行的目录名称,请重新输入C!");
                    return null;
                }

                for (int i = 0; i < operaDirFileList.size(); i++) {
                    File operaDirFile = operaDirFileList.get(i);
                    OperationHtmlMedia(operaDirFile);
                }

            }

            return super.applyDir_SubFileListRule5(allSubDirFileList, allSubRealFileList);
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            if (operaDirFileList.size() == 0) {
                System.out.println("当前用户没有输入执行的目录名称,请重新输入C!");
                return null;
            }
            if (operaType == 4) { // mp4all 的 逻辑与 别的逻辑 有点区别

                OperationHtmlMedia(curDirFile);

            } else {
                for (int i = 0; i < operaDirFileList.size(); i++) {
                    File operaDirFile = operaDirFileList.get(i);
                    OperationHtmlMedia(operaDirFile);
                }

            }

            return super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }

        void OperationHtmlMedia(File xdirFile) {
            switch (operaType) {
                case 1: // mp4
                    ArrayList<File> mp4_mediaFileList = getSubTypeFileWithPoint(xdirFile, ".mp4");
                    tryMediaFileRenameOperation(mp4_mediaFileList, ".mp4");
                    tryMP4HtmlOperation(xdirFile, mp4_mediaFileList.size());
                    break;
                case 2: // jpg
                    ArrayList<File> jpg_mediaFileList = getSubTypeFileWithPoint(xdirFile, ".jpg");
                    tryMediaFileRenameOperation(jpg_mediaFileList, ".jpg");
                    tryJPGHtmlOperation(xdirFile, jpg_mediaFileList.size());
                    break;
                case 3: // gif
                    ArrayList<File> gif_mediaFileList = getSubTypeFileWithPoint(xdirFile, ".gif");
                    tryMediaFileRenameOperation(gif_mediaFileList, ".gif");
                    tryGIFHtmlOperation(xdirFile, gif_mediaFileList.size());
                    break;

                case 4: // allmp4

                    allMp4FileList = getAllSubFile(curDirFile, ".mp4");
                    if (allMp4FileList == null || allMp4FileList.size() == 0) {
                        System.out.println("  当前目录 curDirFile=" + curDirFile.getAbsolutePath()
                                + " 没有寻找到 .mp4文件 执行生成 allmp4-html文件失败!");
                        return;
                    }
                    System.out.println("  当前目录 curDirFile=" + curDirFile.getAbsolutePath() + " allMp4FileList.size()="
                            + allMp4FileList.size());

                    StringBuilder htmlCodeSB_head1 = new StringBuilder();
                    StringBuilder htmlCodeSB_head2 = new StringBuilder();

                    htmlCodeSB_head1.append("var videoCount =  " + allMp4FileList.size() + ";\n");
                    htmlCodeSB_head2.append("var videolist = [");
                    for (int i = 0; i < allMp4FileList.size(); i++) {
                        File mp4File = allMp4FileList.get(i);
                        String mp4FilePath = allMp4FileList.get(i).getAbsolutePath();
                        String mp4FilePath_fixed = mp4FilePath.replace(File.separator, "/");
                        String varName = "videofile_" + i;
                        htmlCodeSB_head1.append(
                                varName + " ={  index:" + i + " , filepath:\"" + mp4FilePath_fixed + "\" };" + "\n");
                        if (i == allMp4FileList.size() - 1) {
                            htmlCodeSB_head2.append(varName + "");
                        } else {
                            htmlCodeSB_head2.append(varName + ",");
                        }

                    }
                    htmlCodeSB_head2.append("];\n");

                    String htmlCode = htmlCodeSB_head1 + "\n" + htmlCodeSB_head2.toString();

                    System.out.println("  htmlCode=\n " + htmlCode.toString());

                    // hoderplace -begin
//							videofile_0 = { index:0 , path:"./mp4_1/mp4/",length:11,};
//							video1 = { index:1 , path:"./mp4_2/mp4/",length:11,};
//							var objectArr = [ person0,person1, ];
                    // hoderplace -end

                    tryAllMp4HtmlOperation(htmlCode);

                    break;

                default:
            }

        }

        void tryMediaFileRenameOperation(ArrayList<File> mp4FileList, String fileTypeWithPoint) {
            int index = 0;
            ArrayList<File> tempFileList1 = new ArrayList<File>();

            for (int i = 0; i < mp4FileList.size(); i++) {
                index = i + 1;
                String timeStamp = "";
                String newName1 = index + "_" + getTimeStamp() + fileTypeWithPoint;
                String newName2 = index + fileTypeWithPoint;
                File curFile = mp4FileList.get(i);
                String parrentFilePath = curFile.getParentFile().getAbsolutePath();
                tryReName(curFile, newName1); // 第一次改名 避免重复
                File file1 = new File(parrentFilePath + File.separator + newName1);
                tempFileList1.add(file1);
            }
            for (int i = 0; i < tempFileList1.size(); i++) {
                index = i + 1;
                File curFile = tempFileList1.get(i);
                String newName = index + fileTypeWithPoint;
                tryReName(curFile, newName); // 第二次改名 实现顺序 1.xx 2.xx 3.xx 4.xx
            }

        }

        void tryMP4HtmlOperation(File curDirFile, int num) {
// 把当前的html文件 中的  对应的 占位符 以 num 进行 替换
// 把  html文件中 mp4/  转换为   当前目录名称  90890/
// 把当前的 html  文件 放入到当前的 shell的 根 目录    html命令为   参数目录_原有名称
            String curDirName = curDirFile.getName();

            for (int i = 0; i < mp4HtmlTemplate_FileList.size(); i++) {
                File HtmlFile = mp4HtmlTemplate_FileList.get(i);
                if (!HtmlFile.exists()) {
                    System.out.println("注意当前Html文件不存在!  PATH:  " + HtmlFile.getAbsolutePath());
                    continue;
                }
                String htmlname = HtmlFile.getName();
                htmlname = htmlname.replace("G2_Rule12", curDirName);

                String htmlContent = ReadFileContent(HtmlFile);
                htmlContent = htmlContent.replace("zukgitPlaceHolderindex", num + "");
                htmlContent = htmlContent.replace("mp4/", curDirName + "/");
                File curShellHtmlFile = new File(
                        curDirFile.getParentFile().getAbsolutePath() + File.separator + "" + htmlname);
                writeContentToFile(curShellHtmlFile, htmlContent);
            }
        }

        void tryJPGHtmlOperation(File curDirFile, int num) {
            String curDirName = curDirFile.getName();

            for (int i = 0; i < jpgHtmlTemplate_FileList.size(); i++) {
                File HtmlFile = jpgHtmlTemplate_FileList.get(i);
                if (!HtmlFile.exists()) {
                    System.out.println("注意当前Html文件不存在!  PATH:  " + HtmlFile.getAbsolutePath());
                    continue;
                }
                String htmlname = HtmlFile.getName();
                htmlname = htmlname.replace("G2_Rule12", curDirName);

                String htmlContent = ReadFileContent(HtmlFile);
                htmlContent = htmlContent.replace("zukgitPlaceHolderindex", num + "");
                htmlContent = htmlContent.replace("jpg/", curDirName + "/");
                File curShellHtmlFile = new File(
                        curDirFile.getParentFile().getAbsolutePath() + File.separator + "" + htmlname);
                writeContentToFile(curShellHtmlFile, htmlContent);
            }

        }

        void tryGIFHtmlOperation(File curDirFile, int num) {
            String curDirName = curDirFile.getName();
            String curParentDirName = curDirFile.getParentFile().getName();
            System.out.println("curDirFile = " + curDirFile.getAbsolutePath());
            System.out.println("ParentFile = " + curDirFile.getParentFile().getAbsolutePath());

            for (int i = 0; i < gifHtmlTemplate_FileList.size(); i++) {
                File HtmlFile = gifHtmlTemplate_FileList.get(i);
                if (!HtmlFile.exists()) {
                    System.out.println("注意当前Html文件不存在!  PATH:  " + HtmlFile.getAbsolutePath());
                    continue;
                }
                String htmlname = HtmlFile.getName();
                htmlname = htmlname.replace("G2_Rule12", curDirName);

                String htmlContent = ReadFileContent(HtmlFile);
                htmlContent = htmlContent.replace("zukgitPlaceHolderindex", num + "");
                htmlContent = htmlContent.replace("gif/", curDirName + "/");
                File curShellHtmlFile = new File(
                        curDirFile.getParentFile().getAbsolutePath() + File.separator + "" + htmlname);
                writeContentToFile(curShellHtmlFile, htmlContent);
            }

        }

        // allMp4 的 操作逻辑
        void tryAllMp4HtmlOperation(String commonHtmlCode) {
            String curDirName = curDirFile.getName();
            String curParentDirName = curDirFile.getParentFile().getName();
            System.out.println("curDirFile = " + curDirFile.getAbsolutePath());
            System.out.println("ParentFile = " + curDirFile.getParentFile().getAbsolutePath());

            for (int i = 0; i < mp4AllHtmlTemplate_FileList.size(); i++) {
                File HtmlFile = mp4AllHtmlTemplate_FileList.get(i);
                if (!HtmlFile.exists()) {
                    System.out.println("注意当前Html文件不存在!  PATH:  " + HtmlFile.getAbsolutePath());
                    continue;
                }
                String htmlname = HtmlFile.getName();
                htmlname = htmlname.replace("G2_Rule12", curDirName);

                String htmlContent = ReadFileContent(HtmlFile);
                htmlContent = htmlContent.replace("zukgitPlaceHolderindex", commonHtmlCode);

                File curShellHtmlFile = new File(curDirFile.getAbsolutePath() + File.separator + "" + htmlname);
                writeContentToFile(curShellHtmlFile, htmlContent);
                System.out.println("htmlContent:" + htmlContent);
                System.out.println("生成Html文件:" + curShellHtmlFile.getAbsolutePath());
            }

        }

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name
                    + "  #_12_mp4      ### 把目录中包含mp4的文件夹进行检索 生成 [mp4目录名称-html文件][mp4改名1.2.3][单一文件夹] 播放文件  \n"
                    + Cur_Bat_Name
                    + "  #_12_allmp4    ### 把目录中所有的mp4文件 生成 Arr数组 放入 [allmp4_timestamp_html][mp4不改名][多文件夹] 播放文件  \n"
                    + Cur_Bat_Name + "  #_12_gif      ### 把目录中包含gif的文件夹进行检索 生成 gif-html 播放文件  \n" + Cur_Bat_Name
                    + "  #_12_jpg      ### 把目录中包含jpg的文件夹进行检索 生成 jpg-html 播放文件  \n" + Cur_Bat_Name
                    + "  #_12_mp4   <目标文件夹目录>   ### 把当前输入目录包含mp4文件夹 生成 mp4-html 播放文件  \n" + Cur_Bat_Name
                    + "  #_12_gif   <目标文件夹目录>   ### 把当前输入目录包含gif文件夹 生成 gif-html 播放文件  \n" + Cur_Bat_Name
                    + "  #_12_jpg   <目标文件夹目录>   ### 把当前输入目录包含jpg文件夹 生成 jpg-html 播放文件  \n";

        }

    }

    class AllDirSubFile_Order_Rule_11 extends Basic_Rule {

        AllDirSubFile_Order_Rule_11() {
            super("#", 11, 5);
        }

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name + "  #_11    ## (清除原有名称，序列从1开始)把当前所有子目录的文件 当前目录 下的实体文件依次按顺序按类型重新命名!  \n";
        }

        @SuppressWarnings("unchecked")
        @Override
        ArrayList<File> applyDir_SubFileListRule5(ArrayList<File> allSubDirFileList,
                                                  ArrayList<File> allSubRealFileList) {

            System.out.println("allSubDirFileList = " + allSubDirFileList.size());
            System.out.println("allSubRealFileList = " + allSubRealFileList.size());
            if (!allSubDirFileList.contains(curDirFile)) {
                allSubDirFileList.add(curDirFile);
            }

            for (int i = 0; i < allSubDirFileList.size(); i++) {
                File dirFileItem = allSubDirFileList.get(i);
                // 获取当前文件夹下的所有依据 文件类型为 .jpg .png .mp4 为key 进行的
                Map<String, ArrayList<File>> curDirSubRealFile = getCurSubFileMap(dirFileItem);

                // 对文件依次重命名

                Map.Entry<String, ArrayList<File>> entry;
                // 不同的类型文件怎么处理?

                if (curDirSubRealFile != null) {
                    Iterator iterator = curDirSubRealFile.entrySet().iterator();
                    while (iterator.hasNext()) {
                        entry = (Map.Entry<String, ArrayList<File>>) iterator.next();
                        String typeStr = entry.getKey(); // Map的Value
                        String typeWithOutPot = typeStr.replace(".", "");

                        ArrayList<File> fileArr = entry.getValue(); // Map的Value

                        // 从 000 开始
//                    fixedFileIndex = fixedFileIndex ;
                        ArrayList<File> curRenamePlace = new ArrayList<File>();
                        for (int m = 0; m < fileArr.size(); m++) {
                            File curFile = fileArr.get(m);
                            String oldName = curFile.getName();
                            // String curFileName = curFile.getName();

                            System.out.println("═════════════ m=" + m + "═════════════");
                            // 占位符 使得 所有文件都命名成功 避免那些已经有该名称了的文件
                            String newName1 = "_ZHolder_" + (m + 1)
                                    + ("".equals(typeWithOutPot) ? "" : "." + typeWithOutPot);
//                        String newName = typeTag+"_"+dirTempIndex+"_"+getPaddingIntString(fixedFileIndex,3,"0",true)+typeStr;
                            if (tryReName(curFile, newName1)) {
                                System.out.println("成功 Index =" + m + "  命名( " + oldName + " => " + newName1 + ")  => "
                                        + curFile.getAbsolutePath());
                            } else {
                                System.out.println("失败 Index =" + m + "  命名( " + oldName + " => " + newName1 + ")  => "
                                        + curFile.getAbsolutePath());
                            }
                            File fileItem2 = new File(
                                    curFile.getParentFile().getAbsolutePath() + File.separator + newName1);
                            if (fileItem2.exists()) {
                                curRenamePlace.add(fileItem2);

                                /*
                                 * System.out.println(fileItem2+ " fileItem2.exists() = "+ fileItem2.exists());
                                 * String newName2 = newName1.replace("_ZHolder_","");
                                 *
                                 * if(tryReName(fileItem2,newName2)){
                                 * System.out.println("成功 Index ="+m+"  命名( "+oldName+" => "+
                                 * newName1+")  => "+curFile.getAbsolutePath()); }else{
                                 * System.out.println("失败 Index ="+m+"  命名( "+oldName+" => "+
                                 * newName1+")  => "+curFile.getAbsolutePath()); }
                                 */

                            }

                        }
                        System.out.println("════════════════════════════════════════════════════");

                        for (int n = 0; n < curRenamePlace.size(); n++) {
                            System.out.println("═════════════ n=" + n + "═════════════");

                            File fileItem2 = curRenamePlace.get(n);
                            String newName2 = fileItem2.getName().replace("_ZHolder_", "");
                            if (tryReName(fileItem2, newName2)) {
                                System.out.println("成功 Index =" + n + "  命名( " + fileItem2.getName() + " => " + newName2
                                        + ")  => " + fileItem2.getAbsolutePath());
                            } else {
                                System.out.println("失败 Index =" + n + "  命名( " + fileItem2.getName() + " => " + newName2
                                        + ")  => " + fileItem2.getAbsolutePath());
                            }
                        }
                        curRenamePlace.clear();

                    }
                }

            }
            return super.applyDir_SubFileListRule5(allSubDirFileList, allSubRealFileList);
        }

        @SuppressWarnings("unchecked")
        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            if (!curDirList.contains(curDirFile)) {
                curDirList.add(curDirFile);
            }

            for (int i = 0; i < curDirList.size(); i++) {
                File dirFileItem = curDirList.get(i);
                // 获取当前文件夹下的所有依据 文件类型为 .jpg .png .mp4 为key 进行的
                Map<String, ArrayList<File>> curDirSubRealFile = getCurSubFileMap(dirFileItem);

                // 对文件依次重命名

                Map.Entry<String, ArrayList<File>> entry;
                // 不同的类型文件怎么处理?

                if (curDirSubRealFile != null) {
                    Iterator iterator = curDirSubRealFile.entrySet().iterator();
                    while (iterator.hasNext()) {
                        entry = (Map.Entry<String, ArrayList<File>>) iterator.next();
                        String typeStr = entry.getKey(); // Map的Value
                        String typeWithOutPot = typeStr.replace(".", "");

                        ArrayList<File> fileArr = entry.getValue(); // Map的Value

                        // 从 000 开始
//                    fixedFileIndex = fixedFileIndex ;
                        ArrayList<File> curRenamePlace = new ArrayList<File>();
                        for (int m = 0; m < fileArr.size(); m++) {
                            File curFile = fileArr.get(m);
                            String oldName = curFile.getName();
                            // String curFileName = curFile.getName();

                            System.out.println("═════════════ m=" + m + "═════════════");
                            // 占位符 使得 所有文件都命名成功 避免那些已经有该名称了的文件
                            String newName1 = "_ZHolder_" + m + ("".equals(typeWithOutPot) ? "" : "." + typeWithOutPot);
//                        String newName = typeTag+"_"+dirTempIndex+"_"+getPaddingIntString(fixedFileIndex,3,"0",true)+typeStr;
                            if (tryReName(curFile, newName1)) {
                                System.out.println("成功 Index =" + m + "  命名( " + oldName + " => " + newName1 + ")  => "
                                        + curFile.getAbsolutePath());
                            } else {
                                System.out.println("失败 Index =" + m + "  命名( " + oldName + " => " + newName1 + ")  => "
                                        + curFile.getAbsolutePath());
                            }
                            File fileItem2 = new File(
                                    curFile.getParentFile().getAbsolutePath() + File.separator + newName1);
                            if (fileItem2.exists()) {
                                curRenamePlace.add(fileItem2);

                                /*
                                 * System.out.println(fileItem2+ " fileItem2.exists() = "+ fileItem2.exists());
                                 * String newName2 = newName1.replace("_ZHolder_","");
                                 *
                                 * if(tryReName(fileItem2,newName2)){
                                 * System.out.println("成功 Index ="+m+"  命名( "+oldName+" => "+
                                 * newName1+")  => "+curFile.getAbsolutePath()); }else{
                                 * System.out.println("失败 Index ="+m+"  命名( "+oldName+" => "+
                                 * newName1+")  => "+curFile.getAbsolutePath()); }
                                 */

                            }

                        }
                        System.out.println("════════════════════════════════════════════════════");

                        for (int n = 0; n < curRenamePlace.size(); n++) {
                            System.out.println("═════════════ n=" + n + "═════════════");

                            File fileItem2 = curRenamePlace.get(n);
                            String newName2 = fileItem2.getName().replace("_ZHolder_", "");
                            if (tryReName(fileItem2, newName2)) {
                                System.out.println("成功 Index =" + n + "  命名( " + fileItem2.getName() + " => " + newName2
                                        + ")  => " + fileItem2.getAbsolutePath());
                            } else {
                                System.out.println("失败 Index =" + n + "  命名( " + fileItem2.getName() + " => " + newName2
                                        + ")  => " + fileItem2.getAbsolutePath());
                            }
                        }
                        curRenamePlace.clear();

                    }
                }

            }

            return curDirList;
        }
    }

    // // zrule_apply_G2.bat #_10_append 2001 往当前文件夹后缀增加 2001
    // // zrule_apply_G2.bat #_10_prefix 2001 往当前文件夹前缀增加 2001
    // // zrule_apply_G2.bat #_10_create 1_100 创建一个序列号从1到100的100个文件夹
    // // zrule_apply_G2.bat #_10_create temp_ 1_100 创建一个序列号从temp1到temp100的100个文件夹
    // // zrule_apply_G2.bat #_10_create _temp 1_100 创建一个序列号从1temp到100temp的100个文件夹
    // // zrule_apply_G2.bat #_10_create i_temp 1_100
    // 创建一个序列号从i1temp到i100temp100的100个文件夹

    // // zrule_apply_G2.bat #_10_create 7000_7100 创建一个序列号从7000开始的到7100结束的文件夹
    // // zrule_apply_G2.bat #_10_replace abc_DEF 创建一个序列号从7000开始的到7100结束的文件夹

    class DirOperation_Rule_10 extends Basic_Rule {

        String firstParamStr; // 第一个参数

        int DIR_OPERA_TYPE_APPEND = 1; // 后缀增加
        String appendStr_1;
        int DIR_OPERA_TYPE_PREFIX = 2; // 前缀增加
        String prefixStr_2;

        int DIR_OPERA_TYPE_CREATE = 3; // 创建文件
        int beginIndex_3;
        int endIndex_3;
        String prefixStr_3;
        String appendStr_3;

        int DIR_OPERA_TYPE_REPLACE = 4; // 替换文件夹名称
        String replacedStr_4;
        String newNameStr_4;

        // 识别当前用户 指定的操作类型 1后缀增加 2前缀增加 3创建文件 4替换文件夹名称
        int currentOperaType = 0;

        DirOperation_Rule_10() {
            super("#", 10, 4);
            prefixStr_3 = "";
            appendStr_3 = "";
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            boolean falg = true;
            if (currentOperaType == 1) {
                appendStr_1 = inputParamList.get(inputParamList.size() - 1);
            } else if (currentOperaType == 2) {
                prefixStr_2 = inputParamList.get(inputParamList.size() - 1);
            } else if (currentOperaType == 4) {
                String inputStr = inputParamList.get(inputParamList.size() - 1);
                if (!inputStr.contains("_")) {
                    falg = false;
                }

                String[] inputArr = inputStr.split("_");

                if (inputArr.length >= 2) {

                    replacedStr_4 = inputArr[0];
                    newNameStr_4 = inputArr[inputArr.length - 1];
                } else {
                    falg = false;
                }
            } else if (currentOperaType == 3) {

                for (int i = 0; i < inputParamList.size(); i++) {

                    String paramItem = inputParamList.get(i);
                    if (paramItem != null && paramItem.equals(firstParamStr)) {
                        continue; // 第一个参数不操作
                    }

                    if (!paramItem.contains("_")) {
                        falg = false;
                        continue;
                    }
                    String fixedParam = paramItem.replace("_", "");

                    if (isNumeric(fixedParam)) { // 如果是 字母 说明是起始的那个参数
                        String[] IndexArr = paramItem.split("_");

                        if (IndexArr.length >= 2) {

                            String beginIndex_3_Str = IndexArr[0];
                            String endIndex_3_Str = IndexArr[IndexArr.length - 1];
                            if (isNumeric(beginIndex_3_Str)) {
                                beginIndex_3 = Integer.parseInt(beginIndex_3_Str);

                            } else {
                                falg = false;
                            }

                            if (isNumeric(endIndex_3_Str)) {
                                endIndex_3 = Integer.parseInt(endIndex_3_Str);
                            } else {
                                falg = false;
                            }

                        } else {
                            falg = false;
                        }
                    } else { // 名称的参数
                        if (paramItem.endsWith("_")) {
                            appendStr_3 = "";
                            String[] NamePreArr = paramItem.split("_");
                            prefixStr_3 = NamePreArr[0];
                            System.out.println("appendStr_3=" + appendStr_3 + "   prefixStr_3=" + prefixStr_3);

                        } else {
                            String[] NamePreArr = paramItem.split("_");
                            if (NamePreArr.length >= 2) {
                                prefixStr_3 = NamePreArr[0];
                                appendStr_3 = NamePreArr[1];
                                System.out.println("appendStr_3=" + appendStr_3 + "   prefixStr_3=" + prefixStr_3);

                            }

                        }

                    }

                }

            }

            return super.initParamsWithInputList(inputParamList) || falg;
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            switch (currentOperaType) {

                case 1:
                    for (int i = 0; i < curDirList.size(); i++) {
                        File dirFile = curDirList.get(i);
                        String dirName = dirFile.getName();
                        String newName = dirName + appendStr_1;
                        tryReName(dirFile, newName);
                    }
                    break;

                case 2:
                    for (int i = 0; i < curDirList.size(); i++) {
                        File dirFile = curDirList.get(i);
                        String dirName = dirFile.getName();
                        String newName = prefixStr_2 + dirName;
                        tryReName(dirFile, newName);
                    }
                    break;

                case 3:
                    for (int i = beginIndex_3; i < endIndex_3 + 1; i++) {
                        String absDirPath = curDirFile.getAbsolutePath();
                        String newDir = absDirPath + File.separator + prefixStr_3 + i + appendStr_3;
                        File curDirFileItem = new File(newDir);
                        curDirFileItem.mkdirs();
                    }
                    break;

                case 4:

                    for (int i = 0; i < curDirList.size(); i++) {
                        File dirFile = curDirList.get(i);
                        String dirName = dirFile.getName();
                        String newName = dirName.replace(replacedStr_4, newNameStr_4);
                        tryReName(dirFile, newName);
                    }

                    break;

                default:
                    System.out.println("当前 currentOperaType = " + currentOperaType + "  没有找到合适的操作类型去处理 ");
            }

            return curDirList;
        }

        @Override
        boolean initParams4InputParam(String inputParam) {

            firstParamStr = inputParam;
            if (inputParam.contains("append")) {
                currentOperaType = 1;
            } else if (inputParam.contains("prefix")) {
                currentOperaType = 2;

            } else if (inputParam.contains("replace")) {
                currentOperaType = 4;

            } else if (inputParam.contains("create")) {
                currentOperaType = 3;

            }

            return super.initParams4InputParam(inputParam);
        }

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name + "  #_10_append  _over   往当前文件夹后缀增加 _over \n" + Cur_Bat_Name
                    + "  #_10_prefix  temp   往当前文件夹前缀增加 temp \n" + Cur_Bat_Name
                    + " #_10_create  1_100   创建一个序列号从1到100的100个文件夹   \n" + Cur_Bat_Name
                    + " #_10_create   temp_  1_100   创建一个序列号从temp1到temp100的100个文件夹 \n " + Cur_Bat_Name
                    + " #_10_create   _temp  1_100   创建一个序列号从1temp到100temp的100个文件夹 \n " + Cur_Bat_Name
                    + " #_10_create   j_temp  1_100   创建一个序列号从 j_1_temp 到100temp的 j_100_temp 个文件夹 \n " + Cur_Bat_Name
                    + " #_10_create  7000_7100  创建一个序列号从7000开始的到7100结束的文件夹  \n " + Cur_Bat_Name
                    + " #_10_replace  abc_DEF  把当前文件夹名称中的  abc 转为 DEF \n ";
        }

    }

    // // zrule_apply_G2.bat #_9 _jpg 把没有类型的文件名称修改为 jpg格式名称
    // // zrule_apply_G2.bat #_9 jpg_ 去除当前jpg的格式 使得其文件格式未知

    // 把 当前目录下子文件 进行格式的转换
    // // zrule_apply_G2.bat #_9 _jpg 把没有类型的文件名称修改为 jpg格式名称
    // // zrule_apply_G2.bat #_9 jpg_ 去除当前jpg的格式 使得其文件格式未知
    // zrule_apply_G2.bat #_9 jpg_png 把 jpg的格式转为png的格式
    // zrule_apply_G2.bat #_9 png_jpg 把 jpg的格式转为png的格式
    // // zrule_apply_G2.bat #_9 gif_ 去除当前gif的格式 使得其文件格式未知
    // // zrule_apply_G2.bat #_9 _gif 把没有类型的文件名称修改为 jpg格式名称
    // // zrule_apply_G2.bat #_9 mp4_ 去除当前mp4的格式 使得其文件格式未知
    // // zrule_apply_G2.bat #_9 _mp4 把没有类型的文件名称修改为 mp4格式名称
    // // zrule_apply_G2.bat #_9 原类型_目标类型 把没有类型的文件名称修改为 jpg格式名称
    // // zrule_apply_G2.bat #_9 _jpg 把没有类型的文件名称修改为 jpg格式名称
    // // zrule_apply_G2.bat #_9 jpg_ 去除当前jpg的格式 使得其文件格式未知

    class FileType_Rule_9 extends Basic_Rule {
        String originType;
        String targetType;

        boolean isFileNameReplace = false;
        boolean isSrcTypeAll = false; // 是否当前输入的 输入类型是* 所有类型

        FileType_Rule_9() {
            super("#", 9, 3);
        }

        @Override
        String simpleDesc() {
            return "\n" + Cur_Bat_Name + "  #_9  _jpg   把没有类型的文件名称修改为 jpg格式名称\n" + Cur_Bat_Name
                    + "  #_9  jpg_   去除当前jpg的格式 使得其文件格式未知 \n" + Cur_Bat_Name + " #_9  jpg_png  把  jpg的格式转为png的格式  \n"
                    + Cur_Bat_Name + " #_9  png_jpg  把  jpg的格式转为png的格式 \n " + Cur_Bat_Name
                    + " #_9  gif_   去除当前gif的格式 使得其文件格式未知  \n " + Cur_Bat_Name
                    + " #_9  _gif   把没有类型的文件名称修改为 jpg格式名称  \n " + Cur_Bat_Name + " #_9  png_jpg  把  jpg的格式转为png的格式 \n "
                    + Cur_Bat_Name + " #_9  mp4_   去除当前mp4的格式 使得其文件格式未知 \n " + Cur_Bat_Name
                    + " #_9  _mp4   把没有类型的文件名称修改为 mp4格式名称 \n " + Cur_Bat_Name
                    + " #_9  *_mp4   把所有别的类型的文件名称修改为 mp4格式名称 \n " + Cur_Bat_Name
                    + " #_9_replace  123_789   把当前 文件名包含 123 改为 789 (依据文件名 判断 而不是类型 ) 123.jpg -> 789.jpg \n " + Cur_Bat_Name
                    + " #_9  7z_7疫z   把当前 7z文件名后缀改为 7疫z 使得无法检测具体类型 \n " + Cur_Bat_Name
                    + " #_9  jpg_orig.jpg    把当前所有的 ori_jpg类型都转为jpg类型(有时存在类型.ori_jpg 这样的类型有用) \n " + Cur_Bat_Name
                    + " #_9  png_orig.jpg    把当前所有的 ori_jpg类型都转为jpg类型(有时存在类型.ori_jpg 这样的类型有用) \n " + Cur_Bat_Name
                    + " #_9  png_orig.png    把当前所有的 ori_jpg类型都转为jpg类型(有时存在类型.ori_jpg 这样的类型有用) \n " + Cur_Bat_Name
                    + " #_9  原类型_目标类型   把没有类型的文件名称【原类型】->【目标类型】 \n ";
        }



        @Override
        boolean initParams4InputParam(String inputParam) {

            if (inputParam.contains("_replace")) {
                isFileNameReplace = true;

            }

            return super.initParams4InputParam(inputParam);
        }


        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            boolean Flag = true;




            // 获取到装换的类型
            String inputFileTypeParams = inputParamList.get(inputParamList.size() - 1);
            if (inputFileTypeParams.contains(".")) {
                if (!inputFileTypeParams.contains(".")) {
                    Flag = false;
                    System.out.println("无法检测到当前 第9 Rule   原始类型_目标类型参数   请检查后重新执行");
                } else {

                    if (inputFileTypeParams.endsWith(".")) {
                        String target = "";

                        String origin = inputFileTypeParams.substring(0,inputFileTypeParams.length()-1);
                        System.out.println("item=" + inputFileTypeParams + "   origin=" + origin + "     target=" + target);
                        originType = origin;
                        targetType = target;

                    } else {

                        String[] parmas = inputFileTypeParams.split("\\.");
                        System.out.println("rule9_item=" + inputFileTypeParams + "   rule9_origin=" + parmas[0] + "     rule9_target=" + parmas[1]);
                        originType = parmas[0];
                        targetType = parmas[1];
                    }

                    Flag = true;

                }

            }else{

                if (!inputFileTypeParams.contains("_")) {
                    Flag = false;
                    System.out.println("无法检测到当前 第9 Rule   原始类型_目标类型参数   请检查后重新执行");
                } else {

                    if (inputFileTypeParams.endsWith("_")) {
                        String target = "";
                        String[] parmas = inputFileTypeParams.split("_");
                        String origin = parmas[0];
                        System.out.println("item=" + inputFileTypeParams + "   origin=" + origin + "     target=" + target);
                        originType = origin;
                        targetType = target;

                    } else {
                        String[] parmas = inputFileTypeParams.split("_");
                        System.out.println(
                                "item=" + inputFileTypeParams + "   origin=" + parmas[0] + "     target=" + parmas[1]);
                        originType = parmas[0];
                        targetType = parmas[1];
                    }

                    Flag = true;

                }


            }

            if("*".equals(originType)){
                isSrcTypeAll = true;
            }
            System.out.println("originType="+originType+"   targetType="+targetType+"  isFileNameReplace = "+ isFileNameReplace+"   isSrcTypeAll=" +isSrcTypeAll+   "  Flag"+ Flag);
            if(isFileNameReplace){
                curFilterFileTypeList.add("*");
            }else{
                curFilterFileTypeList.add(originType);
            }


            return super.initParamsWithInputList(inputParamList) && Flag;
        }

        @Override
        boolean allowEmptyDirFileList() {
            return true;
        }



        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {

            System.out.println(rule_index+":  applyFileListRule3 execute!" );

            int mFileNameReplace_index = 0 ;
            for (int i = 0; i < subFileList.size(); i++) {
                File curFIle = subFileList.get(i);
                String originName = curFIle.getName();
                // 执行 修改文件类型的操作

                if(isFileNameReplace){  // 文件名称替换

                    if(originName.contains(originType)){
                        mFileNameReplace_index++;
                        String newFileName  = originName.replaceAll(originType,targetType);
                        tryReName(curFIle, newFileName);
                        System.out.println("RenameFile["+mFileNameReplace_index+"]: "+curFIle.getName()+" --> "+newFileName);
                    }


                }else {   // 文件类型替换

                    // 1. 如果当前文件 过滤类型是 空 那么 可能就是没有任何的类型了
                    // 如果当前过滤的类型是 originType 是"" 空的话 那么就会过滤出所有的文件 那么只操作 不包含.的那些文件
                    if ("".equals(originType)) {
                        if (originName.contains(".")) {
                            continue; // 包含了 . 说明有类型 那么 不操作
                        }
                        String newName = originName + "." + targetType;
                        tryReName(curFIle, newName);
                    } else if ("*".equals(originType)) {
                        if (originName.contains(".")) {  // 包含了 . 说明有类型 那么 不操作  那么 执行操作
                            String newName = originName + "." + targetType;
                            tryReName(curFIle, newName);
                        } else{    // 没有 类型的 那么 也改名

                            String newName = originName + "." + targetType;
                            tryReName(curFIle, newName);
                        }

                    } else {
                        // 有具体的 过滤的文件
                        String oldType = "." + originType;
                        String newType = "." + targetType;
                        if ("".equals(targetType)) {
                            newType = "";
                        }

                        if (originName.contains(oldType)) {
                            String newName = originName.replace(oldType, newType);
                            tryReName(curFIle, newName);
                        }

                    }

                }



            }

            return subFileList;
        }
    }

    // 把文件后缀中的中文给去除掉 不包含文件夹 不包含孙文件
    class ClearChineseType_8 extends Basic_Rule {

        ClearChineseType_8() {
            super("#", 8, 4);
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            return super.initParamsWithInputList(inputParamList);
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            System.out.println("Rule8_ClearChineseType_8   搜索到的实体文件个数:" + curRealFileList.size());

            for (int i = 0; i < curRealFileList.size(); i++) {
                File curFile = curRealFileList.get(i);
                String currentFileName = curFile.getName();
                if (currentFileName.contains(".")) {
                    String typeStr = currentFileName.substring(currentFileName.lastIndexOf("."));
                    if (isContainChinese(typeStr)) {
                        // //清除中文 清除 空格
                        String newType = clearChinese(typeStr).replace(" ", "");
                        String newName = currentFileName.replace(typeStr, newType); // 新名称
                        System.out.println("newType = " + newType + "    newName=" + newName);
                        tryReName(curFile, newName);
                    }
                }

            }

            return curRealFileList;
        }

        @Override
        String simpleDesc() {
            return "把当前命令的文件包含.的文件的 后缀名称中的中文清除掉  例如 1.7啊z -> 1.7z   2.你zip -> 2.zip \n" + Cur_Bat_Name
                    + " #_8    <指定后缀有中文的文件>  [索引8]   // 把当前目录下文件 后缀中文去除  \n";
        }
    }

    // operation_type 操作类型 1--读取文件内容字符串 进行修改 2--对文件对文件内容(字节)--进行修改 3.对全体子文件进行的随性的操作
    // 属性进行修改(文件名称)
    // // 4.对当前子文件(包括子目录 子文件 --不包含孙目录 孙文件) 5. 从shell 中获取到的路径 去对某一个文件进行操作

    // 对当前目录的文件进行加密 解密
    class Encropty_Rule_7 extends Basic_Rule {
        boolean mEncroptyDirect = true; // true---加密 false--解密
        boolean isAllFileOperation = false;

        boolean isBatchOperation = false; // 是否你是批量处理 会生成固定的 bad_batch good_batch 文件夹 而不是时间戳文件夹

        boolean isZVIOperation = false; // 是否是 1970ZVI 文件夹 操作

        Encropty_Rule_7() {
            super("#", 7, 4);
            isAllFileOperation = false;
            isBatchOperation = false;
            isZVIOperation = false;
        }

        @Override
        boolean initParams4InputParam(String inputParam) {
            if (inputParam.contains("good")) {
                mEncroptyDirect = false;
            } else {
                mEncroptyDirect = true;
            }

            if (inputParam.contains("batch")) {
                isBatchOperation = true;
            } else {
                isBatchOperation = false;
            }

            if (inputParam.contains("#")) {
                isAllFileOperation = true;
            } else {
                isAllFileOperation = false;
            }

            if (inputParam.toLowerCase().contains("zvi") && inputParam.toLowerCase().contains("good")) {
                mEncroptyDirect = false;
                isZVIOperation = true;
                isBatchOperation = false;
            }

            return super.initParams4InputParam(inputParam);
        }

        @Override
        String simpleDesc() {
            return "   默认bad(加密) 把当前目录下的所有文件(不包含文件夹  不包含孙文件)进行 加密bad/解密good\n" + Cur_Bat_Name
                    + " #_7_bad   (默认--加密文件)  把当前目录下的所有文件(不包含文件夹  不包含孙文件)进行 加密bad 生成 【 time + bad 】 加密文件夹 \n"
                    + Cur_Bat_Name + " #_7_good   (解密文件) 把当前目录下的所有文件(不包含文件夹  不包含孙文件)进行 解密good 【 time + good 】 生成解密文件夹\n"
                    + Cur_Bat_Name + " jpg_7_bad  [索引7]   // 把当前目录下的 jpg文件 加密 \n" + Cur_Bat_Name
                    + " jpg_7_good  [索引7]   // 把当前目录下的 jpg文件 解密 \n" + Cur_Bat_Name
                    + " #_7_bad  [索引7]   // 把当前目录所有文件进行加密  加密文件在新的 时间戳文件夹中 \n" + Cur_Bat_Name
                    + " #_7_good  [索引7]   // 把当前目录所有文件进行解密  解密文件在新的 时间戳文件夹中 \n" + Cur_Bat_Name
                    + " #_7_bad_batch   [索引7]   // 把当前目录所有文件进行加密  加密文件在新的【 固定文件夹 bad_batch 】中 适合批量处理 \n" + Cur_Bat_Name
                    + " #_7_good_batch   [索引7]   // 把当前目录所有文件进行解密 解密文件在新的【 固定文件夹 good_batch 】中 适合批量处理 " + "\n"
                    + Cur_Bat_Name
                    + " #_7_good_zvi   [索引7]   // 把当前目录中的 1970ZVI  解密到新的文件夹在新的【 固定文件夹 1970ZVI_Good 】中 适合批量处理 \n";

        }

//                    return "把 当前目录下所有的 jpg  mp4 gif  都转为 i_temp1_1.jpg    v_temp2_1.mp4   g_temp3_1.gif 的文件格式\n" +
//        Cur_Bat_Name + "  jgm_5_recovery  [索引5]   // 在当前 Z_VI 根目录 计算 当前的 JPG GIF MP4的起始值 \n" +
//        Cur_Bat_Name + "  jgm_5_nextstep  [索引5]   //  JPG="+jpgBeginIndex+ " GIF="+gifBeginIndex+" MP4="+mp4BeginIndex+"  JPG增量="+nextStepCountJPG +"    GIF增量="+nextStepCountGIF + "   MP4增量="+nextStepCountMP4+" ▲【 把jpg gif png的增量添加到 beginIndex 然后增量置0 】 \n ";

        void jiamiAllDir(ArrayList<File> curFileList, HashMap<String, ArrayList<File>> subFileTypeMap,
                         ArrayList<File> curDirList, ArrayList<File> curRealFileList) {
            // 1.创建一个时间戳文件夹
            // 2.在当前文件夹的基础上

            SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd_HHmmss");// 设置日期格式
            String date = df.format(new Date());
            String CurBadDirName = "bad_AllFile_" + date;

            if (isBatchOperation) {
                if (mEncroptyDirect) {
                    CurBadDirName = "bad_batch";
                } else {
                    CurBadDirName = "good_batch";
                }
            }

            File curBadDirFile = new File(curDirFile.getAbsolutePath() + File.separator + CurBadDirName);
            curBadDirFile.mkdirs();
            String oldBasePath = curDirFile.getAbsolutePath();
            String newBasePath = curBadDirFile.getAbsolutePath();

            if (!curDirList.contains(curDirFile)) {
                curDirList.add(curDirFile);
            }

            for (int i = 0; i < curDirList.size(); i++) {
                File oldDirFile = curDirList.get(i);
                String newDirFilePath = oldDirFile.getAbsolutePath().replace(oldBasePath, newBasePath);
                File newDirFile = new File(newDirFilePath);
                newDirFile.mkdirs();

                for (int j = 0; j < oldDirFile.listFiles().length; j++) {

                    File oldRealFile = oldDirFile.listFiles()[j];
                    if (oldRealFile.isDirectory()) {
                        continue;
                    }

                    String newRealFilePath = oldRealFile.getAbsolutePath().replace(oldBasePath, newBasePath);
                    File newRealFile = new File(newRealFilePath);
                    // 加密操作
                    createEncryFile(oldRealFile, newRealFile);
                }

            }

            /*
             * for (int i = 0; i < curRealFileList.size(); i++) { File oldRealFile =
             * curRealFileList.get(i); String newRealFilePath =
             * oldRealFile.getAbsolutePath().replace(oldBasePath, newBasePath); File
             * newRealFile = new File(newRealFilePath); // 加密操作
             * createEncryFile(oldRealFile,newRealFile); }
             */

        }

        File getContainDirName(File curShellDir, String name, boolean isDir) {
            File targetFile = null;
            String absShellPath = curShellDir.getAbsolutePath();
            System.out.println(" 当前Shell的路径为: curDirFile =  " + absShellPath);
            File[] fileArr = curShellDir.listFiles();
            if (fileArr != null) {

                for (int i = 0; i < fileArr.length; i++) {
                    File fileItem = fileArr[i];
                    String fileName = fileItem.getName();
                    if (isDir) {
                        if (fileItem.isDirectory() && fileItem.exists()) {
                            if (fileName.equals(name)) {
                                return fileItem;
                            }
                        }
                    } else {
                        if (fileItem.isFile() && fileItem.exists()) {
                            if (fileName.equals(name)) {
                                return fileItem;
                            }
                        }

                    }

                }
            }

            return targetFile;

        }

        void jiemi1970ZVIDir(File m1970ZVI_DirFile, ArrayList<File> curFileList,
                             HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                             ArrayList<File> curRealFileList) {

            SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd_HHmmss");// 设置日期格式
            String date = df.format(new Date());
            String CurBadDirName = "1970ZVI_Good";

            // 1970ZVI_Good
            File curBadDirFile = new File(curDirFile.getAbsolutePath() + File.separator + CurBadDirName);

            curBadDirFile.mkdirs();
            // 1970ZVI路径 /C/1970ZVI
            String oldBasePath = curDirFile.getAbsolutePath(); // 原有的路径 /C
            String newBasePath = curBadDirFile.getAbsolutePath(); // 生成的 新路径 /C/1970ZVI_Good

            for (int i = 0; i < curDirList.size(); i++) {
                File oldDirFile = curDirList.get(i); // 原有的要解密文件
                String oldDirPath = oldDirFile.getAbsolutePath();
                if (!oldDirPath.contains("1970ZVI")) { // 如果当前目录 不包含 1970ZVI 那么 不创建这个目录
                    continue;
                }

                // 把 原有的 1970ZVI 路径 变化为 1970ZVI_Good 路径
                String newDirFilePath = oldDirFile.getAbsolutePath().replace(oldBasePath + File.separator + "1970ZVI",
                        newBasePath);
                System.out.println("AAAAAAAA  newBasePath=" + newBasePath + "  newDirFilePath=" + newDirFilePath);

                System.out.println("oldBasePath/1970ZVI --->  " + oldBasePath + File.separator + "1970ZVI   "
                        + "oldDirFile[" + i + "]  = " + oldDirFile.getAbsolutePath() + "  newDirFilePath[" + i + "] = "
                        + newDirFilePath);
                File newDirFile = new File(newDirFilePath);
                newDirFile.mkdirs();

                for (int j = 0; j < oldDirFile.listFiles().length; j++) {

                    File oldRealFile = oldDirFile.listFiles()[j];
                    String oldRealFile_Path = oldRealFile.getAbsolutePath();
                    if (oldRealFile.isDirectory()) {
                        continue;
                    }

                    if (isExpressType(oldRealFile)) {
                        continue;
                    }

                    // 如果原文件全路径 没有 1970ZVI 那么 不操作 这个文件
                    if (!oldRealFile_Path.contains("1970ZVI")) {
                        continue;
                    }

                    String newRealFilePath = oldRealFile.getAbsolutePath().replace("1970ZVI", "1970ZVI_Good");

                    String batch_fileName = oldRealFile.getName();
//						File newRealFile = new File(newBasePath + File.separator + batch_fileName);   //  子文件夹取消 消失

                    File newRealFile = new File(newRealFilePath); // 子文件夹存在
                    // 解密操作
                    System.out.println("执行当前 ZVI解密操作  batch_fileName = " + batch_fileName + "     newBasePath="
                            + newBasePath + "    newRealFile=" + newRealFile.getAbsolutePath());

                    createDecryFile(oldRealFile, newRealFile);

                }

            }

            /*
             * if(isZVIOperation) { // 如果是 zvi 操作 新的 地址要去掉 1970ZVI_Good/1970ZVI/xxx ->
             * 1970ZVI_Good/xxx if(newBasePath.contains(File.separator+"1970ZVI") &&
             * !newBasePath.endsWith(File.separator+"1970ZVI")) { newDirFilePath =
             * newDirFilePath.replace("1970ZVI", "").replace("_Good",
             * "1970ZVI_Good").replace(File.separator+File.separator, File.separator);
             * System.out.println("BBBBBBBB  newBasePath = "+ newBasePath
             * +"  newDirFilePath="+newDirFilePath); }else
             * if(newBasePath.endsWith(File.separator+"1970ZVI")) { newDirFilePath =
             * curBadDirFile.getAbsolutePath(); System.out.println("CCCCCC  newBasePath = "+
             * newBasePath);
             *
             * }
             *
             * }
             */

            /*
             * if(isZVIOperation) { // 解密操作 System.out.println("ZVI newRealFilePath = "+
             * newRealFilePath); newRealFilePath =
             * oldRealFile.getAbsolutePath().replace(oldBasePath,
             * newBasePath).replace("1970ZVI", "").replace("_Good",
             * "1970ZVI_Good").replace(File.separator+File.separator, File.separator); File
             * newRealFile = new File(newRealFilePath); createDecryFile(oldRealFile,
             * newRealFile); System.out.println("执行当前 ZVI 解密操作  batch_fileName = "+
             * batch_fileName
             * +"     newBasePath="+newBasePath+"    newRealFile="+newRealFile.
             * getAbsolutePath());
             *
             * }
             */

        }

        void jiemiAllDir(ArrayList<File> curFileList, HashMap<String, ArrayList<File>> subFileTypeMap,
                         ArrayList<File> curDirList, ArrayList<File> curRealFileList) {

            // 1.创建一个时间戳文件夹
            // 2.在当前文件夹的基础上
            System.out.println(" curDirFile =" + curDirFile.getAbsolutePath());

            if (isZVIOperation) {
                File zviFileDir = getContainDirName(curDirFile, "1970ZVI", true);
                if (zviFileDir != null) {

                    jiemi1970ZVIDir(zviFileDir, curFileList, subFileTypeMap, curDirList, curRealFileList);

                } else {
                    System.out.println(" 当前目录没有 1970ZVI 文件夹 无法执行   " + Cur_Bat_Name + " #_7_good_zvi   ## 批量解密操作！！！");
                }

                return;
            }

            SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd_HHmmss");// 设置日期格式
            String date = df.format(new Date());
            String CurBadDirName = "good_AllFile_" + date;

            if (isBatchOperation) {
                if (mEncroptyDirect) {
                    CurBadDirName = "bad_batch";
                } else {
                    CurBadDirName = "good_batch";
                }
            }

            File curBadDirFile = new File(curDirFile.getAbsolutePath() + File.separator + CurBadDirName);
            curBadDirFile.mkdirs();
            String oldBasePath = curDirFile.getAbsolutePath(); // 原有的路径 /C
            String newBasePath = curBadDirFile.getAbsolutePath(); // 生成的 新路径 /C/good_batch
            if (!curDirList.contains(curDirFile)) {
                curDirList.add(curDirFile);
            }

            System.out.println("执行当前所有文件 解密操作 newBasePath_Src =  " + newBasePath);

            System.out.println("执行当前所有文件  解密操作 newBasePath_Fixed =  " + newBasePath);

            System.out.println("执行当前所有文件 解密操作  curDirList.size() = " + curDirList.size());

            for (int i = 0; i < curDirList.size(); i++) {
                File oldDirFile = curDirList.get(i); // 原有的要解密文件

//				执行当前所有文件  解密操作  [0] = D:\BaiduNetdiskDownload\公式\bad_batch\A
                System.out.println("执行当前所有文件  解密操作  [" + i + "] = " + oldDirFile.getAbsolutePath());
                if (!isBatchOperation) { // 如果 不是 batch 那么会创建文件夹
                    // 如果是当前目录下多 子文件夹 那么就把在* 的 情况下会 创建这个文件夹 事实上在 batch的情况下不需要这个文件夹
                    String newDirFilePath = oldDirFile.getAbsolutePath().replace(oldBasePath, newBasePath);
                    System.out.println("AAAAAAAA  newBasePath=" + newBasePath + "  newDirFilePath=" + newDirFilePath);

                    System.out.println("oldDirFile[" + i + "]  = " + oldDirFile.getAbsolutePath() + "  newDirFilePath["
                            + i + "] = " + newDirFilePath);
                    File newDirFile = new File(newDirFilePath);
                    newDirFile.mkdirs();
                }

                for (int j = 0; j < oldDirFile.listFiles().length; j++) {

                    File oldRealFile = oldDirFile.listFiles()[j];
                    if (oldRealFile.isDirectory()) {
                        continue;
                    }

                    if (isExpressType(oldRealFile)) {
                        continue;
                    }

                    if (!isBatchOperation) { // 如果 不是 batch 那么会创建文件夹 和原来保持一致
                        String newRealFilePath = oldRealFile.getAbsolutePath().replace(oldBasePath, newBasePath);
                        File newRealFile = new File(newRealFilePath);
                        // 解密操作
                        createDecryFile(oldRealFile, newRealFile);
                    } else {

                        String newRealFilePath = oldRealFile.getAbsolutePath().replace(oldBasePath, newBasePath);

                        /*
                         * 执行当前 解密操作 执行当前所有文件 解密操作 [0] = D:\BaiduNetdiskDownload\公式\bad_batch\A ==
                         * oldDirFile.getAbsolutePath() batch_fileName = A.pdf == batch_fileName
                         * newBasePath=D:\BaiduNetdiskDownload\公式\bad_batch\good_batch
                         * newBasePath=D:\BaiduNetdiskDownload\公式\bad_batch\good_batch\A =====>
                         * newBasePath 应该还有一个 A newRealFilePath =
                         * D:\BaiduNetdiskDownload\公式\bad_batch\good_batch\A\A.pdf
                         * newRealFile=D:\BaiduNetdiskDownload\公式\bad_batch\good_batch\A.pdf
                         */

                        String batch_fileName = oldRealFile.getName();
//						File newRealFile = new File(newBasePath + File.separator + batch_fileName);   //  子文件夹取消 消失

                        File newRealFile = new File(newRealFilePath); // 子文件夹存在
                        // 解密操作
                        System.out.println("执行当前 解密操作  batch_fileName = " + batch_fileName + "     newBasePath="
                                + newBasePath + "    newRealFile=" + newRealFile.getAbsolutePath());
                        System.out.println(" newRealFilePath = " + newRealFilePath);
                        createDecryFile(oldRealFile, newRealFile);

                    }

                }
            }

//            for (int i = 0; i < curRealFileList.size(); i++) {
//                File oldRealFile = curRealFileList.get(i);
//                String newRealFilePath = oldRealFile.getAbsolutePath().replace(oldBasePath, newBasePath);
//                File newRealFile = new File(newRealFilePath);
//                // 加密操作
//                createDecryFile(oldRealFile,newRealFile);
//            }

        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            System.out.println("Rule7 搜索到的实体文件个数:  curRealFileList.size() =" + curRealFileList.size());
            if (isAllFileOperation) {
                if (mEncroptyDirect) {
                    // 加密所有文件夹

                    jiamiAllDir(curFileList, subFileTypeMap, getAllSubDirFile(curDirFile), curRealFileList);
                } else {
                    // 解密当前所有文件夹
                    jiemiAllDir(curFileList, subFileTypeMap, getAllSubDirFile(curDirFile), curRealFileList);

                }
                return null;
            }
            boolean containUserType = curFilterFileTypeList.contains("#"); // 是否包含用户选中的了文件类型 没有包含 那么就把所有实体realty 加密

            SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd_HHmmss");// 设置日期格式
            String date = df.format(new Date());// new Date()为获取当前系统时间，也可使用当前时间戳
            String curNewDirName = date;
            if (mEncroptyDirect) {
                curNewDirName += "_bad";
            } else {
                curNewDirName += "_good";
            }

            if (!containUserType) {
                curNewDirName += "_" + curFilterFileTypeList.get(0); // 1.如果所有文件都加密 那么没有后缀 如果某一个文件类型解密 那么添加后缀
            }
            if (isBatchOperation) {
                if (mEncroptyDirect) {
                    curNewDirName = "bad_batch";
                } else {
                    curNewDirName = "good_batch";
                }
            }

            File tempDirFile = new File(curDirFile.getAbsolutePath() + File.separator + curNewDirName);
            tempDirFile.mkdirs(); // 创建文件夹
            String tempDirPath = tempDirFile.getAbsolutePath();
            System.out.println("Rule7 搜索到的实体文件个数:" + curRealFileList.size());

            for (int i = 0; i < curRealFileList.size(); i++) {
                File curFile = curRealFileList.get(i);
                String currentFileName = File.separator + curFile.getName();

//                System.out.println("currentFileName = "+ currentFileName);
                if (mEncroptyDirect) { // 加密时 如果是 以 i_temp 开头 并且 以 .jpg 为结尾时 加密的类型去掉
                    if (currentFileName.contains(".jpg") && currentFileName.contains("i_temp")) {
                        currentFileName = currentFileName.replace(".jpg", "");
                    } else if (currentFileName.contains(".mp4") && currentFileName.contains("v_temp")) {
                        currentFileName = currentFileName.replace(".mp4", "");
                    } else if (currentFileName.contains(".gif") && currentFileName.contains("g_temp")) {
                        currentFileName = currentFileName.replace(".gif", "");
                    }

                    File badFile = new File(tempDirPath + File.separator + currentFileName);

                    createEncryFile(curFile, badFile);
                } else { // 解密 如果当前文件 不包含 .
                    if (!currentFileName.contains(".") && currentFileName.contains("i_temp")) {
                        currentFileName = currentFileName + ".jpg";
                    } else if (!currentFileName.contains(".") && currentFileName.contains("v_temp")) {
                        currentFileName = currentFileName + ".mp4";
                    } else if (!currentFileName.contains(".") && currentFileName.contains("g_temp")) {
                        currentFileName = currentFileName + ".gif";
                    }
                    File goodFile = new File(tempDirPath + File.separator + currentFileName);
                    System.out.println("createDecryFile goodFile = " + goodFile.getAbsolutePath() + "tempDirPath = "
                            + tempDirPath);
                    createDecryFile(curFile, goodFile);
                }
            }

            return null;
        }
    }

    static boolean isExpressType(File targetFile) {
        boolean flag = false;

        if (targetFile.isDirectory()) {
            return false;
        }

        String type = getFileTypeWithPoint(targetFile.getName());

        if (".7z".equals(type) || ".zip".equals(type) || ".rar".equals(type) || ".war".equals(type)) {
            return true;
        }

        return flag;

    }

    class SubDirRename_Rule_6 extends Basic_Rule {

        boolean isOrder_NoOriginName = false;

        SubDirRename_Rule_6() {
            super("#", 6, 4);
            isOrder_NoOriginName = false;
        }

        @Override
        String simpleDesc() {

            return Cur_Bat_Name + " #_6    // 修改当前的一级子目录下的文件夹 以及文件  按顺序命令 【序号_原名称.类型】  (不操作 孙文件 孙文件夹 )  \n"
                    + Cur_Bat_Name + " png_6    // 修改当前的一级子目录下的文件夹下的 png格式文件  按顺序命令 【序号_原名称.类型】  (不操作 孙文件 孙文件夹 ) \n"
                    + Cur_Bat_Name
                    + " png_6_order    // 修改当前的一级子目录下的文件夹下的 png格式文件  按顺序命令 【0000.png 0001.png 0002.png ....】  (不操作 孙文件 孙文件夹 ) \n"
                    + Cur_Bat_Name
                    + " m3u8_6_order  // 【type<可选>_6_order】 修改当前的目录下指定类型的 文件  按顺序命令[0000.m3u8 0001.m3u8] 【序号.类型】【不保留原名称】  (不操作 孙文件 孙文件夹 )  \n";
        }

        @Override
        boolean initParams4InputParam(String inputParam) {
            if (inputParam.contains("order")) {
                isOrder_NoOriginName = true;
            }

            return super.initParams4InputParam(inputParam);
        }

        @SuppressWarnings("unchecked")
        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {

            boolean executeFlag = false;
            boolean isFixedAllSubFlag = curFilterFileTypeList.contains("#");
            if (isFixedAllSubFlag) { // 只有包含 #_6 才对 文件夹进行操作 png_6 那么就只对 当前文件夹下的 png文件进行操作
                for (int i = 0; i < curDirList.size(); i++) {
                    File dir = curDirList.get(i);
                    String dirName = dir.getName();
                    String new_dirName = i + "_" + dirName;
                    tryReName(dir, new_dirName);
                }
            }

            Map.Entry<String, ArrayList<File>> entry;
            // 不同的类型文件怎么处理?

            if (subFileTypeMap != null) {
                Iterator iterator = subFileTypeMap.entrySet().iterator();
                while (iterator.hasNext()) {
                    entry = (Map.Entry<String, ArrayList<File>>) iterator.next();
                    String typeStr = entry.getKey(); // Map的Value
                    String typeWithOutPot = typeStr.replace(".", "");

                    if (!isFixedAllSubFlag && !curFilterFileTypeList.contains(typeWithOutPot)) {
                        // 如果 当前操作不是操作所有文件 并且这个类型不在匹配列表中 那么 不执行 返回next
                        // 如果是 全 操作 那么 往下执行
                        // 如果不是全操作 当前类型包含 那么往下执行
                        continue;
                    }

                    ArrayList<File> fileArr = entry.getValue(); // Map的Value

                    // 从 000 开始
//                    fixedFileIndex = fixedFileIndex ;
                    for (int i = 0; i < fileArr.size(); i++) {
                        File curFile = fileArr.get(i);
                        // String curFileName = curFile.getName();
                        String newName = i + "_" + curFile.getName();
                        String fileTypeStr = getFileTypeWithPoint(curFile.getName());
                        if (isOrder_NoOriginName) {
                            newName = getPaddingIntString(i, 4, "0", true) + fileTypeStr;
                        }
//                        String newName = typeTag+"_"+dirTempIndex+"_"+getPaddingIntString(fixedFileIndex,3,"0",true)+typeStr;
                        if (tryReName(curFile, newName)) {
                            executeFlag = true;
                        }
                    }
                }
            }
            return executeFlag ? curRealFileList
                    : super.applySubFileListRule4(curFileList, subFileTypeMap, curDirList, curRealFileList);
        }
    }

    public static String getFileNameNoPoint(File file) {
        String type = getFileTypeWithPoint(file.getName());
        String originname = file.getName();
        String resultName = originname.replace(type, "");
        return resultName;
    }

    public static String getFileNameNoPoint(String originName) {
        String type = getFileTypeWithPoint(originName);
        return originName.replace(type, "");
    }

    public static String getFileTypeWithPoint_unknow(String fileName) {
        String name = "";
        if (fileName.contains(".")) {
            name = fileName.substring(fileName.lastIndexOf(".")).trim().toLowerCase();
        } else {
            name = "";
        }
        return name.toLowerCase().trim();
    }

    public static String getFileTypeWithPoint(String fileName) {
        String name = "";
        if (fileName.contains(".")) {
            name = fileName.substring(fileName.lastIndexOf(".")).trim().toLowerCase();
        } else {
            name = "";
        }
        return name.toLowerCase().trim();
    }

    // 把 当前目录下所有的 jpg mp4 gif 都转为 i_temp1_1.jpg v_temp2_1.mp4 g_temp3_1.gif 的文件格式
    class AVI_Rule_5 extends Basic_Rule {
        String tempTag = "temp";
        boolean isTemp; // 是否是零时起的编号
        int mTempBeginIndex = 0; // 零时编号的默认起始地址

        boolean isRecovrty = false; // 当前是否是 读取当前目录 计算 ProPerities的值的操作
        boolean isEnable = true; // 当存在增量的时候 不起作用 不执行 记录的操作
        boolean isExistAddPart = false; // 是否存在增量
        boolean executeNextStep = false; // 当用户输入的 输入参数 包含 nextstep 时 执行 增量的 重置0操作 添加到index的操作

        int jpgBeginIndex = 0;
        int fixed_jpg_BeginIndex = 0;
        String jpgtag = "i";
        int jpgDirTempIndex = 0;
        int jpgEndIndex = 1;
        int nextStepCountJPG = 0; // 当前 JPG的 增量

        int gifBeginIndex = 0;
        String giftag = "g";
        int gifDirTempIndex = 0;
        int fixed_gif_BeginIndex = 0;
        int gifEndIndex = 1;
        int nextStepCountGIF = 0; // 当前 GIF的 增量

        int mp4BeginIndex = 0; // 从 Propertities 中读取到的值
        String mp4tag = "v"; // mp4的前缀
        int mp4DirTempIndex = 0; // 依据 mp4BeginIndex 计算出的 temp1 temp2 .... temp100
        int fixed_mp4_BeginIndex = 0; // 在当前 tempx 中的索引 大小为 mp4BeginIndex%1000
        int mp4EndIndex = 1; // 最后保存到 Propertities 中的 值
        int nextStepCountMP4 = 0; // 当前 MP4 的 增量

        AVI_Rule_5() {
            super("jgm", 5, 3);
            curFilterFileTypeList.add("jpg");
            curFilterFileTypeList.add("gif");
            curFilterFileTypeList.add("mp4");
            // 从 Proprietary 拿到当前的总的索引 值
            // jpgBeginIndex =
            // gifBeginIndex =
            // mp4BeginIndex =
            String strJPGBegin = G2_Properties.getProperty("jpgBeginIndex");
            if (strJPGBegin == null) {
                strJPGBegin = "0";
                G2_Properties.put("jpgBeginIndex", "0");
            }
            jpgBeginIndex = Integer.parseInt(strJPGBegin);

            String strGIFBegin = G2_Properties.getProperty("gifBeginIndex");
            if (strGIFBegin == null) {
                strGIFBegin = "0";
                G2_Properties.put("gifBeginIndex", "0");
            }
            gifBeginIndex = Integer.parseInt(strGIFBegin);

            String strMP4Begin = G2_Properties.getProperty("mp4BeginIndex");
            if (strMP4Begin == null) {
                strMP4Begin = "0";
                G2_Properties.put("mp4BeginIndex", "0");
            }
            mp4BeginIndex = Integer.parseInt(strMP4Begin);

            String strNextStepJPG = G2_Properties.getProperty("nextStepCountJPG");
            if (strNextStepJPG == null) {
                strNextStepJPG = "0";
                G2_Properties.put("nextStepCountJPG", "0");
            }
            nextStepCountJPG = Integer.parseInt(strNextStepJPG);

            String strNextStepGIF = G2_Properties.getProperty("nextStepCountGIF");
            if (strNextStepGIF == null) {
                strNextStepGIF = "0";
                G2_Properties.put("nextStepCountGIF", "0");
            }
            nextStepCountGIF = Integer.parseInt(strNextStepGIF);

            String strNextStepMP4 = G2_Properties.getProperty("nextStepCountMP4");
            if (strNextStepMP4 == null) {
                strNextStepMP4 = "0";
                G2_Properties.put("nextStepCountMP4", "0");
            }
            nextStepCountMP4 = Integer.parseInt(strNextStepMP4);

            if (nextStepCountMP4 != 0 || nextStepCountGIF != 0 || nextStepCountJPG != 0) {
                isExistAddPart = true;
            }

            jpgDirTempIndex = jpgBeginIndex / 1000;
            fixed_jpg_BeginIndex = jpgBeginIndex % 1000;

            gifDirTempIndex = gifBeginIndex / 1000;
            fixed_gif_BeginIndex = gifBeginIndex % 1000;

            mp4DirTempIndex = mp4BeginIndex / 1000;
            fixed_mp4_BeginIndex = mp4BeginIndex % 1000;

        }

        @Override
        String simpleDesc() {
            return "把 当前目录下所有的 jpg  mp4 gif  都转为 i_temp1_1.jpg    v_temp2_1.mp4   g_temp3_1.gif 的文件格式\n" + Cur_Bat_Name
                    + "  jgm_5_temp0      [索引5]   // 零时把当前gif jpg mp4 类型 起始位置设置为0   \n" + Cur_Bat_Name
                    + "  jgm_5_temp99      [索引5]   // 零时把当前gif jpg mp4 类型 起始位置设置为99   \n" + Cur_Bat_Name
                    + "  jgm_5_recovery  [索引5]   // 在当前 Z_VI 根目录 计算 当前的 JPG GIF MP4的起始值 \n" + Cur_Bat_Name
                    + "  jgm_5_nextstep  [索引5]   //  JPG=" + jpgBeginIndex + " GIF=" + gifBeginIndex + " MP4="
                    + mp4BeginIndex + "  JPG增量=" + nextStepCountJPG + "    GIF增量=" + nextStepCountGIF + "   MP4增量="
                    + nextStepCountMP4 + " ▲【 把jpg gif png的增量添加到 beginIndex 然后增量置0 】 \n ";
        }

        @Override
        boolean initParams4InputParam(String inputParam) {

            if (inputParam.contains("temp")) {
                int index = inputParam.indexOf("temp") + "temp".length();
                String tempIndexStr = inputParam.substring(index);
                if (isNumeric(tempIndexStr)) {
                    mTempBeginIndex = Integer.parseInt(tempIndexStr);
                } else {
                    if (tempIndexStr.contains("_")) {
                        String blankIndex = tempIndexStr.substring(0, tempIndexStr.indexOf("_"));
                        if (isNumeric(blankIndex)) {
                            mTempBeginIndex = Integer.parseInt(blankIndex);
                        }
                    } else {
                        mTempBeginIndex = 0; // 默认为0
                    }
                }

                isTemp = true;
            }
            if (inputParam.contains("nextstep")) {
                executeNextStep = true;
            }

            if (inputParam.contains("_recovery")) {
                isRecovrty = true;
                isEnable = false;
                curFilterFileTypeList.add("#"); // 把当前所有文件都加入到列表中
            }
            System.out.println("OLD记录的Properties信息:(OLD)   " + " JPG=" + jpgBeginIndex + "   GIF=" + gifBeginIndex
                    + "   MP4=" + mp4BeginIndex + "  JPG增量=" + nextStepCountJPG + "    GIF增量=" + nextStepCountGIF
                    + "   MP4增量=" + nextStepCountMP4);

            if (executeNextStep) { // 如果存在增量 当前不执行 并且用户是输入的 nextstep的时候 执行 step的更新
                jpgBeginIndex = jpgBeginIndex + nextStepCountJPG;
                gifBeginIndex = gifBeginIndex + nextStepCountGIF;
                mp4BeginIndex = mp4BeginIndex + nextStepCountMP4;
                G2_Properties.setProperty("jpgBeginIndex", "" + jpgBeginIndex);
                G2_Properties.setProperty("gifBeginIndex", "" + gifBeginIndex);
                G2_Properties.setProperty("mp4BeginIndex", "" + mp4BeginIndex);
                G2_Properties.setProperty("nextStepCountJPG", "" + 0);
                G2_Properties.setProperty("nextStepCountGIF", "" + 0);
                G2_Properties.setProperty("nextStepCountMP4", "" + 0);
                isEnable = false;
            }

            return super.initParams4InputParam(inputParam);
        }

        void tryDynamicCalCulateBeginIndex(ArrayList<File> subFileList) {

            String jpg_pre = "i_temp";
            ArrayList<File> jpgTempList = new ArrayList<File>();

            String gif_pre = "g_temp";
            ArrayList<File> gifTempList = new ArrayList<File>();

            String mp4_pre = "v_temp";
            ArrayList<File> mp4TempList = new ArrayList<File>();

            for (int i = 0; i < subFileList.size(); i++) {
                File curFile = subFileList.get(i);
                if (curFile.getAbsolutePath().contains("Z_VI")) {
                    if (curFile.getName().startsWith(jpg_pre)) {
                        jpgTempList.add(curFile);
                    } else if (curFile.getName().startsWith(gif_pre)) {
                        gifTempList.add(curFile);
                    } else if (curFile.getName().startsWith(mp4_pre)) {
                        mp4TempList.add(curFile);
                    }
                }

            }

            if (jpgTempList.size() == 0 && gifTempList.size() == 0 && mp4TempList.size() == 0) {
                System.out.println("当前执行目录不在 Z_VI的根目录 Git_Dir , 请重新执行 " + Cur_Bat_Name);
                return;
            }

            // 通过 搜索 计算得到的 type 文件的 长度 Count
            // 通过 计算 文件最后的名字得到的 index = Count - 1
            int jpgDynimicCount = jpgTempList.size();
            int gifDynimicCount = gifTempList.size();
            int mp4DynimicCount = mp4TempList.size();

            jpgTempList.sort(new Comparator<File>() {
                @Override
                public int compare(File o1, File o2) {

                    int o1Index = calculIndexFromName(o1.getName());

                    int o2Index = calculIndexFromName(o2.getName());
                    if (o1Index < o2Index) {
                        return -1;
                    }
                    if (o1Index == o2Index) {
                        return 0;
                    }
                    return 1;
                }
            });

            gifTempList.sort(new Comparator<File>() {
                @Override
                public int compare(File o1, File o2) {

                    int o1Index = calculIndexFromName(o1.getName());

                    int o2Index = calculIndexFromName(o2.getName());
                    if (o1Index < o2Index) {
                        return -1;
                    }
                    if (o1Index == o2Index) {
                        return 0;
                    }
                    return 1;
                }
            });

            // Comparable VICompare = new Comparable()
            mp4TempList.sort(new Comparator<File>() {
                @Override
                public int compare(File o1, File o2) {

                    int o1Index = calculIndexFromName(o1.getName());

                    int o2Index = calculIndexFromName(o2.getName());
                    if (o1Index < o2Index) {
                        return -1;
                    }
                    if (o1Index == o2Index) {
                        return 0;
                    }
                    return 1;
                }
            });
            File lastJPGFile = null;
            File lastGIFFile = null;
            File lastMP4File = null;

            if (jpgTempList.size() > 0) {
                lastJPGFile = jpgTempList.get(jpgTempList.size() - 1);
            }

            if (gifTempList.size() > 0) {
                lastGIFFile = gifTempList.get(gifTempList.size() - 1);
            }

            if (mp4TempList.size() > 0) {
                lastMP4File = mp4TempList.get(mp4TempList.size() - 1);
            }

            int jpgLastIndex = 0;
            int gifLastIndex = 0;
            int mp4LastIndex = 0;
            if (lastJPGFile != null) {
                jpgLastIndex = calculIndexFromName(lastJPGFile.getName());
            }
            if (lastGIFFile != null) {
                gifLastIndex = calculIndexFromName(lastGIFFile.getName());

            }
            if (lastMP4File != null) {
                mp4LastIndex = calculIndexFromName(lastMP4File.getName());
            }

            if (jpgDynimicCount != jpgBeginIndex || (jpgLastIndex + 1) != jpgDynimicCount) { // 大小 和 记录的起始点 不一致 那么需要
                // 重新该名称
                for (int i = 0; i < jpgTempList.size(); i++) {
                    File jpgFile = jpgTempList.get(i);
                    String jpgFileName = "i" + "_" + getPaddingIntStringWithDirIndexFileNameWithIndex(tempTag,
                            gifDirTempIndex, 0, i, 3, "0", true);
                    tryReName(jpgFile, jpgFileName);
                }
            }

            if (gifDynimicCount != gifBeginIndex || (gifLastIndex + 1) != gifDynimicCount) { // 大小 和 记录的起始点 不一致 那么需要
                // 重新该名称
                for (int i = 0; i < gifTempList.size(); i++) {
                    File gifFile = gifTempList.get(i);
                    String gifFileName = "g" + "_" + getPaddingIntStringWithDirIndexFileNameWithIndex(tempTag,
                            gifDirTempIndex, 0, i, 3, "0", true);
                    tryReName(gifFile, gifFileName);
                }
            }

            if (mp4DynimicCount != mp4BeginIndex || (mp4LastIndex + 1) != mp4DynimicCount) { // 大小 和 记录的起始点 不一致 那么需要
                // 重新该名称
                for (int i = 0; i < mp4TempList.size(); i++) {
                    File mp4File = mp4TempList.get(i);
                    String mp4FileName = "v" + "_" + getPaddingIntStringWithDirIndexFileNameWithIndex(tempTag,
                            gifDirTempIndex, 0, i, 3, "0", true);
                    tryReName(mp4File, mp4FileName);
                }
            }

            System.out.println("recovery 搜索到的文件 数量:" + subFileList.size());
            if (lastJPGFile != null) {
                jpgLastIndex = calculIndexFromName(lastJPGFile.getName());
                System.out.println("最后一个 JPG 文件的名称为:" + lastJPGFile.getName() + "  索引:" + jpgLastIndex
                        + (jpgLastIndex != (jpgBeginIndex - 1) ? " 匹配不成功(改名操作)" : "匹配成功"));

            }
            if (lastGIFFile != null) {
                gifLastIndex = calculIndexFromName(lastGIFFile.getName());
                System.out.println("最后一个 GIF 文件的名称为:" + lastGIFFile.getName() + "  索引:" + gifLastIndex
                        + (gifLastIndex != (gifBeginIndex - 1) ? " 匹配不成功(改名操作)" : "匹配成功"));

            }
            if (lastMP4File != null) {
                mp4LastIndex = calculIndexFromName(lastMP4File.getName());
                System.out.println("最后一个 MP4 文件的名称为:" + lastMP4File.getName() + "  索引:" + mp4LastIndex
                        + (mp4LastIndex != (mp4BeginIndex - 1) ? " 匹配不成功(改名操作)" : "匹配成功"));
            }
            System.out.println(
                    "jpgDynimicIndex(JPG动态计算文件数量)=" + getXsizeString(jpgDynimicCount, 7) + "   (最后一个JPG文件名称索引+1)"
                            + getXsizeString(jpgLastIndex + 1, 7) + " ||    Pro记录 jpgBeginIndex 为:" + jpgBeginIndex);
            System.out.println(
                    "gifDynimicIndex(GIF动态计算文件数量)=" + getXsizeString(gifDynimicCount, 7) + "   (最后一个GIF文件名称索引+1)"
                            + getXsizeString(gifLastIndex + 1, 7) + " ||    Pro记录 gifBeginIndex 为:" + gifBeginIndex);
            System.out.println(
                    "mp4DynimicIndex(MP4动态计算文件数量)=" + getXsizeString(mp4DynimicCount, 7) + "   (最后一个MP4文件名称索引+1)"
                            + getXsizeString(mp4LastIndex + 1, 7) + " ||    Pro记录 mp4BeginIndex 为:" + mp4BeginIndex);

            recoveryProperities(jpgDynimicCount, gifDynimicCount, mp4DynimicCount);
            System.out.println();
        }

        int calculIndexFromName(String viName) {

            String valueA = viName.replace("_", "");
            valueA = valueA.replace("gif", "");
            valueA = valueA.replace("jpg", "");
            valueA = valueA.replace("mp4", "");
            valueA = valueA.replace("mp3", "");
            valueA = valueA.replace("png", "");
            valueA = valueA.replace("temp", "");
            valueA = valueA.replace("\"", "");
            valueA = valueA.replace(".", "");
            valueA = valueA.replace("(", "");
            valueA = valueA.replace(")", "");
            valueA = valueA.replace("）", "");
            valueA = valueA.replace("（", "");

            valueA = valueA.replace("a", "");
            valueA = valueA.replace("b", "");
            valueA = valueA.replace("c", "");
            valueA = valueA.replace("d", "");
            valueA = valueA.replace("e", "");
            valueA = valueA.replace("f", "");
            valueA = valueA.replace("g", "");
            valueA = valueA.replace("h", "");
            valueA = valueA.replace("i", "");
            valueA = valueA.replace("j", "");
            valueA = valueA.replace("k", "");
            valueA = valueA.replace("l", "");
            valueA = valueA.replace("m", "");
            valueA = valueA.replace("n", "");
            valueA = valueA.replace("o", "");
            valueA = valueA.replace("p", "");
            valueA = valueA.replace("q", "");
            valueA = valueA.replace("r", "");
            valueA = valueA.replace("s", "");
            valueA = valueA.replace("t", "");
            valueA = valueA.replace("u", "");
            valueA = valueA.replace("v", "");
            valueA = valueA.replace("w", "");
            valueA = valueA.replace("x", "");
            valueA = valueA.replace("y", "");
            valueA = valueA.replace("z", "");
            valueA = valueA.replace(" ", "").trim();
            int resultIndex = 0;
            try {
                resultIndex = Integer.parseInt(valueA);

            } catch (Exception e) {
                resultIndex = 0;
            }

            return resultIndex;
        }

        void recoveryProperities(int jpg, int gif, int mp4) {
            jpgBeginIndex = jpg;
            gifBeginIndex = gif;
            mp4BeginIndex = mp4;
            G2_Properties.setProperty("jpgBeginIndex", "" + jpg);
            G2_Properties.setProperty("gifBeginIndex", "" + gif);
            G2_Properties.setProperty("mp4BeginIndex", "" + mp4);
            G2_Properties.setProperty("nextStepCountJPG", "" + 0);
            G2_Properties.setProperty("nextStepCountGIF", "" + 0);
            G2_Properties.setProperty("nextStepCountMP4", "" + 0);

            System.out.println(" Z_VI(Git_Dir)恢复Pro数:(New)    JPG=" + jpgBeginIndex + "   GIF=" + gifBeginIndex
                    + "   MP4=" + mp4BeginIndex + "  JPG增量=0    GIF增量=0   MP4增量=0");
        }

        @SuppressWarnings("unchecked")
        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {
            boolean executeFlag = false;

            if (isRecovrty) { // 如果是要恢复的的话
                tryDynamicCalCulateBeginIndex(subFileList);
                return null;
            }

            String oldAddPart = "OLD 记录的Properties增量:(OLD)   " + " JPG=" + jpgBeginIndex + "   GIF=" + gifBeginIndex
                    + "   MP4=" + mp4BeginIndex + "  JPG增量=" + nextStepCountJPG + "    GIF增量=" + nextStepCountGIF
                    + "   MP4增量=" + nextStepCountMP4;
            if (!isEnable) {
                System.out.println("当前 Rule5 规则上的增量已经置0  增量已得到确认  请开始累计新的资源! ");
                System.out.println("当前记录到Prop的增量信息:(New)  " + " JPG=" + jpgBeginIndex + "   GIF=" + gifBeginIndex
                        + "   MP4=" + mp4BeginIndex + "  JPG增量=" + 0 + "    GIF增量=" + 0 + "   MP4增量=" + 0);

                return null;
            }
            if (isExistAddPart) {
                System.out.println("当前 Rule5 规则存在上次还未确认的增量 请执行如下命令来确认增量 使得NextStep完成\n" + Cur_Bat_Name
                        + " jgm_5_nextstep      // ▲【 把jpg gif png的增量添加到 beginIndex 然后增量置0 】 \n ");
            }
            Map.Entry<String, ArrayList<File>> entry;
            int nextStepCountJPG_new = 0;
            int nextStepCountGIF_new = 0;
            int nextStepCountMP4_new = 0;
            if (fileTypeMap != null) {
                Iterator iterator = fileTypeMap.entrySet().iterator();
                while (iterator.hasNext()) {
                    entry = (Map.Entry<String, ArrayList<File>>) iterator.next();
                    String typeStr = entry.getKey(); // Map的Value
                    ArrayList<File> fileArr = entry.getValue(); // Map的Value
                    String typeTag = jpgtag;
                    String dirTempIndex = tempTag + jpgDirTempIndex;
                    int tempIndex = 1;
                    int fixedFileIndex = 0;
                    if (".jpg".equals(typeStr)) {
                        typeTag = jpgtag;
                        dirTempIndex = tempTag + jpgDirTempIndex;
                        fixedFileIndex = jpgBeginIndex;
                        tempIndex = jpgDirTempIndex;
                        nextStepCountJPG = fileArr.size();
                        nextStepCountJPG_new = fileArr.size();
                        if (!isTemp)
                            G2_Properties.setProperty("nextStepCountJPG", "" + nextStepCountJPG);
                        jpgEndIndex = jpgBeginIndex + fileArr.size();
                        System.out.println("当前JPG起始值:" + fixedFileIndex + "    当前GIF的文件长度:" + fileArr.size());
                    } else if (".mp4".equals(typeStr)) {
                        typeTag = mp4tag;
                        dirTempIndex = tempTag + mp4DirTempIndex;
                        fixedFileIndex = mp4BeginIndex;
                        tempIndex = mp4DirTempIndex;
                        nextStepCountMP4 = fileArr.size();
                        nextStepCountMP4_new = fileArr.size();
                        if (!isTemp)
                            G2_Properties.setProperty("nextStepCountMP4", "" + nextStepCountMP4);

                        mp4EndIndex = mp4BeginIndex + fileArr.size();
                        System.out.println("当前MP4起始值:" + fixedFileIndex + "    当前GIF的文件长度:" + fileArr.size());
                    } else if (".gif".equals(typeStr)) {
                        typeTag = giftag;
                        dirTempIndex = tempTag + gifDirTempIndex;
                        fixedFileIndex = gifBeginIndex;
                        tempIndex = gifDirTempIndex;
                        nextStepCountGIF = fileArr.size();
                        System.out.println("当前GIF起始值:" + fixedFileIndex + "    当前GIF的文件长度:" + fileArr.size());
                        nextStepCountGIF_new = fileArr.size();
                        if (!isTemp)
                            G2_Properties.setProperty("nextStepCountGIF", "" + nextStepCountGIF);
                        gifEndIndex = gifBeginIndex + fileArr.size();

                    } else {
                        continue;
                    }

                    if (isTemp) {
                        fixedFileIndex = mTempBeginIndex; // 如果是 temp 那么 默认 就把 temp转为 index
                        nextStepCountJPG_new = 0;
                        nextStepCountGIF_new = 0;
                        nextStepCountMP4_new = 0;
                    }
                    // 从 000 开始
//                    fixedFileIndex = fixedFileIndex ;

                    for (int i = 0; i < fileArr.size(); i++) {

                        File curFile = fileArr.get(i);
                        // String curFileName = curFile.getName();
                        String newName = typeTag + "_" + getPaddingIntStringWithDirIndexFileNameWithIndex(tempTag,
                                gifDirTempIndex, fixedFileIndex, i, 3, "0", true) + typeStr;

//                        String newName = typeTag+"_"+dirTempIndex+"_"+getPaddingIntString(fixedFileIndex,3,"0",true)+typeStr;

                        if (tryReName(curFile, newName)) {
                            executeFlag = true;
                        }
//                        fixedFileIndex++;
                    }
                }
            }

            String NewAddPart = "New 记录的Properties增量:(New)   " + " JPG=" + jpgBeginIndex + "   GIF=" + gifBeginIndex
                    + "   MP4=" + mp4BeginIndex + "  JPG增量=" + nextStepCountJPG_new + "    GIF增量="
                    + nextStepCountGIF_new + "   MP4增量=" + nextStepCountMP4_new;

            System.out.println("══════════确认增量信息 Begin══════════");
            if (isExistAddPart) {
                // System.out.println("Rule5 上次的增量情况:");
                System.out.println(oldAddPart);
            } else {
                System.out.println("OLD     上次的不存在增量:(OLD)    JPG=" + jpgBeginIndex + "   GIF=" + gifBeginIndex
                        + "   MP4=" + mp4BeginIndex + " JPG增量=0     GIF增量=0     MP4增量=0");
            }
            // System.out.println("\nRule5 现在的增量情况: ");
            System.out.println(NewAddPart);

            System.out.println("New 现在使用如下命令把 New 当前的增量进行确认! \n" + Cur_Bat_Name
                    + " jgm_5_nextstep      // ▲【 把jpg gif png的增量添加到 beginIndex 然后增量置0 】 \n ");
            System.out.println("══════════确认增量信息 End══════════");
            if (executeFlag) {
                return curFixedFileList;
            }
            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        // 从 起始的地址 beginIndex 开始计算
        String getPaddingIntStringWithDirIndexFileNameWithIndex(String cTempTag, int CurrentTempIndex, int beginIndex,
                                                                int index, int padinglength, String oneStr, boolean dirPre) {

            int indexIdentify = beginIndex + index;
            int tempIndexResult = (indexIdentify / 1000);
            String result = "" + getXsizeString((indexIdentify % 1000), oneStr, padinglength, dirPre);
            return cTempTag + tempIndexResult + "_" + result;

        }

        // 不从起始的地址 计算 从0，1,2,3.... 开始计算
        String getPaddingIntStringWithDirIndexFileName(String cTempTag, int CurrentTempIndex, int index,
                                                       int padinglength, String oneStr, boolean dirPre) {

            int tempIndexA = (index / 1000);
            int tempIndexResult = CurrentTempIndex + tempIndexA;

            String result = "" + getXsizeString((index % 1000), oneStr, padinglength, dirPre);

            /*
             * int length = (""+index).length();
             *
             * if(length < padinglength){ int distance = padinglength - length; for (int i =
             * 0; i < distance; i++) { if(dirPre){ result = oneStr+result; }else{ result =
             * result + oneStr; }
             *
             * }
             *
             * }
             */

            return cTempTag + tempIndexResult + "_" + result;

        }

        String getXsizeString(int index, int paddingSize) {

            return getXsizeString(index, " ", paddingSize, true);

        }

        String getXsizeString(int index, String charOne, int paddingSize, boolean directPre) {
            String result = ("" + index);
            int length = ("" + index).length();
            if (length < paddingSize) {
                int distance = paddingSize - length;
                for (int i = 0; i < distance; i++) {
                    if (directPre) {
                        result = charOne + result;
                    } else {
                        result = result + charOne;
                    }

                }
            }
            return result;
        }

    }

    // 把 当前目录下所有的 png jpeg 都转为 jpg的格式
    class Image2Png_Rule_4 extends Basic_Rule {
        String targetFileType = ".png";

        Image2Png_Rule_4() {
            super("png", 4, 3);
            curFilterFileTypeList.add(".jpeg");
            curFilterFileTypeList.add(".JPEG");
            curFilterFileTypeList.add(".jpg");
            curFilterFileTypeList.add(".JPG");
            curFilterFileTypeList.add(".PNG");
            targetFileType = ".png";
        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {
            boolean falg = false;
            for (int i = 0; i < subFileList.size(); i++) {
                File imageFile = subFileList.get(i);
                String fileName = imageFile.getName();
                String newName = fileName.replace(".jpeg", targetFileType);
                newName = newName.replace(".jpg", targetFileType);
                newName = newName.replace(".JPEG", targetFileType);
                newName = newName.replace(".JPG", targetFileType);
                newName = newName.replace(".PNG", targetFileType);
                if (tryReName(imageFile, newName)) {
                    falg = true;
                }
            }

            if (falg) {
                return curFixedFileList;
            }
            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        @Override
        String simpleDesc() {
            return " 把当前目录(包含子目录)所有的 .jpg .jpeg 的文件后缀改为 .png 的文件后缀";
        }
    }

    // 把 当前目录下所有的 png jpeg 都转为 jpg的格式
    class Image2Jpeg_Rule_3 extends Basic_Rule {
        String targetFileType = ".jpg";

        Image2Jpeg_Rule_3() {
            super("jpg", 3, 3);
            curFilterFileTypeList.add(".jpeg");
            curFilterFileTypeList.add(".JPEG");
            curFilterFileTypeList.add(".JPG");
            curFilterFileTypeList.add(".png");
            curFilterFileTypeList.add(".PNG");
            targetFileType = ".jpg";
        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {
            boolean falg = false;
            for (int i = 0; i < subFileList.size(); i++) {
                File imageFile = subFileList.get(i);
                String fileName = imageFile.getName();
                String newName = fileName.replace(".jpeg", targetFileType);
                newName = newName.replace(".png", targetFileType);
                newName = newName.replace(".JPEG", targetFileType);
                newName = newName.replace(".PNG", targetFileType);
                newName = newName.replace(".JPG", targetFileType);
                if (tryReName(imageFile, newName)) {
                    falg = true;
                }
            }

            if (falg) {
                return curFixedFileList;
            }
            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        @Override
        String simpleDesc() {
            return " 把当前目录(包含子目录)所有的 .png .jpeg 的文件后缀改为 .jpg 的文件后缀";
        }
    }

    // 指定什么类型的文件在当前使用什么样的规则
    // operation_type 操作类型
    // 1--读取文件内容字符串 进行修改 String applyOperationRule(String origin)
    // 2--对单个文件属性进行修改(文件名称) 对文件内容(字节)--进行修改 File applyFileByteOperationRule(File
    // originFile)
    // 3--对集合文件属性进行修改(文件名称) 对所有子文件--进行修改 ArrayList<File>
    // applyFileByteOperationRule(ArrayList<File> subFileList)
    // index 唯一指定的一种 rule规则

    // file_name_2 #_2 对当前目录下的所有文件进行 文件名称的重新命名 命名规则 在头部添加序号

    class File_Name_Rule_2 extends Basic_Rule {

        // key = type value = 符合过滤文件规则的名称的文件的集合
        // HashMap<String, ArrayList<File>> arrFileMap;
        boolean keepOriginalName = true;
        int inputBeginIndex = 0;

        boolean isOrder_Padding5 = false; // 是否 以 00000.jpg 00001.jpg 00002.jpg 这样命名
        // 是否是按 1.jpg 2,jpg 3.png 4.png 依次命名 而不是 1.jpg 2,jpg 1.png 2.png 类型来命名
        boolean isOrder = false;

        File_Name_Rule_2() {
            super("#", 2, 3); //
        }

        @SuppressWarnings("unchecked")
        boolean tryReNameOperation(HashMap<String, ArrayList<File>> arrFileMap) {
            boolean executeFlag = false;
            Map.Entry<String, ArrayList<File>> entry;
            int fileOrderIndex = 0;
//            System.out.println("1 fileOrderIndex = "+ fileOrderIndex);
            if (fileOrderIndex != inputBeginIndex && inputBeginIndex != 0) {
                fileOrderIndex = inputBeginIndex - 1;
            }
//            System.out.println("2 fileOrderIndex = "+ fileOrderIndex);
//            System.out.println("3 inputBeginIndex = "+ inputBeginIndex);
            if (arrFileMap != null) {
                Iterator iterator = arrFileMap.entrySet().iterator();
                while (iterator.hasNext()) {
                    entry = (Map.Entry<String, ArrayList<File>>) iterator.next();
                    String typeStr = entry.getKey(); // Map的Value
                    ArrayList<File> fileArr = entry.getValue(); // Map的Value

                    for (int i = 0; i < fileArr.size(); i++) {
                        fileOrderIndex++;
                        int index = i + 1;
                        String newNamePre = (isOrder_Padding5 ? getPaddingIntString(index, 5, "0", true) : index) + "_";
                        File curFile = fileArr.get(i);
                        String curFileName = curFile.getName();
                        String newName = "";
                        if (keepOriginalName) {
                            if (isOrder) { // 按顺序依次 不按 type了 一直走
                                newName = (isOrder_Padding5 ? getPaddingIntString(fileOrderIndex, 5, "0", true)
                                        : fileOrderIndex) + "_" + curFileName + typeStr;
                            } else {
                                newName = newNamePre + curFileName + typeStr;
                            }
                        } else {
                            // 如果不保留名称 那么没有类型的文件 将只有 序号 没有类型
                            if ("unknow".equals(typeStr)) {
                                newName = (isOrder_Padding5 ? getPaddingIntString(index, 5, "0", true) : index) + "";
                            } else {
                                if (isOrder) { // 按顺序依次 不按 type了 一直走
                                    newName = (isOrder_Padding5 ? getPaddingIntString(fileOrderIndex, 5, "0", true)
                                            : fileOrderIndex) + typeStr;
                                } else {
                                    newName = (isOrder_Padding5 ? getPaddingIntString(index, 5, "0", true) : index)
                                            + typeStr;
                                }

                            }
                        }
                        if (tryReName(curFile, newName)) {
                            executeFlag = true;
                        }
                        System.out.println("index=[" + i + "] typeStr[" + typeStr + "]  newName[" + newName
                                + "]  keepOriginalName=[" + keepOriginalName + "]  isOrder[" + isOrder
                                + "]  isOrder_Padding5[" + isOrder_Padding5 + "]");
                    }

                }
            }

            return executeFlag;
        }

        @Override
        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {

            if (tryReNameOperation(fileTypeMap)) {
                return curFixedFileList;
            }

            return super.applyFileListRule3(subFileList, fileTypeMap);
        }

        boolean initParams4InputParam(String inputParams) {
            if (inputParams.contains("_false")) {
                keepOriginalName = false;
            } else {
                keepOriginalName = true;
            }

            if (inputParams.contains("_order")) {
                isOrder = true;
            } else {
                isOrder = false;
            }

            if (inputParams.contains("padding5")) {
                isOrder_Padding5 = true;
            } else {
                isOrder_Padding5 = false;
            }

            if (inputParams.contains("_")) {
                String[] inputParamArr = inputParams.split("_");
                if (inputParamArr.length > 0 && isNumeric(inputParamArr[inputParamArr.length - 1].trim())) {
                    inputBeginIndex = Integer.parseInt(inputParamArr[inputParamArr.length - 1].trim());
//                    System.out.println(" 0 inputBeginIndex = "+ inputBeginIndex);
                }
            }

            return super.initParams4InputParam(inputParams);

        }

        String ruleTip(String type, int index, String batName, OS_TYPE curType) {
            String itemDesc = "";
            String desc_true = " (保留原名称) 把当前的所有子文件(非目录)重命名为 【序号_原始名称.类型】的形式 例如 hello.jpg =》 1_hello.jpg  xx.jpg-》2_xx.jpg    001/4.jpg -> 001/3_4.jpg(不同文件夹)   保留原有名称 相同类型文件不同文件夹 使用同一个序列号   ";
            String desc_true_1 = " (保留原名称_按类型依次从1开始 order ) 把当前的所有子文件(非目录)重命名为 【序号_原始名称.类型 走到底】的形式 例如 hello.jpg =》 1_hello.jpg  xx.jpg-》2_xx.jpg   aa.png -> 3_aa.png  | 001/4.zip ->  001/4_4.zip  保留原有名称 不相同类型文件不同文件夹 使用同一个序列号 ";
            String desc_true_2 = " (保留原名称_依照输入索引为起始 order ) 把当前的所有子文件(非目录)重命名为 【自定义序号_原始名称.类型 走到底】的形式 例如 #_2_false_order_50  hello.jpg =》 50_hello.jpg  xx.jpg-》51_xx.jpg   aa.png -> 52_aa.png 保留原有名称 不相同类型文件不同文件夹 使用同一个序列号(序号自定义) ";

            String desc_false = "(清除原名称) 把当前的所有子文件(非目录)重命名为 【序号.类型】的形式 例如 hello.jpg =》 1.jpg  xx.png-》1.jpg   不保留原有名称 相同类型文件不同文件夹 使用同一个序列号";
            String desc_false_1 = "(清除原名称_按类型依次 order ) 把当前的所有子文件(非目录)重命名为 【序号.类型 走到底 】的形式 例如 hello.jpg =》 1.jpg  xx.jpg-》2_xx.jpg  xx.png-》3.png  xx.png-》4.png  不保留原有名称 不相同类型文件不同文件夹 使用同一个序列号 ";
            String desc_false_2 = "(清除原名称_按类型 依照输入索引为起始 order ) 把当前的所有子文件(非目录)重命名为 【输入Begin序号.类型 走到底 】的形式 例如   #_2_false_order_10  hello.jpg =》 10.jpg  xx.jpg-》11_xx.jpg  xx.png-》12.png  xx.png-》13.png  不保留原有名称 不相同类型文件不同文件夹 使用同一个序列号(序号自定义) ";
            String desc_false_3 = "(清除原名称_按类型 每个文件夹单独作为新的起点 以类型重新命名  ) 把当前的所有子文件(以目录分割)重命名实体文件(目录名称不变)为 A/A/aa.jpg  A/A/bb.jpg  A/A/cc.png  A/A/dd.png -> A/A/1.jpg  A/A/2.jpg  A/A/1.png  A/A/2.png  ";
            String desc_false_4 = "(清除原名称_按类型 每个文件夹单独作为新的起点 以类型重新命名  ) 把当前的所有子文件(以目录分割)重命名实体文件(目录名称不变)为 A/A/aa.jpg  A/A/bb.jpg  A/A/cc.png  A/A/dd.png -> A/A/1.jpg  A/A/2.jpg  A/A/1.png  A/A/2.png  ";

            String desc_true_pading1 = " (保留原名称) 把当前的所有子文件(非目录)重命名为 【序号_原始名称.类型】的形式 例如 hello.jpg =》 00001_hello.jpg  xx.jpg-》00002_xx.jpg    001/4.jpg -> 001/00003_4.jpg(不同文件夹)   保留原有名称 相同类型文件不同文件夹 使用同一个序列号对齐5位   ";

            String desc_false_pading1 = "(清除原名称) 把当前的所有子文件(非目录)重命名为 【序号.类型】的形式 例如 hello.jpg =》 00001.jpg  xx.png-》00002.jpg 对其5位数字  不保留原有名称 相同类型文件不同文件夹 使用同一个序列号";

            if (curType == OS_TYPE.Windows) {
                itemDesc = batName.trim() + ".bat  " + type + "_" + index + "_true" + "    [索引 " + index + "]  描述: "
                        + desc_true + "\n";
                itemDesc += "\n" + batName.trim() + ".bat  " + type + "_" + index + "_true_order" + "    [索引 " + index
                        + "]  描述: " + desc_true_1 + "\n";
                itemDesc += "\n" + batName.trim() + ".bat  " + type + "_" + index + "_true_order_20" + "    [指定开始索引 "
                        + index + "]  描述: " + desc_true_2 + "\n";
                itemDesc += "\n" + batName.trim() + ".bat  " + type + "_" + index + "_true_order_20_padding5"
                        + "    [指定开始索引 " + index + "]  描述: " + desc_true_pading1 + "\n";
                itemDesc += "\n" + batName.trim() + ".bat  " + type + "_" + index + "_false" + "    [索引 " + index
                        + "]  描述:" + desc_false + "\n";
                itemDesc += "\n" + batName.trim() + ".bat  " + type + "_" + index + "_false_order" + "    [索引 " + index
                        + "]  描述:" + desc_false_1 + "\n";
                itemDesc += "\n" + batName.trim() + ".bat  " + type + "_" + index + "_false_order_padding5" + "    [索引 "
                        + index + "]  描述:" + desc_false_pading1 + "\n";
                itemDesc += "\n" + batName.trim() + ".bat  " + type + "_" + index + "_false_order_10" + "    [指定开始索引 "
                        + index + "]  描述:" + desc_false_2 + "\n";

            } else {
                itemDesc = batName.trim() + ".sh " + type + "_" + index + "_true" + "    [索引 " + index + "]  描述:"
                        + desc_true;
                itemDesc += "\n" + batName.trim() + ".bat  " + type + "_" + index + "_true_order" + "    [索引 " + index
                        + "]  描述: " + desc_true_1;
                itemDesc += "\n" + batName.trim() + ".bat  " + type + "_" + index + "_true_order_padding5" + "    [索引 "
                        + index + "]  描述: " + desc_true_1;
                itemDesc += "\n" + batName.trim() + ".sh  " + type + "_" + index + "_false" + "    [索引 " + index
                        + "]  描述:" + desc_false;
                itemDesc += "\n" + batName.trim() + ".sh  " + type + "_" + index + "_false_order" + "    [索引 " + index
                        + "]  描述:" + desc_false_1;
                itemDesc += "\n" + batName.trim() + ".sh  " + type + "_" + index + "_false_order_padding5" + "    [索引 "
                        + index + "]  描述:" + desc_false_pading1;
                itemDesc += "\n" + batName.trim() + ".sh  " + type + "_" + index + "_false_order_padding5" + "    [索引 "
                        + index + "]  描述:" + desc_true_pading1;
                itemDesc += "\n" + batName.trim() + ".sh  " + type + "_" + index + "_false_order_10" + "    [指定开始索引 "
                        + index + "]  描述:" + desc_false_2 + "\n";
            }

            return itemDesc;
        }

    }

    // html_1
    /*
     * 1.读取当前的 html文件 然后把所有的 html文件的 <script> </script> 重新放到 </body> 后面 <script>
     * </script> </body>
     */

    class HTML_Rule_1 extends Basic_Rule {

        HTML_Rule_1() {
            super("html", 1, 1);
        }

        String applyOperationRule(String origin) {
            StringBuilder sb = new StringBuilder();
            if (origin.contains("<script>") && origin.contains("</script>") && origin.contains("</body>")
                    && origin.indexOf("</body>") > origin.indexOf("<script>") && // <script> </body> // script 索引小于
                    // </body>的索引
                    origin.indexOf("</script>") == origin.lastIndexOf("</script>")) { // 只包含一个 </script>
                int scriptBegin = origin.indexOf("<script>");
                int scriptEnd = origin.indexOf("</script>") + "</script>".length();
                int bodyEnd = origin.indexOf("</body>");

                String script = origin.substring(scriptBegin, scriptEnd);
                String result = origin.replace(script, "");
                result = result.replace("</body>", "</body>" + "\n" + script);

                sb.append(result);
            } else {
                sb.append(origin);
            }
            return sb.toString();

        }

        String simpleDesc() {
            return " 读取当前的 html文件  然后把所有的 html文件的 <script> </script>  重新放到 </body> 后面";
        }

    }

    class Basic_Rule extends Rule {
        Basic_Rule(String ctype, int cindex, int opera_type) {
            this.file_type = ctype;
            this.rule_index = cindex;
            this.operation_type = opera_type;
            this.identify = this.file_type + "" + this.rule_index;
            curFilterFileTypeList = new ArrayList<String>();
            curFixedFileList = new ArrayList<File>();
            firstInputIndexStr = "";
        }

        String applyStringOperationRule1(String origin) {
            return origin;
        }

        File applyFileByteOperationRule2(File originFile) {
            return originFile;
        }

        ArrayList<File> applyFileListRule3(ArrayList<File> subFileList, HashMap<String, ArrayList<File>> fileTypeMap) {
            return null;
        }

        @Override
        ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                              HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                              ArrayList<File> curRealFileList) {
            return curFileList;
        }

        @Override
        ArrayList<File> applyDir_SubFileListRule5(ArrayList<File> allSubDirFileList,
                                                  ArrayList<File> allSubRealFileList) {

            return null;
        }

        boolean initParams4InputParam(String inputParam) {
            firstInputIndexStr = inputParam;
            return true;
        }

        @Override
        boolean initParamsWithInputList(ArrayList<String> inputParamList) {
            return true;
        }

        @Override
        boolean allowEmptyDirFileList() {
            return false;
        }

        String simpleDesc() {
            return null;
        }

        String ruleTip(String type, int index, String batName, OS_TYPE curType) {
            String itemDesc = "";
            if (curType == OS_TYPE.Windows) {
                itemDesc = batName.trim() + ".bat  " + type + "_" + index + "    [索引 " + index + "]  描述:"
                        + simpleDesc();
            } else   if (curType == OS_TYPE.Linux) {
                //  在 Linux 下  #_42 会被当成注释  无法 被识别  所以  必须 把 第一个 # 号改为 下划线
                String  simple_desc = simpleDesc();
                String fixed_simple_desc  = simple_desc.replace("#_","@_");
                itemDesc = batName.trim() + ".sh " + type + "_" + index + "    [索引 " + index + "]  描述:" + fixed_simple_desc;
            } else   if (curType == OS_TYPE.MacOS) {
                //  在Mac 下  # 能被识别
                itemDesc = batName.trim() + ".sh " + type + "_" + index + "    [索引 " + index + "]  描述:" + simpleDesc();
            } else{

                //  在 Linux 下  #_42 会被当成注释  无法 被识别  所以  必须 把 第一个 # 号改为 下划线
                String  simple_desc = simpleDesc();
                String fixed_simple_desc  = simple_desc.replace("#_","@_");
                itemDesc = batName.trim() + ".sh " + type + "_" + index + "    [索引 " + index + "]  描述:" + fixed_simple_desc;
            }

            return itemDesc;
        }

        boolean tryReName(File curFile, String newName) {
            String newFilePath = curFile.getParent() + File.separator + newName;
            String oldName = curFile.getName();
            File newFile = new File(newFilePath);
            if (newFile.exists() && newFilePath.equals(curFile.getAbsolutePath())) {

//           newFilePath = curFile.getParent() + File.separator +"重复_"+newName;
//           newFile = new File(newFilePath);
                System.out.println("当前目录已存在重命名后的文件  文件名称:" + curFile.getName());
                return false; // 已经存在的文件不处理 直接返回

            }
            boolean flag = curFile.renameTo(newFile);
            if (flag) {
                System.out.println(oldName + " 转为 " + newFilePath + " 成功！");
                curFixedFileList.add(curFile);
            } else {
                String fileNameNoPoint = getFileNameNoPoint(newName);
                String secondNewName = newName.replace(fileNameNoPoint, fileNameNoPoint + "_" + getTimeStampLong());
                System.out.println(
                        oldName + " 转为 " + newFilePath + " 失败1次！ 尝试使用新名称 secondNewName=[" + secondNewName + "]");
                String newSecondPath = curFile.getParent() + File.separator + secondNewName;
                File secondFile = new File(newSecondPath);
                flag = curFile.renameTo(secondFile);
                if (flag) {
                    System.out.println(oldName + " 第二次转为 " + newFilePath + " 成功！");
                } else {
                    System.out.println(oldName + " 第二次转为 " + newFilePath + " 仍然失败！");
                }
            }
            return flag;
        }
    }

    abstract class Rule {
        // operation_type 操作类型 1--读取文件内容字符串 进行修改 2--对文件对文件内容(字节)--进行修改 3.对全体子文件进行的随性的操作
        // 属性进行修改(文件名称)
        // 4.对当前子文件(包括子目录 子文件 --不包含孙目录 孙文件) // 5. 从shell 中获取到的路径 去对某一个文件进行操作
        String firstInputIndexStr;
        int operation_type;
        String file_type; // * 标识所有的文件类型 以及当前操作类型文件 或者 单独的文件过滤类型
        String identify;
        int rule_index; // (type,index) 组成了最基础的唯一键
        ArrayList<String> curFilterFileTypeList; // 当前的文件过滤类型 多种文件过滤类型 例如把 多种格式 jpeg png 转为 jpg 时 使用到
        ArrayList<File> curFixedFileList; // 当前修改操作成功的集合

        abstract boolean allowEmptyDirFileList(); // 是否允许当前的目录下的文件为空

        abstract String applyStringOperationRule1(String origin);

        abstract File applyFileByteOperationRule2(File originFile);

        abstract ArrayList<File> applyFileListRule3(ArrayList<File> subFileList,
                                                    HashMap<String, ArrayList<File>> fileTypeMap);

        abstract ArrayList<File> applySubFileListRule4(ArrayList<File> curFileList,
                                                       HashMap<String, ArrayList<File>> subFileTypeMap, ArrayList<File> curDirList,
                                                       ArrayList<File> curRealFileList);

        abstract ArrayList<File> applyDir_SubFileListRule5(ArrayList<File> allSubDirFileList,
                                                           ArrayList<File> allSubRealFileList);

        abstract boolean initParams4InputParam(String inputParam); // 初始化Rule的参数 依据输入的字符串

        abstract boolean initParamsWithInputList(ArrayList<String> inputParamList);

        abstract String ruleTip(String type, int index, String batName, OS_TYPE curType); // 使用说明列表 如果覆盖 那么就不使用默认的说明 ,
        // 默认就一种情况

        abstract String simpleDesc(); // 使用的简单描述 中文的该 rule的使用情况 默认会在 ruleTip 被调用

    }

    static void ANSI_writeContentToFile(File file, String strParam) {

        try {
            if (file != null && !file.exists()) {
                System.out.println("创建文件:  " + file.getAbsolutePath());
                if (!file.getParentFile().exists()) {
                    file.getParentFile().mkdirs();
                }

                file.createNewFile();

            }

            if (file != null && file.exists()) {
                BufferedWriter curBW = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), "GBK"));
                curBW.write(strParam);
                curBW.flush();
                curBW.close();
                // System.out.println("write out File OK ! File = " + file.getAbsolutePath());
            } else {
                System.out.println("write out File  Failed !    File = " + file.getAbsolutePath());
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void UTF8File_To_ANSIFile(File file) {
        StringBuffer buffer = new StringBuffer();
        try {
            FileInputStream fis = new FileInputStream(file.getAbsolutePath());
            InputStreamReader isr = new InputStreamReader(fis, "UTF-8");
            BufferedReader br = new BufferedReader(isr);
            String line = null;
            br.skip(1);
            while ((line = br.readLine()) != null) {
                buffer.append(line);
                buffer.append("\r\n");
            }
            buffer.delete(buffer.length() - 2, buffer.length());
            br.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
        System.out.println(buffer);
        try {
            FileOutputStream fos = new FileOutputStream(file.getAbsoluteFile());
            OutputStreamWriter osw = new OutputStreamWriter(fos);
            osw.write(buffer.toString());
            osw.flush();
            osw.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    static void writeContentToFile(File file, String strParam) {

        try {
            if (file != null && !file.exists()) {
                System.out.println("创建文件:  " + file.getAbsolutePath());
                if (!file.getParentFile().exists()) {
                    file.getParentFile().mkdirs();
                }

                file.createNewFile();

            }

            if (file != null && file.exists()) {
                BufferedWriter curBW = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), "utf-8"));
                curBW.write(strParam);
                curBW.flush();
                curBW.close();
                // System.out.println("write out File OK ! File = " + file.getAbsolutePath());
            } else {
                System.out.println("write out File  Failed !    File = " + file.getAbsolutePath());
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public static String ReadFileContent_No_UTF8(File mFilePath) {

        if (mFilePath != null && mFilePath.exists()) {
            // System.out.println("存在 当前文件 "+ mFilePath.getAbsolutePath());
        } else {
            System.out.println("不存在 当前文件 " + mFilePath.getAbsolutePath());

            return null;
        }
        StringBuilder sb = new StringBuilder();

        try {
            BufferedReader curBR = new BufferedReader(new InputStreamReader(new FileInputStream(mFilePath)));
            String oldOneLine = "";
            int index = 1;
            while (oldOneLine != null) {

                oldOneLine = curBR.readLine();
                if (oldOneLine == null || oldOneLine.trim().isEmpty()) {
                    continue;
                }

                sb.append(oldOneLine + "\n");
//                    System.out.println("第"+index+"行读取到的字符串:"+oldOneLine);
                index++;

            }
            curBR.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
        return sb.toString();

    }

    public static String ReadFileContent_GBK(File mFilePath) {

        if (mFilePath != null && mFilePath.exists()) {
            // System.out.println("存在 当前文件 "+ mFilePath.getAbsolutePath());
        } else {
            System.out.println("不存在 当前文件 " + mFilePath.getAbsolutePath());

            return null;
        }
        StringBuilder sb = new StringBuilder();

        try {
            BufferedReader curBR = new BufferedReader(new InputStreamReader(new FileInputStream(mFilePath), "GBK"));
            String oldOneLine = "";
            int index = 1;
            while (oldOneLine != null) {

                oldOneLine = curBR.readLine();
                if (oldOneLine == null || oldOneLine.trim().isEmpty()) {
                    continue;
                }

                sb.append(oldOneLine + "\n");
//                    System.out.println("第"+index+"行读取到的字符串:"+oldOneLine);
                index++;

            }
            curBR.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
        return sb.toString();

    }

    public static String ReadFileContent_UTF8(File mFilePath) {

        if (mFilePath != null && mFilePath.exists()) {
            // System.out.println("存在 当前文件 "+ mFilePath.getAbsolutePath());
        } else {
            System.out.println("不存在 当前文件 " + mFilePath.getAbsolutePath());

            return null;
        }
        StringBuilder sb = new StringBuilder();

        try {
            BufferedReader curBR = new BufferedReader(new InputStreamReader(new FileInputStream(mFilePath), "utf-8"));
            String oldOneLine = "";
            int index = 1;
            while (oldOneLine != null) {

                oldOneLine = curBR.readLine();
                if (oldOneLine == null || oldOneLine.trim().isEmpty()) {
                    continue;
                }

                sb.append(oldOneLine + "\n");
//                    System.out.println("第"+index+"行读取到的字符串:"+oldOneLine);
                index++;

            }
            curBR.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
        return sb.toString();

    }

    public static String ReadFileContent(File mFilePath) {

        if (mFilePath != null && mFilePath.exists()) {
            // System.out.println("存在 当前文件 "+ mFilePath.getAbsolutePath());
        } else {
            System.out.println("不存在 当前文件 " + mFilePath.getAbsolutePath());

            return null;
        }
        StringBuilder sb = new StringBuilder();

        try {
            BufferedReader curBR = new BufferedReader(new InputStreamReader(new FileInputStream(mFilePath), "utf-8"));
            String oldOneLine = "";
            int index = 1;
            while (oldOneLine != null) {

                oldOneLine = curBR.readLine();
                if (oldOneLine == null || oldOneLine.trim().isEmpty()) {
                    continue;
                }

                sb.append(oldOneLine + "\n");
//                    System.out.println("第"+index+"行读取到的字符串:"+oldOneLine);
                index++;

            }
            curBR.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
        return sb.toString();

    }



    public static ArrayList<String> ReadFileJavaContentAsList_Begin_End(File mFilePath  , String beginClearTag , String endClearTag ) {


        if (mFilePath != null && mFilePath.exists()) {
            // System.out.println("存在 当前文件 "+ mFilePath.getAbsolutePath());
        } else {
            System.out.println("不存在 当前文件  ReadFileContentAsList  mFilePath = null "  );

            return null;
        }
        ArrayList<String> contentList = new ArrayList<String>();

        boolean isContainLine = true;
        try {
            BufferedReader curBR = new BufferedReader(new InputStreamReader(new FileInputStream(mFilePath), "utf-8"));
            String oldOneLine = "";
            int index = 1;
            while (oldOneLine != null) {

                oldOneLine = curBR.readLine();
                if (oldOneLine == null) {
                    continue;
                }

                if(oldOneLine.contains(beginClearTag) && isContainLine){
                    isContainLine = false;
                    continue;
                }

                // 如果当前 包含 EndTag  b 并且 当前的  f lag是   false 的 话 那么 就 说明 这个  区间结束了
                if(oldOneLine.contains(endClearTag) && !isContainLine){
                    isContainLine = true;
                    continue;

                }


                if(isContainLine){
                    contentList.add(oldOneLine);
                    index++;
                }

//                    System.out.println("第"+index+"行读取到的字符串:"+oldOneLine);

            }
            curBR.close();

        } catch (Exception e) {
            e.printStackTrace();
        }

        int lineSize  = contentList.size();

        String lastLine = "";

        if(lineSize > 0){
            lastLine = contentList.get(lineSize-1).trim();
        }


        while("".equals(lastLine)){
            int end_index = contentList.size()-1;

            if(contentList.size() <= 0){
                break;
            }
            if(end_index >= 0  ){
                lastLine = contentList.get(end_index).trim();
                if(lastLine.trim().endsWith("}")){
                    break;
                }else{
                    contentList.remove(end_index);
                }
            }

        }

        return contentList;

    }


    public static ArrayList<String> ReadFileContentAsListWithClearTag(File mFilePath , String clearTag) {

        if (mFilePath != null && mFilePath.exists()) {
            // System.out.println("存在 当前文件 "+ mFilePath.getAbsolutePath());
        } else {
            System.out.println("不存在 当前文件  ReadFileContentAsList  mFilePath = null "  );

            return null;
        }
        ArrayList<String> contentList = new ArrayList<String>();

        try {
            BufferedReader curBR = new BufferedReader(new InputStreamReader(new FileInputStream(mFilePath), "utf-8"));
            String oldOneLine = "";
            int index = 1;
            while (oldOneLine != null) {

                oldOneLine = curBR.readLine();
                if (oldOneLine == null) {
                    continue;
                }

                if(oldOneLine.contains(clearTag)){
                    continue;
                }

                contentList.add(oldOneLine);
//                    System.out.println("第"+index+"行读取到的字符串:"+oldOneLine);
                index++;

            }
            curBR.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
        return contentList;

    }



    public static ArrayList<String> ReadFileContentAsList(File mFilePath) {

        if (mFilePath != null && mFilePath.exists()) {
            // System.out.println("存在 当前文件 "+ mFilePath.getAbsolutePath());
        } else {
            System.out.println("不存在 当前文件  ReadFileContentAsList  mFilePath = null "  );

            return null;
        }
        ArrayList<String> contentList = new ArrayList<String>();

        try {
            BufferedReader curBR = new BufferedReader(new InputStreamReader(new FileInputStream(mFilePath), "utf-8"));
            String oldOneLine = "";
            int index = 1;
            while (oldOneLine != null) {

                oldOneLine = curBR.readLine();
                if (oldOneLine == null) {
                    continue;
                }

                contentList.add(oldOneLine);
//                    System.out.println("第"+index+"行读取到的字符串:"+oldOneLine);
                index++;

            }
            curBR.close();

        } catch (Exception e) {
            e.printStackTrace();
        }
        return contentList;

    }

    public static boolean isContainChinese(String str) {
        Pattern p = Pattern.compile("[\u4e00-\u9fa5]");
        Matcher m = p.matcher(str);
        if (m.find()) {
            return true;
        }
        return false;
    }

    public static boolean isNumeric(String str) {

        if (str == null) {
            return false;
        }

        for (int i = str.length(); --i >= 0;) {
            if (!Character.isDigit(str.charAt(i))) {
                return false;
            }
        }
        if (str.trim().equals("")) {
            return false;
        }
        return true;
    }
    
    

    static void writeContentToFile(File file, ArrayList<String> strList) {

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < strList.size(); i++) {
            sb.append(strList.get(i) + "\n");
        }
        try {
            if (file != null && !file.exists()) {
                System.out.println("新建文件夹: file=" + file.getAbsolutePath());

                if (!file.getParentFile().exists()) {
                    file.getParentFile().mkdirs();
                }

                file.createNewFile();
            }

            if (file != null && file.exists()) {
                BufferedWriter curBW = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file), "utf-8"));
                curBW.write(sb.toString());
                curBW.flush();
                curBW.close();
                System.out.println("write out File OK !  File = " + file.getAbsolutePath());
            } else {
                System.out.println("write out File  Failed !    File = " + file.getAbsolutePath());
            }
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    static String getPaddingIntString(int index, int padinglength, String oneStr, boolean dirPre) {
        String result = "" + index;
        int length = ("" + index).length();

        if (length < padinglength) {
            int distance = padinglength - length;
            for (int i = 0; i < distance; i++) {
                if (dirPre) {
                    result = oneStr + result;
                } else {
                    result = result + oneStr;
                }

            }

        }
        return result;

    }

    public static void createEncryFile(File generalFile, File encryptFile) {

        int general_position = 0;
        int general_offset = 0;
        FileInputStream generalFileInputStream = null;
        BufferedInputStream generalBufferedInputStream = null;

        FileOutputStream encryptileOutputStream = null;
        BufferedOutputStream encryptBufferedOutputStream = null;

        try {
            if (!encryptFile.exists()) {
                encryptFile.createNewFile();
            }

            long generalFile_length = generalFile.length();

            generalFileInputStream = new FileInputStream(generalFile);
            generalBufferedInputStream = new BufferedInputStream(generalFileInputStream);

            encryptileOutputStream = new FileOutputStream(encryptFile);
            encryptBufferedOutputStream = new BufferedOutputStream(encryptileOutputStream);

            if (encryptFile.getAbsolutePath().trim().endsWith("md")) {
                while ((general_position = generalBufferedInputStream.read(TEMP_Rule7, 0, TEMP_Rule7.length)) != -1) {
                    encryptBufferedOutputStream.write(TEMP_Rule7, 0, general_position);
                    encryptBufferedOutputStream.flush();
                }
                // 关闭流
                generalBufferedInputStream.close();
                encryptBufferedOutputStream.close();
                return;

            }

            // System.out.println("原始文件字节大小: " + generalBufferedInputStream.available());
            while (general_offset < BYTE_CONTENT_LENGTH_Rule7) { // 读取原始文件的头 BYTE_CONTENT_LENGTH 个字节数进行加密
                general_position = generalBufferedInputStream.read(TEMP_Rule7, general_offset,
                        TEMP_Rule7.length - general_offset);
                if (general_position == -1) {
                    break;
                }
                general_offset += general_position;
                // byteTo16(TEMP, general_position); // 可以查看 指定 前 general_position 个在
                // TEMP数组中的字节数据 太多 注释掉
            }

            // 对读取到的TEMP字节数组 BYTE_CONTENT_LENGTH 个字节进行 ECB模式加密 明文大小与密文大小一致



            byte[] encrypt_bytes = encrypt(TEMP_Rule7);


			/*
			byte[] real_byte =   new byte[(int) generalFile_length];
			for (int i = 0; i < generalFile_length; i++) {
				real_byte[i] = TEMP_Rule7[i];
			}

			byte[] encrypt_real_bytes = encrypt(real_byte);
			String raw_bytes_str  = bytesToHexString(real_byte);
			String encrypt_raw_bytes_str  = bytesToHexString(encrypt_real_bytes);



			System.out.println("加密原始文件:" + generalFile.getName() + "  加密前明文大小:" + TEMP_Rule7.length + "   加密后密文大小:"
					+ encrypt_bytes.length);

			 String raw_str = new String(real_byte,"utf-8");
			 String encrypt_str = new String(encrypt_real_bytes,"utf-8");

			  System.out.println("原始字符串:"+raw_str+   "   "+ "原始Hex字符串:" + raw_bytes_str );
			  System.out.println("加密字符串:"+encrypt_str+   "   "+"加密Hex字符串:" + encrypt_raw_bytes_str );
	        */

            // 加密后的密文 填充 encryptFile文件的头首部
            encryptBufferedOutputStream.write(encrypt_bytes, 0, encrypt_bytes.length);
            encryptBufferedOutputStream.flush();
            // 从正常的 general文件 读取 BYTE_CONTENT_LENGTH 字节数之后的所有字节写入到 加密File(Head已经加密)文件中去
            while ((general_position = generalBufferedInputStream.read(TEMP_Rule7, 0, TEMP_Rule7.length)) != -1) {
                encryptBufferedOutputStream.write(TEMP_Rule7, 0, general_position);
                encryptBufferedOutputStream.flush();
            }
            // 关闭流
            generalBufferedInputStream.close();
            encryptBufferedOutputStream.close();

        } catch (Exception e) {
            System.out.println(e.fillInStackTrace());

        }
    }

    private static Cipher encryptCipher = null;
    private static Cipher decryptCipher = null;

    static {
        try {
            Security.addProvider(new cn.gmssl.sun.crypto.provider.SunJCE());
            Key key = getKey(strDefaultKey_Rule7.getBytes());
            //	System.out.println("getFormat()=【"+key.getFormat()+"】  bytesToHexString=【getEncoded = "+bytesToHexString(key.getEncoded())+"】"
            //	+"【getAlgorithm= "+key.getAlgorithm()+"】" +"【toString = "+key.toString()+"】" +"【serialVersionUID= "+key.serialVersionUID+"】");
            encryptCipher = Cipher.getInstance("DES/ECB/NoPadding");
            encryptCipher.init(Cipher.ENCRYPT_MODE, key);
            decryptCipher = Cipher.getInstance("DES/ECB/NoPadding");
            decryptCipher.init(Cipher.DECRYPT_MODE, key);
            //	System.out.println("getFormat()=【"+key.getFormat()+"】  bytesToHexString=【"+bytesToHexString(key.getEncoded())+"】");

//			System.out.println("SunJCE_decryptCipher.toString()=【1 "+decryptCipher.toString()+"】"+"【2 "+decryptCipher+"】"
//					+"【3getAlgorithm  "+decryptCipher.getAlgorithm()+"】"+"【4getBlockSize "+decryptCipher.getBlockSize()+"】"+
//					"【5VI "+bytesToHexString(decryptCipher.getIV())+"】"+"【6getParameters "+decryptCipher.getParameters()+"】"+
//					"【7getProvider  "+decryptCipher.getProvider()+"】"	+"【8getExemptionMechanism "+decryptCipher.getExemptionMechanism()+"】") ;


        } catch (Exception e) {

        }

    }

    private static Key getKey(byte[] arrBTmp) throws Exception {
        byte[] arrB = new byte[8]; // 认默为0
        for (int i = 0; i < arrBTmp.length && i < arrB.length; ++i) {
            arrB[i] = arrBTmp[i];
        }
        // 生成密匙
        Key key = new javax.crypto.spec.SecretKeySpec(arrB, "DES");
        return key;
    }

    // 加密字节数组
    public static byte[] encrypt(byte[] arrB) throws Exception {
        return encryptCipher.doFinal(arrB);
    }

    // 密解字节数组
    public static byte[] decrypt(byte[] arrB) throws Exception {
        return decryptCipher.doFinal(arrB);
    }

    static ArrayList<File> getAllSubFile(File dirFile) {
        ArrayList<String> typeList = new ArrayList<String>();
        typeList.add("#");
        return getAllSubFile(dirFile, null, typeList);
    }

    static ArrayList<File> getAllSubFile(File dirFile, String typeStr) {
        ArrayList<String> typeList = new ArrayList<String>();
        typeList.add(typeStr);
        if(dirFile == null) {
            return null;
        }

        return getAllSubFile(dirFile.getAbsolutePath(), "", typeList);

    }

    static ArrayList<File> getAllSubFile(File dirFile, String aospPath, ArrayList<String> typeList) {
        if (aospPath == null || "".equals(aospPath)) {
            return getAllSubFile(dirFile.getAbsolutePath(), "", typeList);
        }
        return getAllSubFile(dirFile.getAbsolutePath(), aospPath, typeList);

    }

    static ArrayList<File> getAllSubFile(String rootPath, String aospItemPath, ArrayList<String> typeList) {
        ArrayList<File> allFile = new ArrayList<File>();
        Path curRootPath = Paths.get(rootPath + File.separator + aospItemPath);

        try {
            Files.walkFileTree(curRootPath, new SimpleFileVisitor<Path>() {

                @Override
                public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
                    String fileString = file.toAbsolutePath().toString();
                    // System.out.println("pathString = " + fileString);

                    for (int i = 0; i < typeList.size(); i++) {
                        String type = typeList.get(i);
                        if ("*".equals(type) || "#".equals(type)) { // 如果 类型是 * 那么就把 所有的 非目录文件加入列表中
                            File curFile = new File(fileString);
                            if (!curFile.isDirectory()) {
                                allFile.add(curFile);
                                break;
                            }

                        } else {
                            if (fileString.endsWith(type)) {
                                allFile.add(new File(fileString));
                                break;
//                         System.out.println("file found at path: " + file.toAbsolutePath());
                            }
                        }
                    }
                    return FileVisitResult.CONTINUE;
                }
            });
        } catch (IOException e) {
            e.printStackTrace();
        }

        return allFile;

    }

    static ArrayList<File> getCurrentSubDirFile(File rootPath) {
        ArrayList<File> allDirFile = new ArrayList<File>();
        File[] files = rootPath.listFiles();
        for (int i = 0; i < files.length; i++) {
            File fileItem = files[i];
            if (fileItem.isDirectory()) {
                allDirFile.add(fileItem);
            }
        }
        return allDirFile;

    }

    static ArrayList<File> getAllSubDirFile(File rootPath) {
        ArrayList<File> allDirFile = new ArrayList<File>();
        Path curRootPath = Paths.get(rootPath.getAbsolutePath() + File.separator);

        try {
            Files.walkFileTree(curRootPath, new SimpleFileVisitor<Path>() {

                @Override
                public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
                    allDirFile.add(dir.toFile());
                    return super.postVisitDirectory(dir, exc);
                }

            });
        } catch (IOException e) {
            e.printStackTrace();
        }

        return allDirFile;

    }

    // 读取加密文件 对加密部分进行解密 然后生成解密之后的文件 decryptFile
    public static void createDecryFile(File encryptFile, File decryptFile) {

        FileOutputStream decryptileOutputStream = null;
        BufferedOutputStream decryptBufferedOutputStream = null;

        FileInputStream encryptileInputStream = null;
        BufferedInputStream encryptBufferedInputStream = null;

        try {
            if (!decryptFile.getParentFile().exists()) {
                decryptFile.getParentFile().mkdirs();
            }

            if (!decryptFile.exists()) {
                decryptFile.createNewFile();
            }
            encryptileInputStream = new FileInputStream(encryptFile);
            encryptBufferedInputStream = new BufferedInputStream(encryptileInputStream);

            decryptileOutputStream = new FileOutputStream(decryptFile);
            decryptBufferedOutputStream = new BufferedOutputStream(decryptileOutputStream);

            int encrypt_offset = 0;
            int encrypt_position = 0;
            while (encrypt_offset < BYTE_CONTENT_LENGTH_Rule7) { // 读取到加密文件的 加密字节部分 大小为 BYTE_CONTENT_LENGTH
                encrypt_position = encryptBufferedInputStream.read(TEMP_Rule7, encrypt_offset,
                        TEMP_Rule7.length - encrypt_offset);

                if (encrypt_position == -1) {
                    break;
                }
                encrypt_offset += encrypt_position;
                // byteTo16(TEMP, general_position); // 可以查看 指定 前 general_position 个在
                // TEMP数组中的字节数据 太多 注释掉
            }

            byte[] decrypt_bytes = decrypt(TEMP_Rule7); // 对加密文件的加密字节进行解密
            System.out.println("源文件:" + encryptFile.getAbsolutePath() + "    解密文件:" + decryptFile.getAbsolutePath()
                    + "  密文加密字节大小:" + TEMP_Rule7.length + "   解密密文之后的明文大小:" + decrypt_bytes.length);

            decryptBufferedOutputStream.write(decrypt_bytes);
            decryptBufferedOutputStream.flush();

            // 读取 encryptFile加密文件中正常的字节 BYTE_CONTENT_LENGTH 字节数之后的所有字节写入到
            // 解密File(Head已经解密)文件中去
            while ((encrypt_offset = encryptBufferedInputStream.read(TEMP_Rule7, 0, TEMP_Rule7.length)) != -1) {
                decryptBufferedOutputStream.write(TEMP_Rule7, 0, encrypt_offset);
                decryptBufferedOutputStream.flush();
            }

            encryptBufferedInputStream.close();
            decryptBufferedOutputStream.close();

        } catch (Exception e) {
            System.out.println(e.fillInStackTrace());

        }
    }

    static void showTip() {
        System.out.println("对Type文件内容 进行 Index 规则的处理  identy=【 Type_Index 】【 文件后缀_当前操作逻辑索引】\n");
        System.out.println("当前已实现的替换逻辑如下:\n");

        int count = 1;
        System.out.println("═══════════════════" + "使用方法列表 Begin" + "═══════════════════" + "\n");
        for (int i = 0; i < realTypeRuleList.size(); i++) {
            Rule itemRule = realTypeRuleList.get(i);
            String type = itemRule.file_type;
            int index = itemRule.rule_index;
            String desc = itemRule.ruleTip(type, index, G2_Bat_Name, CUR_OS_TYPE);

            /*
             * String itemDesc = ""; if(curOS_TYPE == OS_TYPE.Windows){ itemDesc =
             * "zrule_apply_G2.bat  "+type+"_"+index + "    [索引 "+count+"]  描述:"+desc;
             * }else{ itemDesc = "zrule_apply_G2 "+type+"_"+index +
             * "    [索引 "+count+"]  描述:"+desc; }
             */
            System.out.println(desc + "\n");
            count++;
        }
        System.out.println("═══════════════════" + "使用方法列表 End " + "═══════════════════" + "\n");

    }

    static boolean checkInputParamsOK() {
        boolean inputOk = true;

        for (int i = 0; i < Rule_Identify_TypeIndexList.size(); i++) {
            String curInputStr = Rule_Identify_TypeIndexList.get(i);
            if (!curInputStr.contains("_")) {
                return false;
            }

            String[] paramsArr = curInputStr.split("_");
            if (paramsArr.length < 2) {
                continue;
            }
            String type = paramsArr[0];
            String index = paramsArr[1];

//          initParams4InputParam
            if (!isNumeric(index)) { // 第二个参数不是 数字 那么 输入格式错误
                return false;
            }
            Rule matchRule = getRuleByIndex(Integer.parseInt(index));
            if (matchRule != null) {
                inputOk = matchRule.initParams4InputParam(curInputStr)
                        && matchRule.initParamsWithInputList(Rule_Identify_TypeIndexList);
                return inputOk;
            }

        }

        return inputOk;
    }

    static Rule CurSelectedRule;

    public static void main(String[] args) {

        initSystemInfo();

        if (args != null) {
            for (int i = 0; i < args.length; i++) {
                System.out.println("args[" + i + "] = " + args[i]);
                if (i == 0) {
                    curDirPath = args[i];
                } else {
                    mKeyWordName.add(args[i]);
                    Rule_Identify_TypeIndexList.add(args[i]);
                }
            }
        }

        mG2_Object = new G2_ApplyRuleFor_TypeFile();
        mG2_Object.InitRule();

        File mCurDirFile = new File(curDirPath);
        curDirFile = new File(curDirPath);

        if (mKeyWordName.size() == 0) {
            showTip();
            return;
        }

        if (!checkInputParamsOK()) {
            System.out.println("当前用户输入的格式错误   input=【类型_索引】  例如    html_1   html_2    html_3  ");
            return;
        }

        if (curDirFile == null || !mCurDirFile.exists() || !mCurDirFile.isDirectory()) {
            System.out.println("当前执行替换逻辑的文件路径:" + curDirPath + "  不存在! ");
            return;
        }

        // 通过 shell中输入参数来进行操作
        // Rule_Identify_TypeIndexList.add("html_1"); // 1.添加处理的类型文件 类型_该类型的处理逻辑索引
        // 索引从1开始

        for (int i = 0; i < Rule_Identify_TypeIndexList.size(); i++) { // 依据文件类型 去找到文件
            // html_1
            String applyRuleString = Rule_Identify_TypeIndexList.get(i);
            String paramsArr[] = applyRuleString.split("_");
            if (paramsArr.length < 2) {
                continue;
            }
            String curType = paramsArr[0];
            String curApplyRule = paramsArr[1];
            if (!isNumeric(curApplyRule)) {
                continue;
            }
            int ruleIndex = Integer.parseInt(curApplyRule);

            Rule curApplayRule = getRuleByIndex(ruleIndex);
            if (curApplayRule != null) {
                CurSelectedRule = curApplayRule;
            }
            if (curApplayRule == null && CurSelectedRule == null) {
                System.out.println("无法匹配到 对应的 index=" + ruleIndex + "  对应的规则 Rule !   可能需要代码添加。");
                continue; // 继续下一个循环
            }
            if (curApplayRule == null && CurSelectedRule != null) {
                return;
            }
            if (curApplayRule.curFilterFileTypeList.size() == 0) {
                curApplayRule.curFilterFileTypeList.add(curType);
            }

            ArrayList<File> typeFileList = new ArrayList<File>();

            if (curApplayRule.operation_type == 4) { // 对于 类型是 4 的操作 只获取当前 shell 下的文件
                typeFileList.addAll(Arrays.asList(mCurDirFile.listFiles()));
                System.out.println("operation_type == 4 子目录大小: " + typeFileList.size());
            } else {
                typeFileList = getAllSubFile(mCurDirFile, null, curApplayRule.curFilterFileTypeList);
            }

            if (typeFileList.size() == 0) {
                System.out.println("未能搜索到类型列表匹配的文件:  " + Rule_Identify_TypeIndexList.get(i));
                if (!curApplayRule.allowEmptyDirFileList()) { // 是否允许当前目录下的文件夹为空
                    continue;
                }

            }
            initFileTypeMap(typeFileList);

            if (curApplayRule.operation_type == 4) { // 只对 当前的 子 文件(目录 文件)操作
                // 对当前文件进行整理
                ArrayList<File> subDirList = new ArrayList<File>();
                ArrayList<File> realFileList = new ArrayList<File>();

                outCycle: for (int j = 0; j < typeFileList.size(); j++) {
                    File curFile = typeFileList.get(j);
                    if (curFile.isDirectory()) {
                        subDirList.add(curFile);
                    } else {

                        if (curApplayRule.curFilterFileTypeList.contains("#")) {
                            realFileList.add(curFile);
                        } else {

                            inCycle: for (int k = 0; k < curApplayRule.curFilterFileTypeList.size(); k++) {
                                String curMatchType = curApplayRule.curFilterFileTypeList.get(k);
//                                System.out.println("FileName:"+curFile.getName()+"  curMatchType="+curMatchType);
                                if (curFile.getName().endsWith(curMatchType)) {
                                    realFileList.add(curFile);
                                    break inCycle;
                                }
                            }

                        }

                    }
                }

                ArrayList<File> resultFileList = curApplayRule.applySubFileListRule4(typeFileList, CurDirFileTypeMap,
                        subDirList, realFileList);
                if (resultFileList != typeFileList) {
                    System.out.println("应用规则: curApplayRule.operation_type ="+curApplayRule.operation_type+" " + applyRuleString + " 成功!");
                } else {
                    System.out.println("应用规则: curApplayRule.operation_type ="+curApplayRule.operation_type+" " + applyRuleString + " 失败!");
                }

            } else if (curApplayRule.operation_type == 3) { // 对所有文件进行的 统一处理的 类型

                ArrayList<File> resultFileList = curApplayRule.applyFileListRule3(typeFileList, CurDirFileTypeMap);
                if (resultFileList != typeFileList) {

                    System.out.println("应用规则: curApplayRule.operation_type ="+curApplayRule.operation_type+" " + applyRuleString + " 成功!");
                } else {
                    System.out.println("应用规则: curApplayRule.operation_type ="+curApplayRule.operation_type+" " + applyRuleString + " 失败!");
                }

            } else if (curApplayRule.operation_type == 5) { // 对所有文件夹 所有子文件 孙文件 所有 子文件夹 孙文件夹

                ArrayList<File> curAllDirFile = getAllSubDirFile(curDirFile); // 获取所有的 文件夹列表 包含 孙子 子文件夹
                ArrayList<File> curAllRealFile = getAllSubFile(curDirFile); // 获取所有的 文件 列表 包含 孙子 子文件
                // FileChannel
//  zukgit operation_type == 5
                System.out.println(" curDirFile = " + curDirFile.toString());
                System.out.println(" curAllDirFile = " + curAllDirFile.size());
                System.out.println(" curAllRealFile = " + curAllRealFile.size());
                curApplayRule.applyDir_SubFileListRule5(curAllDirFile, curAllRealFile);
            } else {

                for (int j = 0; j < typeFileList.size(); j++) {
                    File itemFile = typeFileList.get(j);
                    String fileCOntent = ReadFileContent(itemFile).trim();
                    // 2.applyOperationRule 添加处理规则

                    String resultStr = OriApplyOperationRule(curType, curApplyRule, fileCOntent).trim();

                    int currentOperationType = 1; // 默认操作类型是 读取字符串的内容 进行处理

                    String identy = curType.trim() + curApplyRule.trim();
//                Rule applayRule2Identify = getRuleByIdentify(identy);

                    Rule applayRule4Index = getRuleByIndex(ruleIndex);
//                如果对应相同的 index的 Rule #_2    出现了    MP3_2 的情况  那么就需要把当前的 所有的*的文件 过滤为 mp3的文件
//                if("#".equals(applayRule2Identify.file_type) && !curType.equals(applayRule2Identify.file_type)){
//
//                }

                    if (applayRule4Index != null) {
                        currentOperationType = applayRule4Index.operation_type;
                    } else {
                        System.out.println("无法匹配到 对应的 identy=" + identy + "  对应的规则 Rule !   可能需要代码添加。");
                        return;
                    }

                    if (currentOperationType == 1) { // 对字符串进行逻辑处理的类型

                        if (!fileCOntent.equals(resultStr)) {
                            writeContentToFile(itemFile, resultStr);
                            System.out.println("itemFile[" + j + "] 符合规则(String-Content) 应用Rule成功 " + applyRuleString
                                    + "  = " + itemFile.getAbsolutePath());
                        } else {
                            System.out.println(
                                    "itemFile[" + j + "] 不符合规则(String-Content) = " + itemFile.getAbsolutePath());
                        }

                    } else if (currentOperationType == 2) {

                        File resultFile = applayRule4Index.applyFileByteOperationRule2(itemFile);

                        if (resultFile != itemFile) {
                            System.out.println("itemFile[" + j + "] 符合规则(File) 应用Rule成功 " + applyRuleString + "  = "
                                    + itemFile.getAbsolutePath());
                        } else {
                            System.out.println("itemFile[" + j + "] 不符合规则(File) = " + itemFile.getAbsolutePath());
                        }

                    }

                }

            }

        }

        setProperity();
    }

    static void addCurFileTypeMapItemWithKey(String keyType, File curFile) {
        if (CurDirFileTypeMap.containsKey(keyType)) {
            ArrayList<File> fileList = CurDirFileTypeMap.get(keyType);
            fileList.add(curFile);
        } else {
            ArrayList<File> fileList = new ArrayList<File>();
            fileList.add(curFile);
            CurDirFileTypeMap.put(keyType, fileList);
        }
    }

    static void initFileTypeMap(ArrayList<File> subFileList) {
        if (subFileList == null) {
            return;
        }
        for (File curFile : subFileList) {
            String fileName = curFile.getName();
            if (!fileName.contains(".")) {
                addCurFileTypeMapItemWithKey("unknow", curFile);
            } else {
                String suffix = fileName.substring(fileName.lastIndexOf(".")).trim().toLowerCase();
                addCurFileTypeMapItemWithKey(suffix, curFile);
            }
        }

    }

    static Map<String, ArrayList<File>> getCurSubFileMap(File mDirFile) {
        HashMap<String, ArrayList<File>> realFileListMap = new HashMap<String, ArrayList<File>>();
        ;

        for (File curFile : mDirFile.listFiles()) {
            if (curFile.isDirectory()) {
                continue;
            }
            String fileName = curFile.getName();

            if (!fileName.contains(".")) {
                String type = ""; // unknow 没有后缀名的文件
                if (realFileListMap.containsKey(type)) {
                    ArrayList<File> fileList = realFileListMap.get(type);
                    fileList.add(curFile);
                } else {
                    ArrayList<File> fileList = new ArrayList<File>();
                    fileList.add(curFile);
                    realFileListMap.put(type, fileList);
                }
            } else {
                String suffix = fileName.substring(fileName.lastIndexOf(".")).trim().toLowerCase();

                if (realFileListMap.containsKey(suffix)) {
                    ArrayList<File> fileList = realFileListMap.get(suffix);
                    fileList.add(curFile);
                } else {
                    ArrayList<File> fileList = new ArrayList<File>();
                    fileList.add(curFile);
                    realFileListMap.put(suffix, fileList);
                }
            }
        }

        return realFileListMap;
    }

    static String OriApplyOperationRule(String mType, String index, String mOriContent) {
        String identy = mType.trim() + index.trim();
        Rule applayRule = getRuleByIdentify(identy);
        if (applayRule == null) {
            System.out.println("没有查询到 identy =" + identy + "对应的处理规则");
            return mOriContent;
        }
        return applayRule.applyStringOperationRule1(mOriContent);
    }

    static ArrayList<Rule> realTypeRuleList = new ArrayList<Rule>(); // 规则的集合

    static Rule getRuleByIndex(int index) {
        for (int i = 0; i < realTypeRuleList.size(); i++) {
            if (realTypeRuleList.get(i).rule_index == index) {
                return realTypeRuleList.get(i);
            }
        }
        return null;
    }

    ArrayList<File> getSubTypeFileWithPoint(File dirFile, String pointType) {
        ArrayList<File> targetFileList = new ArrayList<File>();
        String fillterFileStr = "" + pointType.toLowerCase();
        if (!dirFile.isDirectory()) {
            return targetFileList;
        }
        File[] allSubFileList = dirFile.listFiles();
        for (File curFile : allSubFileList) {
            String fileName = curFile.getName().toLowerCase();
            if (fileName.endsWith(fillterFileStr)) {
                targetFileList.add(curFile);
            }
        }

        return targetFileList;
    }

    static String getTimeStampLong() {

        SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd_HHmmss_SSS");// 设置日期格式
        String date = df.format(new Date());
        return date;
    }

    static String getTimeStamp_YYYYMM() {

        SimpleDateFormat df = new SimpleDateFormat("yyyyMM");// 设置日期格式
        String date = df.format(new Date());
        return date;
    }

    static String getTimeStamp_YYYY_MM() {

        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM");// 设置日期格式
        String date = df.format(new Date());
        return date;
    }

    static String getTimeStamp() {

        SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd_HHmmss");// 设置日期格式
        String date = df.format(new Date());
        return date;
    }

    static String getTimeStamp_HHmmss() {

        SimpleDateFormat df = new SimpleDateFormat("HHmmss");// 设置日期格式
        String date = df.format(new Date());
        return date;
    }

    static String getTimeStamp_yyyyMMddHHmmss() {

        SimpleDateFormat df = new SimpleDateFormat("yyyyMMddHHmmss");// 设置日期格式
        String date = df.format(new Date());
        return date;
    }

    static String getTimeStamp_YYYYMMdd() {

        SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd");// 设置日期格式
        String date = df.format(new Date());
        return date;
    }

    static Rule getRuleByIdentify(String identify) {
        for (int i = 0; i < realTypeRuleList.size(); i++) {
            if (realTypeRuleList.get(i).identify.equals(identify)) {
                return realTypeRuleList.get(i);
            }
        }
        return null;
    }

    public static void fileCopy(File origin, File target) {
        InputStream input = null;
        OutputStream output = null;
        int lengthSize;
        // 创建输入输出流对象
        File targetDirParentFile = target.getParentFile();
        try {
            if (targetDirParentFile != null && !targetDirParentFile.exists()) {
                targetDirParentFile.mkdirs();
            }
            input = new FileInputStream(origin);
            output = new FileOutputStream(target);
            // 获取文件长度
            try {
                lengthSize = input.available();
                // 创建缓存区域
                byte[] buffer = new byte[lengthSize];
                // 将文件中的数据写入缓存数组
                input.read(buffer);
                // 将缓存数组中的数据输出到文件
                output.write(buffer);

            } catch (IOException e) {

                e.printStackTrace();
            }

        } catch (Exception e) {

        } finally {
            if (input != null && output != null) {
                try {
                    input.close(); // 关闭流
                    output.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static String execCMD_Windows(String command) {
//        System.out.println("══════════════Begin ExE ");
        StringBuilder sb = new StringBuilder();
        StringBuilder errorSb = new StringBuilder();
        try {

            Process process = Runtime.getRuntime().exec("CMD.exe /c start /B " + command);

            InputStreamReader inputReader = new InputStreamReader(process.getInputStream(), "GBK");
            BufferedReader bufferedReader = new BufferedReader(inputReader);
            String line;
            int waitFor = process.waitFor();
//            Stream<String> lines = bufferedReader.lines();
//            lines.iterator();
//            System.out.println("line Count = "+lines.count());

            while ((line = bufferedReader.readLine()) != null) {
                sb.append(line + "\n");

            }

            boolean isAlive = process.isAlive();
            int errorSteamCode = process.getErrorStream().read();

            String errorStream = process.getErrorStream().toString();
            int exitValue = process.exitValue();
//            process.getErrorStream().
            // 杀掉进程
//            System.out.println("exitValue ="+ exitValue);
            sb.append("\nexitValue = " + exitValue + "\nisAlive = " + isAlive + "\nerrorStream = " + errorStream
                    + "\nerrorSteamCode = " + errorSteamCode + "\nwaitFor = " + waitFor);
//            process.destroy();

        } catch (Exception e) {
            System.out.println("execCMD 出现异常! ");
            return e.toString();
        }

//        System.out.println("sb.toString() = "+ sb.toString());
//        System.out.println("══════════════End ExE ");
        return sb.toString();
    }

    /**
     * 执行 mac(unix) 脚本命令~
     *
     * @param command
     * @return
     */
    public static String execCMD_Mac(String command) {
        String[] cmd = { "/bin/bash" };
        Runtime rt = Runtime.getRuntime();
        Process proc = null;
        try {
            proc = rt.exec(cmd);
        } catch (IOException e) {
            e.printStackTrace();
        }

        // 打开流
        OutputStream os = proc.getOutputStream();
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(os));

        try {
            bw.write(command);

            bw.flush();
            bw.close();

            /** 真奇怪，把控制台的输出打印一遍之后竟然能正常终止了~ */
//            readConsole(proc);

            /** waitFor() 的作用在于 java 程序是否等待 Terminal 执行脚本完毕~ */
            proc.waitFor();
        } catch (Exception e) {
            e.printStackTrace();
        }
        int retCode = proc.exitValue();
        if (retCode != 0) {
            System.out.println("unix script retCode = " + retCode);

//            System.out.println(readConsole(proc));
            System.out.println("UnixScriptUil.execute 出错了!!");
        }
        return retCode + "";
    }

    static int getCurrentYear() {

        SimpleDateFormat df = new SimpleDateFormat("YYYY");

        return Integer.parseInt(df.format(new Date()));

    }

    // A1 ..... A2.
    static String get_Bat_Sh_FlagNumber(String mCur_Bat_Name) {
        String mCharNumber = "error";
        String curBat = mCur_Bat_Name;
        if (mCur_Bat_Name.contains(".sh")) {
            curBat = curBat.replace(".sh", "");
        }

        if (mCur_Bat_Name.contains(".bat")) {
            curBat = curBat.replace(".bat", "");
        }
        if (curBat.contains("_")) {
            String[] arrNameList = curBat.split("_");
            mCharNumber = arrNameList[arrNameList.length - 1];
        } else {
            mCharNumber = curBat;
        }

        return mCharNumber;
    }

    public static String execCMD(String command) {

        String result = "";
        if (CUR_OS_TYPE == OS_TYPE.Windows) {
            return execCMD_Windows(command);
        } else if (CUR_OS_TYPE == OS_TYPE.MacOS) {

            return execCMD_Mac(command);
        } else {

            execCMD_Mac(command);
        }
        return result;
    }

    /**
     * 执行 mac(unix) 脚本命令~
     *
     * @param command
     * @return
     */
    public static int execute_Mac(String command) {
        String[] cmd = { "/bin/bash", "-c", command };
        Runtime rt = Runtime.getRuntime();
        Process proc = null;
        try {
            proc = rt.exec(cmd);
        } catch (IOException e) {
            e.printStackTrace();
        }

        // 打开流
//        OutputStream os = proc.getOutputStream();
//        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(os));

        try {
//            String newCommand = "/bin/bash -c "+"\""+command+"\"";
//            System.out.println("newCommand = " + newCommand);

//            bw.write(newCommand);

//
//            bw.flush();
//            bw.close();

            /** 真奇怪，把控制台的输出打印一遍之后竟然能正常终止了~ */
//            readConsole(proc);

            /** waitFor() 的作用在于 java 程序是否等待 Terminal 执行脚本完毕~ */
            proc.waitFor();
            Thread.sleep(100000);

        } catch (Exception e) {
            e.printStackTrace();
        }
//        int retCode = proc.exitValue();
//        if (retCode != 0) {
//            System.out.println("unix script retCode = " + retCode);
//
//            System.out.println(readConsole(proc));
//            System.out.println("UnixScriptUil.execute 出错了!!");
//        }

        return 0;
    }

    /**
     * 计算转换后目标矩形的宽高
     *
     * @param src   源矩形
     * @param angel 角度
     * @return 目标矩形
     */
    static Rectangle CalcRotatedSize(Rectangle src, int angel) {
        double cos = Math.abs(Math.cos(Math.toRadians(angel)));
        double sin = Math.abs(Math.sin(Math.toRadians(angel)));
        int des_width = (int) (src.width * cos) + (int) (src.height * sin);
        int des_height = (int) (src.height * cos) + (int) (src.width * sin);
        return new Rectangle(new Dimension(des_width, des_height));
    }

    /**
     * 旋转角度
     *
     * @param src   源图片
     * @param angel 角度
     * @return 目标图片
     */
    public static BufferedImage rotate(Image src, int angel) {
        int src_width = src.getWidth(null);
        int src_height = src.getHeight(null);
        // calculate the new image size

        Rectangle rect_des = CalcRotatedSize(new Rectangle(new Dimension(src_width, src_height)), angel);

        BufferedImage res = null;
        res = new BufferedImage(rect_des.width, rect_des.height, BufferedImage.TYPE_INT_RGB);
        Graphics2D g2 = res.createGraphics();
        // transform(这里先平移、再旋转比较方便处理；绘图时会采用这些变化，绘图默认从画布的左上顶点开始绘画，源图片的左上顶点与画布左上顶点对齐，然后开始绘画，修改坐标原点后，绘画对应的画布起始点改变，起到平移的效果；然后旋转图片即可)

        g2.translate((rect_des.width - src_width) / 2, (rect_des.height - src_height) / 2);

        g2.rotate(Math.toRadians(angel), src_width / 2, src_height / 2);

//        //先旋转（以目标区域中心点为旋转中心点，源图片左上顶点对准目标区域中心点，然后旋转）
//        g2.translate(rect_des.width/2,rect_des.height/ 2);
//        g2.rotate(Math.toRadians(angel));
//        //再平移（原点恢复到源图的左上顶点处（现在的右上顶点处），否则只能画出1/4）
//        g2.translate(-src_width/2,-src_height/2);

        g2.drawImage(src, null, null);
        return res;
    }

    static void SortString(ArrayList<String> strList) {
        Comparator<Object> CHINA_COMPARE = Collator.getInstance(Locale.CHINA);
        strList.sort((o1, o2) -> {
            // 比较的基本原则，拿最小长度的字符串进行比较，若全部相等，则长字符串往后排

            int len1 = o1.length();
            int len2 = o2.length();
            int len = (len1 - len2) <= 0 ? len1 : len2;
            StringBuilder sb1 = new StringBuilder();
            StringBuilder sb2 = new StringBuilder();
            for (int i = 0; i < len; i++) {
                String s1 = o1.substring(i, i + 1);
                String s2 = o2.substring(i, i + 1);
                if (isNumericFirstChar(s1) && isNumericFirstChar(s2)) {
                    // 取出所有的数字
                    sb1.append(s1);
                    sb2.append(s2);
                    // 取数字时，不比较
                    continue;
                }
                if (sb1.length() != 0 && sb2.length() != 0) {
                    if (!isNumericFirstChar(s1) && !isNumericFirstChar(s2)) {
                        int value1 = Integer.valueOf(sb1.toString());
                        int value2 = Integer.valueOf(sb2.toString());
                        return value1 - value2;
                    } else if (isNumericFirstChar(s1)) {
                        return 1;
                    } else if (isNumericFirstChar(s2)) {
                        return -1;
                    }
                }
                int result = CHINA_COMPARE.compare(s1, s2);
                if (result != 0) {
                    return result;
                }
            }
            // 这一步：是为了防止以下情况：第10 第20，正好以数字结尾，且字符串长度相等
            if (len1 == len2 && sb1.length() != 0 && sb2.length() != 0) {
                int value1 = Integer.valueOf(sb1.toString());
                int value2 = Integer.valueOf(sb2.toString());
                return value1 - value2;
            }
            // 若前面都相等，则直接比较字符串的长度，长的排后面，短的排前面
            return Integer.compare(len1, len2);
        });

    }

    static void SortFileWithName(ArrayList<File> fileList) {
        Comparator<Object> CHINA_COMPARE = Collator.getInstance(Locale.CHINA);
        fileList.sort((o1_file, o2_file) -> {
            // 比较的基本原则，拿最小长度的字符串进行比较，若全部相等，则长字符串往后排
            String o1 = o1_file.getName();
            String o2 = o2_file.getName();
            int len1 = o1.length();
            int len2 = o2.length();
            int len = (len1 - len2) <= 0 ? len1 : len2;
            StringBuilder sb1 = new StringBuilder();
            StringBuilder sb2 = new StringBuilder();
            for (int i = 0; i < len; i++) {
                String s1 = o1.substring(i, i + 1);
                String s2 = o2.substring(i, i + 1);
                if (isNumericFirstChar(s1) && isNumericFirstChar(s2)) {
                    // 取出所有的数字
                    sb1.append(s1);
                    sb2.append(s2);
                    // 取数字时，不比较
                    continue;
                }
                if (sb1.length() != 0 && sb2.length() != 0) {
                    if (!isNumericFirstChar(s1) && !isNumericFirstChar(s2)) {
                        int value1 = Integer.valueOf(sb1.toString());
                        int value2 = Integer.valueOf(sb2.toString());
                        return value1 - value2;
                    } else if (isNumericFirstChar(s1)) {
                        return 1;
                    } else if (isNumericFirstChar(s2)) {
                        return -1;
                    }
                }
                int result = CHINA_COMPARE.compare(s1, s2);
                if (result != 0) {
                    return result;
                }
            }
            // 这一步：是为了防止以下情况：第10 第20，正好以数字结尾，且字符串长度相等
            if (len1 == len2 && sb1.length() != 0 && sb2.length() != 0) {
                int value1 = Integer.valueOf(sb1.toString());
                int value2 = Integer.valueOf(sb2.toString());
                return value1 - value2;
            }
            // 若前面都相等，则直接比较字符串的长度，长的排后面，短的排前面
            return Integer.compare(len1, len2);
        });

    }

    // 判断是否是数字
    static boolean isNumericFirstChar(String s) {
        return Character.isDigit(s.charAt(0));
    }

    static ArrayList<File> getRealFileWithDirAndPointType(File dirFile, ArrayList<String> selectTypeList) {

        ArrayList<File> targetFileList = new ArrayList<File>();
        if (dirFile == null || !dirFile.exists() || dirFile.isFile()) {
            return targetFileList;
        }

        File[] dir_fileList = dirFile.listFiles();

        for (int i = 0; i < dir_fileList.length; i++) {
            File itemFile = dir_fileList[i];
            if (itemFile.isDirectory()) {
                continue;
            }

            if (selectTypeList == null || selectTypeList.size() == 0) {
                targetFileList.add(itemFile);
                continue;
            }
            String fileName_lower = itemFile.getName().toLowerCase();

            for (int j = 0; j < selectTypeList.size(); j++) {
                String typeStr = selectTypeList.get(j);
                if (fileName_lower.endsWith(typeStr.trim().toLowerCase())) {
                    targetFileList.add(itemFile);
                }

            }

        }
        return targetFileList;
    }

    static ArrayList<File> getRealFileWithDirAndPointType(File dirFile, String type) {

        ArrayList<File> targetFileList = new ArrayList<File>();
        if (dirFile == null || !dirFile.exists() || dirFile.isFile()) {
            return targetFileList;
        }

        File[] dir_fileList = dirFile.listFiles();

        for (int i = 0; i < dir_fileList.length; i++) {
            File itemFile = dir_fileList[i];
            if (itemFile.isDirectory()) {
                continue;
            }
            if (type == null || "".equals(type.trim())) {
                targetFileList.add(itemFile);
                continue;
            }
            String fileName_lower = itemFile.getName().toLowerCase();

            if (fileName_lower.endsWith(type.trim().toLowerCase())) {
                targetFileList.add(itemFile);
            }

        }
        return targetFileList;
    }

    public static String clearNumber(String str) {
        String result = new String(str);
        result = result.replaceAll("0", "");
        result = result.replaceAll("1", "");
        result = result.replaceAll("2", "");
        result = result.replaceAll("3", "");
        result = result.replaceAll("4", "");
        result = result.replaceAll("5", "");
        result = result.replaceAll("6", "");
        result = result.replaceAll("7", "");
        result = result.replaceAll("8", "");
        result = result.replaceAll("9", "");
        return result;
    }

    /**
     * 汉字转为拼音 空间以下划线_分割 1.每个汉字前面添加_ 2.每个汉字后面添加_ 3.把所有的两个__ 下划线转为 一个下划线
     *
     * @param chinese
     * @return
     */
    public static String ToPinyin(String chinese) {
        if (chinese == null || chinese.trim().isEmpty()) {
            return null;
        }
        String curItem = new String(chinese);
        while (curItem.contains(" ")) {
            curItem = curItem.replaceAll(" ", "");
        }
        String pinyinStr = "";
        char[] newChar = curItem.toCharArray();
        HanyuPinyinOutputFormat defaultFormat = new HanyuPinyinOutputFormat();
        defaultFormat.setCaseType(HanyuPinyinCaseType.LOWERCASE);
        defaultFormat.setToneType(HanyuPinyinToneType.WITHOUT_TONE);
        for (int i = 0; i < newChar.length; i++) {
            if (newChar[i] > 128) {
                try {
                    // 《》，：“￥。，？。，；【 】。、

//                    System.out.println("xxxxxxxxxx");
//                    System.out.println("newChar["+i+"] = "+ newChar[i]);
                    String charStr = newChar[i] + "";
                    if (charStr.equals("《")) {
                        pinyinStr += "<";
                        continue;
                    } else if (charStr.equals("》")) {
                        pinyinStr += ">";
                        continue;
                    } else if (charStr.equals("，")) {
                        pinyinStr += ",";
                        continue;
                    } else if (charStr.equals("：")) {
                        pinyinStr += ":";
                        continue;
                    } else if (charStr.equals("“")) {
                        pinyinStr += "\"";
                        continue;
                    } else if (charStr.equals("￥")) {
                        pinyinStr += "$";
                        continue;
                    } else if (charStr.equals("？")) {
                        pinyinStr += "?";
                        continue;
                    } else if (charStr.equals("；")) {
                        pinyinStr += ";";
                        continue;
                    } else if (charStr.equals("【")) {
                        pinyinStr += "[";
                        continue;
                    } else if (charStr.equals("】")) {
                        pinyinStr += "]";
                        continue;
                    } else if (charStr.equals("、")) {
                        pinyinStr += ",";
                        continue;
                    }

                    String[] arrChar = PinyinHelper.toHanyuPinyinStringArray(newChar[i], defaultFormat);
                    if (arrChar == null) {
                        System.out.println("pinyinStr = " + null);
                        continue;
                    }
                    pinyinStr += "_" + arrChar[0] + "_"; // [0] 标识当前拼音 汉-> han
//                    System.out.println("pinyinStr = "+ pinyinStr);
//                    System.out.println("xxxxxxxxxx ");
                } catch (BadHanyuPinyinOutputFormatCombination e) {
                    e.printStackTrace();
                }
            } else { // 汉字的编码是大于 128的 所以 小于 128编码的就直接认为是 ascii编码的
                pinyinStr += newChar[i];
            }
        }
        while (pinyinStr.contains("__")) {
            pinyinStr = pinyinStr.replaceAll("__", "_");
//            System.out.println("pinyinStr1 = " + pinyinStr);
        }

        while (pinyinStr.contains("u:")) { // 女转为 nu: 绿 lu: 需要转为 nv lv
            pinyinStr = pinyinStr.replaceAll("u:", "v");
//            System.out.println("pinyinStr1 = " + pinyinStr);
        }

        while (pinyinStr.startsWith("_")) {
            pinyinStr = pinyinStr.substring(1, pinyinStr.length());
//            System.out.println("pinyinStr2 = " + pinyinStr);
        }
        while (pinyinStr.endsWith("_")) {
            pinyinStr = pinyinStr.substring(0, pinyinStr.length() - 1);
//            System.out.println("pinyinStr3 = " + pinyinStr);
        }
        return pinyinStr;
    }

    public static String getFileNameNoPointNoLowerCase(String fileName) {
        String name = "";
        if (fileName.contains(".")) {
            name = fileName.substring(0, fileName.lastIndexOf(".")).trim();
        } else {
            name = new String(fileName);
        }
        return name.trim();
    }

    /**
     * BASE64解密
     *
     * @throws Exception
     */
    public static String jiemi_decryptBASE64(String key) throws Exception {
        return new String(Base64.getDecoder().decode(key));
    }

    /**
     * BASE64加密
     */
    public static String jiami_encryptBASE64(byte[] key) throws Exception {

        return new String(Base64.getEncoder().encode(key));
    }

    static void NotePadOpenTargetFile(String absPath) {
        String commandNotead = "";
        if (CUR_OS_TYPE == OS_TYPE.Windows) {
            commandNotead = "cmd.exe /c start   Notepad++.exe " + absPath;
            execCMD(commandNotead);

        } else if (CUR_OS_TYPE == OS_TYPE.Linux) {
            commandNotead = " gedit " + absPath;
        } else if (CUR_OS_TYPE == OS_TYPE.MacOS) {
            commandNotead = "/Applications/UltraEdit  " + absPath;
            execute_Mac(commandNotead);
        }
    }

    static ArrayList<File> getAllSubFileInFileList(ArrayList<File> rootFileList, String typeStr) {
        if (rootFileList == null || rootFileList.size() == 0) {
            return null;
        }
        ArrayList<File> ResultFileList = new ArrayList<File>();

        ArrayList<String> typeList = new ArrayList<String>();
        typeList.add(typeStr);

        for (int i = 0; i < rootFileList.size(); i++) {
            File dirFile = rootFileList.get(i);
            ArrayList<File> flitterFileList = getAllSubFile(dirFile.getAbsolutePath(), "", typeList);
            if (flitterFileList == null || flitterFileList.size() == 0) {
                continue;
            }
            ResultFileList.addAll(flitterFileList);
        }

        return ResultFileList;

    }

    static String getFirstZiMu(String srcStr) {
        String firstZimu = "U"; // 默认为 Unknow;
        if (srcStr == null || "".equals(srcStr.trim())) {
            return firstZimu;
        }

        if (!isContainChinese(srcStr)) { // 如果 不包含中文 那么 取这个词的 第一个字符
            String char_1 = srcStr.substring(0, 1).toUpperCase();
            firstZimu = char_1;

        } else {
            String char_1 = srcStr.substring(0, 1).toUpperCase();
//			System.out.println("X2 char_1 = "+char_1 );
            if (!isContainChinese(char_1)) {
                firstZimu = char_1;
            } else { // 如果第一个字母为汉字 那么取到这个字的 拼音的 第一个词
                String pinyinStr = ToPinyin(char_1);
//				System.out.println("X2  pinyinStr = "+pinyinStr );
                String char_1_fixed = pinyinStr.substring(0, 1).toUpperCase();
                firstZimu = char_1_fixed;
            }

        }

//		System.out.println("X3  firstZimu = "+firstZimu );
        return firstZimu;

    }

    /**
     * 删除文件，可以是文件或文件夹
     *
     * @param fileName 要删除的文件名
     * @return 删除成功返回true，否则返回false
     */
    public static boolean delete(String fileName) {
        File file = new File(fileName);
        if (!file.exists()) {
            System.out.println("删除文件失败:" + fileName + "不存在！");
            return false;
        } else {
            if (file.isFile())
                return deleteFile(fileName);
            else
                return deleteDirectory(fileName);
        }
    }

    /**
     * 删除单个文件
     *
     * @param fileName 要删除的文件的文件名
     * @return 单个文件删除成功返回true，否则返回false
     */
    public static boolean deleteFile(String fileName) {
        File file = new File(fileName);
        // 如果文件路径所对应的文件存在，并且是一个文件，则直接删除
        if (file.exists() && file.isFile()) {
            if (file.delete()) {
                System.out.println("删除单个文件" + fileName + "成功！");
                return true;
            } else {
                System.out.println("删除单个文件" + fileName + "失败！");
                return false;
            }
        } else {
            System.out.println("删除单个文件失败：" + fileName + "不存在！");
            return false;
        }
    }

    /**
     * 删除目录及目录下的文件
     *
     * @param dir 要删除的目录的文件路径
     * @return 目录删除成功返回true，否则返回false
     */
    public static boolean deleteDirectory(String dir) {
        // 如果dir不以文件分隔符结尾，自动添加文件分隔符
        if (!dir.endsWith(File.separator))
            dir = dir + File.separator;
        File dirFile = new File(dir);
        // 如果dir对应的文件不存在，或者不是一个目录，则退出
        if ((!dirFile.exists()) || (!dirFile.isDirectory())) {
            System.out.println("删除目录失败：" + dir + "不存在！");
            return false;
        }
        boolean flag = true;
        // 删除文件夹中的所有文件包括子目录
        File[] files = dirFile.listFiles();
        for (int i = 0; i < files.length; i++) {
            // 删除子文件
            if (files[i].isFile()) {
                flag = deleteFile(files[i].getAbsolutePath());
                if (!flag)
                    break;
            }
            // 删除子目录
            else if (files[i].isDirectory()) {
                flag = deleteDirectory(files[i].getAbsolutePath());
                if (!flag)
                    break;
            }
        }
        if (!flag) {
            System.out.println("删除目录失败！");
            return false;
        }
        // 删除当前目录
        if (dirFile.delete()) {
            System.out.println("删除目录" + dir + "成功！");
            return true;
        } else {
            return false;
        }
    }

    /**
     * 图片翻转时，计算图片翻转到正常显示需旋转角度
     */
    public static boolean getRotateAngleForPhoto(String fileName) {

        boolean isPort = true;
        File file = new File(fileName);

        int angel = 0;
        Metadata metadata;

        try {
            metadata = JpegMetadataReader.readMetadata(file);
            metadata.getDirectories();

            // zukgit_directory [Exif IFD0] - Orientation = Right side, top (Rotate 90 CW)
            for (Directory directory : metadata.getDirectories()) {
                for (Tag tag : directory.getTags()) {
                    // 格式化输出[directory.getName()] - tag.getTagName() = tag.getDescription()
                    System.out.format("zukgit_directory  [%s] - %s = %s\n", directory.getName(), tag.getTagName(),
                            tag.getDescription());

                    if ("Exif IFD0".equals(directory.getName())) {
                        String orientation = directory.getString(ExifIFD0Directory.TAG_ORIENTATION);
                        System.out.println("ZZOrientation = " + orientation);

                        if ("1".equals(orientation)) { // 90度 和 270度 宽高对调了
                            angel = 0;

                        } else if ("6".equals(orientation)) {
                            // 6旋转90
                            angel = 90;
                            isPort = false;
                        } else if ("3".equals(orientation)) {
                            // 3旋转180
                            angel = 180;
                        } else if ("8".equals(orientation)) {
                            // 8旋转90
                            angel = 270;
                            isPort = false;
                        }
                        return isPort;
                    }
                }
//				if (directory.hasErrors()) {
//					for (String error : directory.getErrors()) {
//						System.err.format("ERROR: %s", error);
//					}
//				}
            }

            /*
             * if(directory.containsTag(ExifDirectory.TAG_ORIENTATION)){ // Exif信息中方向 int
             * orientation = directory.getInt(ExifDirectory.TAG_ORIENTATION); // 原图片的方向信息
             * if(6 == orientation ){ //6旋转90 angel = 90; }else if( 3 == orientation){
             * //3旋转180 angel = 180; }else if( 8 == orientation){ //8旋转90 angel = 270; } }
             */

        } catch (JpegProcessingException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
//		System.out.println("图片旋转角度：" + angel);
        return isPort;
    }

    public static String getMainPageHtmlCode(String url) {

        File ChromeDriverFile = new File(zbinPath + File.separator + "G2_chromedriver_v91.exe");

        ChromeOptions CUR_CHROME_OPTIONS = new ChromeOptions();
        // 驱动位置
        CUR_CHROME_OPTIONS.addArguments("--start-fullscreen");

//			CUR_CHROME_OPTIONS.addArguments("Accept=text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8");
//			CUR_CHROME_OPTIONS.addArguments("Accept-Encoding=gzip, deflate, sdch");
//			CUR_CHROME_OPTIONS.addArguments("Accept-Language=zh-CN,zh;q=0.8");
//			CUR_CHROME_OPTIONS.addArguments("Connection=keep-alive");
//			CUR_CHROME_OPTIONS.addArguments("Host=activityunion-marketing.meituan.com");
//			CUR_CHROME_OPTIONS.addArguments("Upgrade-Insecure-Requests=1");
//			CUR_CHROME_OPTIONS.addArguments("User-Agent=Mozilla/5.0 (iPhone; CPU iPhone OS 8_0 like Mac OS X) AppleWebKit/600.1.3 (KHTML, like Gecko) Version/8.0 Mobile/12A4345d Safari/600.1.4");

        System.setProperty("webdriver.chrome.driver", ChromeDriverFile.getAbsolutePath());
        // 避免被浏览器检测识别
        CUR_CHROME_OPTIONS.setExperimentalOption("excludeSwitches", Collections.singletonList("enable-automation"));

        ChromeDriver driver = new ChromeDriver(CUR_CHROME_OPTIONS);
        int loop_index = 0;
        try {

            driver.get(url);
            long waitTime = Double.valueOf(Math.max(3, Math.random() * 5) * 1000).longValue();
            TimeUnit.MILLISECONDS.sleep(waitTime);
            long timeout = 20_000;
            // 循环下拉，直到全部加载完成或者超时
            do {
                new Actions(driver).sendKeys(Keys.END).perform();
                TimeUnit.MILLISECONDS.sleep(waitTime);
                if (loop_index == 1) {
                    System.out.println("!! 触发点击事件  起始 标识 AAA !!");
                    new Actions(driver).sendKeys(Keys.HOME).perform();
                    TimeUnit.MILLISECONDS.sleep(1500);
                    try {
                        driver.findElement(By.className("xgplayer-start")).click();
                        TimeUnit.MILLISECONDS.sleep(2000);
                    } catch (Exception e) {
                        System.out.println("尝试点击播放按钮失败!! ");

                        System.out.println("click异常:");
                        System.out.println(e.fillInStackTrace());

                    }

                }

                TimeUnit.MILLISECONDS.sleep(waitTime);
                timeout -= waitTime;
                loop_index++;
            } while (!driver.getPageSource().contains("已经到底部，没有新的内容啦") && timeout > 0);
            System.out.println("已经到底部，没有新的内容啦");
            return driver.getPageSource();
        } catch (Exception e) {
            // TODO: handle exception
            System.out.println("获取网页源码的时候出错  url = " + url);
            e.printStackTrace();

        } finally {
            driver.close();

        }
        return null;
    }

    static String getTimeStampyyyyMMdd_HHmmss() {

        SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd_HHmmss");// 设置日期格式
        String date = df.format(new Date());
        return date;
    }

    static String getYear_Month_Day() {

        SimpleDateFormat df = new SimpleDateFormat("yyyy-MM-dd");// 设置日期格式
        String date = df.format(new Date());
        return date;
    }

    static File getPCScreenFile() {

        // H7_Email_WorkPlace
        // 把截图放到 C:\Users\zhuzj5\Desktop\zbin\H7_Email_WorkPlace\yyMMdd_hhmmss 文件夹中

        String timestamp = getTimeStamp_YYYYMMdd();
        String H7_WorkPlace_TaskDir = zbinPath + File.separator + "G2_Monitor_Download" + File.separator
                + getTimeStamp_YYYYMM();

        File taskDirFile = new File(H7_WorkPlace_TaskDir);
        if (!taskDirFile.exists()) {
            taskDirFile.mkdirs();
        }

        File imageFIle = null;
        String imageName = "pc_screen_" + getTimeStampyyyyMMdd_HHmmss() + ".png";
        String imageAbsPath = H7_WorkPlace_TaskDir + File.separator + imageName;

        imageFIle = new File(imageAbsPath);

        if (!imageFIle.exists()) {
            try {
                imageFIle.createNewFile();
            } catch (Exception e) {

            }
        }

        // ----------------Image Begin---------
        GraphicsDevice gd = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice();
        int height = gd.getDisplayMode().getHeight();
        int width = gd.getDisplayMode().getWidth();
        Rectangle screenRect = new Rectangle(0, 0, width, height);
        cn.hutool.core.swing.ScreenUtil.captureScreen(screenRect, imageFIle);
//----------------Image End---------

        System.out.println("PC截图路径: " + imageAbsPath);
        if (!imageFIle.exists() || imageFIle.length() < 100) {
            return null;
        }

        return imageFIle;
//        File newImage_XY_File =   paintXYFromImageFile(imageFIle);
//        return newImage_XY_File;
    }

    static boolean isImageFile(File imageFIle) {
        boolean flag = false;
        if (imageFIle.getName().endsWith(".jpg") || imageFIle.getName().endsWith(".Jpg")
                || imageFIle.getName().endsWith(".JPG") || imageFIle.getName().endsWith(".png")
                || imageFIle.getName().endsWith(".Png") || imageFIle.getName().endsWith(".PNG")) {
            flag = true;
        }
        return flag;
    }

    public static String getFileTypeNoPoint(String fileName) {
        String name = "";
        if (fileName.contains(".")) {
            name = fileName.substring(fileName.lastIndexOf(".") + 1).trim().toLowerCase();
        } else {
            name = "";
        }
        return name.toLowerCase().trim();
    }

    static File paintXYFromImageFile(File imageFile) {
        if (!imageFile.exists() || imageFile.length() < 10 || !isImageFile(imageFile)) {
            return null;
        }

        String originName = getFileNameNoPoint(imageFile.getName());
        String imageType = getFileTypeNoPoint(imageFile.getName());
        String newImageFileNameStr = originName + "_xy" + "." + imageType;
        File newImageFile = new File(
                imageFile.getParentFile().getAbsolutePath() + File.separator + newImageFileNameStr);

        try {
            if (!newImageFile.exists()) {
                newImageFile.createNewFile();
            }
            BufferedImage bi = ImageIO.read(imageFile);
            int height = bi.getHeight();
            int width = bi.getWidth();

            int up_line_num = width / 10; // 竖线的数量
            int down_line_num = height / 10; // 横线的数量

            Graphics2D g2 = (Graphics2D) bi.getGraphics();
            g2.setColor(Color.RED);// 设置颜色
            g2.setStroke(new BasicStroke(1.5f)); // 直线粗细
            Font f = new Font("宋体", Font.BOLD, 20);
            g2.setFont(f); // 设置字体:字体、字号、大小
            for (int i = 0; i < down_line_num; i++) { // 横线的数量
                int down_origin_x_item = 0;
                int down_origin_y_item = 100 * i + 100;
                int down_new_x_item = width;
                int down_new_y_item = down_origin_y_item;

                int text_X = down_origin_x_item + 10; //
                int text_y = down_origin_y_item - 10; //
                g2.drawString(down_origin_y_item + "", text_X, text_y);
                g2.drawLine(down_origin_x_item, down_origin_y_item, down_new_x_item, down_new_y_item);
            }

            for (int i = 0; i < up_line_num; i++) { // 竖线的数量

                int down_origin_x_item = 100 * i + 100;
                int down_origin_y_item = 0;
                int down_new_x_item = down_origin_x_item;
                int down_new_y_item = height;
                int text_X = down_origin_x_item - 50; //
                int text_y = down_origin_y_item + 20;
                g2.drawString(down_origin_x_item + "", text_X, text_y);
                g2.drawLine(down_origin_x_item, down_origin_y_item, down_new_x_item, down_new_y_item);
            }
            ImageIO.write(bi, imageType, new FileOutputStream(newImageFile));
            System.out.println("程序执行结束!");
        } catch (IOException e) {

            e.printStackTrace();
            System.out.println("异常=" + e);
            return imageFile; // 出现异常 那么就不操作 x y 坐标了
        }
        return newImageFile;
    }

    @SuppressWarnings("unchecked")
    public static void sendemail(boolean isFirstMonitor , String PcName, String targetEMail, String mTitle, String inputContent,
                                 ArrayList<String> paramTextList, ArrayList<String> extraTextList, HashMap<File, String> imageFile_Desc_Map,
                                 ArrayList<File> attatchFileList) throws Exception {




        //  isFirstMonitor   如果是  第一个 邮件 那么 正文的 一部分设置成绿色
        // 给用户发送邮件的邮箱
        String from = "382581427@qq.com";
        // 邮箱的用户名
        String username = "382581427@qq.com";
        // 邮箱授权码 // kyioxkexvqdtbjhd【新】 pwkvngnpfkvpbgcd【旧】

        String password = "kyioxkexvqdtbjhd";
        // 发送邮件的服务器地址，QQ服务器
        String host = "smtp.qq.com";
        // 接收人邮箱
        String to = targetEMail;
        if (to == null || "".equals(to.trim())) {
            to = "zukgit@foxmail.com";
        }

        // 邮件主题
//        String title = "邮件主题[测试混合邮件]";
        String title = mTitle;
        if (title == null || "".equals(title.trim())) {
            title = "YYYYHHDD";
        }

        // 使用QQ邮箱时配置
        Properties prop = new Properties();
        prop.setProperty("mail.host", "smtp.qq.com"); // 设置QQ邮件服务器
        prop.setProperty("mail.transport.protocol", "smtp"); // 邮件发送协议
        prop.setProperty("mail.smtp.auth", "true"); // 需要验证用户名和密码

        // 关于QQ邮箱，还要设置SSL加密，其他邮箱不需要
        MailSSLSocketFactory sf = new MailSSLSocketFactory();
        sf.setTrustAllHosts(true);
        prop.put("mail.smtp.ssl.enable", "true");
        prop.put("mail.smtp.ssl.socketFactory", sf);

        // 创建定义整个邮件程序所需的环境信息的 Session 对象，QQ才有，其他邮箱就不用了
        javax.mail.Session session = javax.mail.Session.getInstance(prop, new Authenticator() {
            @Override
            protected PasswordAuthentication getPasswordAuthentication() {
                // 发件人邮箱用户名，授权码
                return new PasswordAuthentication(username, password);
            }
        });

        // 开启 Session 的 debug 模式，这样就可以查看程序发送 Email 的运行状态
//       session.setDebug(true);

        // 通过 session 得到 transport 对象
        javax.mail.Transport ts = session.getTransport();

        // 使用邮箱的用户名和授权码连上邮箱服务器
        ts.connect(host, username, password);

        // 创建邮件，写邮件
        // 需要传递 session
        MimeMessage message = new MimeMessage(session);
        message.setFrom(new javax.mail.internet.InternetAddress(from)); // 指明邮件的发件人
        message.setRecipient(javax.mail.Message.RecipientType.TO, new javax.mail.internet.InternetAddress(to)); // 指明邮件的收件人
        message.setSubject(mTitle); // 邮件主题

        // =========================================== 配置开始
        // ==============================
        // 遍历 imageFile_Desc_Map

        StringBuilder extraSB = new StringBuilder();
        if (extraTextList != null && extraTextList.size() > 0) { // 一些 额外的信息
            extraSB.append("<br><br>═══════ 副文开始 ═══════<br><br>");
            for (int i = 0; i < extraTextList.size(); i++) {
                extraSB.append(extraTextList.get(i) + "<br>");
            }
            extraSB.append("<br><br>═══════ 副文结束 ═══════<br><br>");
        }

        StringBuilder paramSB = new StringBuilder();
        if (paramTextList != null && paramTextList.size() > 0) { // 一些 额外的信息

            for (int i = 0; i < paramTextList.size(); i++) {
                paramSB.append(paramTextList.get(i) + "<br>");
            }

        }

        ArrayList<MimeBodyPart> image_desc_MimeBodyPartList = new ArrayList<MimeBodyPart>();

        MimeBodyPart body_content = new MimeBodyPart(); // 文字内容
        File lastAttatchFile =  null ;
        if(attatchFileList != null && attatchFileList.size() > 0 ) {

            lastAttatchFile = attatchFileList.get(attatchFileList.size()-1);

        }

        if(isFirstMonitor) {

            body_content.setContent("<font color=\"green\">"+inputContent + "</font><br><br>" + PcName + " " + getTimeStampyyyyMMdd_HHmmss()+" LastFile:"+lastAttatchFile
                    + "<br>═1═1═1═1═1═1═ 正文结束 ═1═1═1═1═1═1═<br>" + "" + "<br>" + paramSB.toString() + "<br>═1═1═1═1═1═1═ 参数结束 ═1═1═1═1═1══<br><br>"
                    + extraSB.toString(), "text/html;charset=utf-8");

        }else {

            body_content.setContent(inputContent + "<br><br>" + PcName + " " + getTimeStampyyyyMMdd_HHmmss()+" LastFile:"+lastAttatchFile
                    + "<br>═══════ 正文结束 ═══════<br>" + "" + "<br>" + paramSB.toString() + "<br>═══════ 参数结束 ═══════<br><br>"
                    + extraSB.toString(), "text/html;charset=utf-8");
        }

        image_desc_MimeBodyPartList.add(body_content);

        if (imageFile_Desc_Map != null) {

            Map.Entry<File, String> entryItem;
            int item_index = 0;
            int map_size = 0;
            map_size = imageFile_Desc_Map.size();
            Iterator iterator = imageFile_Desc_Map.entrySet().iterator();
            while (iterator.hasNext()) {
                entryItem = (Map.Entry<File, String>) iterator.next();
                File key_file = entryItem.getKey(); // Map的Key
                String value_desc = entryItem.getValue(); // Map的Value
                if (key_file == null) {
                    System.out.println("map[" + item_index + "][" + map_size + "]____" + "key[" + key_file + "]-value["
                            + value_desc + "]" + " 为空! ");
                    continue;
                }

                if (!key_file.exists()) {
                    System.out.println("map[" + item_index + "][" + map_size + "]____" + "key[" + key_file + "]-value["
                            + value_desc + "]" + " 不存在! ");
                    continue;
                }
                System.out.println("map[" + item_index + "][" + map_size + "]____" + "key[" + key_file + "]-value["
                        + value_desc + "]");

                MimeBodyPart body_image = new MimeBodyPart();
                body_image.setDataHandler(new javax.activation.DataHandler(
                        new javax.activation.FileDataSource(key_file.getAbsolutePath())));
                body_image.setContentID(key_file.getName());

                // 文本
                // " 图片描述:fafa <img src='cid:1.png'>", "text/html;charset=utf-8"
//   		        body2.setContent("我不是广告，<img src='cid:1.png'>", "text/html;charset=utf-8");
                String image_item_desc = value_desc + " <img src='cid:" + key_file.getName() + "'>";
                MimeBodyPart body_text = new MimeBodyPart();
                body_text.setContent(image_item_desc, "text/html;charset=utf-8");

                image_desc_MimeBodyPartList.add(body_image);
                image_desc_MimeBodyPartList.add(body_text);

                item_index++;
            }
        }

        MimeMultipart image_desc_MimeMultipart = null;
        if (image_desc_MimeBodyPartList != null && image_desc_MimeBodyPartList.size() > 0) {
            image_desc_MimeMultipart = new MimeMultipart();

            for (int i = 0; i < image_desc_MimeBodyPartList.size(); i++) {
                image_desc_MimeMultipart.addBodyPart(image_desc_MimeBodyPartList.get(i));
            }
            image_desc_MimeMultipart.setSubType("related"); // 文本和图片内嵌成功
        }

        ArrayList<MimeBodyPart> attatch_MimeBodyPartList = new ArrayList<MimeBodyPart>();

        if (attatchFileList != null && attatchFileList.size() > 0) {

            for (int i = 0; i < attatchFileList.size(); i++) {
                File attatchFile = attatchFileList.get(i);

                MimeBodyPart body_attatch = new MimeBodyPart();
                body_attatch.setDataHandler(new javax.activation.DataHandler(
                        new javax.activation.FileDataSource(attatchFile.getAbsolutePath())));
                body_attatch.setFileName(attatchFile.getName());
                attatch_MimeBodyPartList.add(body_attatch);
            }

        }

        // 将拼装好的正文内容设置为主体
        MimeBodyPart contentText = new MimeBodyPart();
        if (image_desc_MimeMultipart != null) {
            contentText.setContent(image_desc_MimeMultipart);
        }

        // 拼接附件与正文内容
        MimeMultipart all_MimeMultipart = new MimeMultipart();
        all_MimeMultipart.addBodyPart(contentText);
        for (int i = 0; i < attatch_MimeBodyPartList.size(); i++) {
            all_MimeMultipart.addBodyPart(attatch_MimeBodyPartList.get(i)); // 添加附件
        }
        all_MimeMultipart.setSubType("mixed");

        // =========================================== 配置结束
        // ==============================
        // 设置到消息中，保存修改
        message.setContent(all_MimeMultipart); // 把最后编辑好的邮件放到消息当中
        message.saveChanges(); // 保存修改

        // 发送邮件
        ts.sendMessage(message, message.getAllRecipients());

        System.out.println("sendemail finish__________");

        // 释放资源
        ts.close();

    }

    static ArrayList<String> getWifiInfoList() {
        ArrayList<String> wifiInfoList = new ArrayList<String>();
        String osName = System.getProperties().getProperty("os.name").toLowerCase();
        File wifiLogFile = new File(System.getProperties().getProperty("user.home") + File.separator + "Desktop"
                + File.separator + "zbin" + File.separator + "E2_WifiDetail.txt");

        if (osName != null && osName.toLowerCase().contains("win")) { // windows 系统
            String word1 = "上的配置文件"; // 接口 WLAN 上的配置文件 debugtheworld:
            String word2 = "关键内容"; // 关键内容 : 12345678

            String curMatchContent = "";
            String tip = "";
            if (wifiLogFile.exists()) {
                String UTF8_Conent = ReadFileContent_No_UTF8(wifiLogFile);
                String Default_Conent = ReadFileContent_No_UTF8(wifiLogFile);
                String GBK_Conent = ReadFileContent_GBK(wifiLogFile);

                if (UTF8_Conent.contains(word2)) {
                    curMatchContent = UTF8_Conent;
                    tip = "UTF8_Conent";
                } else if (Default_Conent.contains(word2)) {
                    curMatchContent = Default_Conent;
                    tip = "Default_Conent";
                } else if (GBK_Conent.contains(word2)) {
                    curMatchContent = GBK_Conent;
                    tip = "GBK_Conent";
                }

            }

            System.out.println("tipA[" + tip + "]  curMatchContent=" + curMatchContent);

            ArrayList<WifiItem> wifiItemList = new ArrayList<WifiItem>();

            // 如果 有 就 读取 txt 文件 ,
            if (wifiLogFile.exists() && curMatchContent.contains(word2)) {
                // System.out.println("wifiLogFile 文件存在");
                readWifiObjectFromString(curMatchContent, wifiItemList);
                ArrayList<String> wifiList = transactWifiList(wifiItemList);

                System.out.println(" Read-Wifi_Success   wifiList.size()=" + wifiList.size());

                if (wifiList != null && wifiList.size() > 0) {

                    for (int i = 0; i < wifiList.size(); i++) {
                        String wifiStr = wifiList.get(i);
                        if (!wifiInfoList.contains(wifiStr)) {
                            wifiInfoList.add(wifiStr);
                        }
                    }

                }

//                return wifiList;   // 这里不返回   因为  有可能 当前 不是最新的数据

            }

            if (!wifiLogFile.exists() || !curMatchContent.contains(word2)) { // 如果 不存在 那么 执行 相关命令得到 对应的文件 执行
                // E2_WifiDetail_Exit.bat 文件
                File E2_WifiDetail_Bat_File = new File(System.getProperties().getProperty("user.home") + File.separator
                        + "Desktop" + File.separator + "zbin" + File.separator + "E2_WifiDetail_Exit.bat");

                System.out.println("执行 Bat 文件 " + E2_WifiDetail_Bat_File.getAbsolutePath() + " Begin");
                execCMD(E2_WifiDetail_Bat_File.getAbsolutePath());
                System.out.println("执行 Bat 文件 " + E2_WifiDetail_Bat_File.getAbsolutePath() + " End");

                try {
                    Thread.sleep(1500); // 睡 1.5 秒
                } catch (InterruptedException e) {
                    // TODO Auto-generated catch block
                    e.printStackTrace();
                }

                boolean wifiLogExist = wifiLogFile.exists();
                boolean isContainWord = false;
                String wifiLog_Content = "";

                if (wifiLogExist) {
                    String UTF8_Conent = ReadFileContent_No_UTF8(wifiLogFile);
                    String Default_Conent = ReadFileContent_No_UTF8(wifiLogFile);
                    String GBK_Conent = ReadFileContent_GBK(wifiLogFile);

                    if (UTF8_Conent.contains(word2)) {
                        curMatchContent = UTF8_Conent;
                        tip = "UTF8_Conent";
                    } else if (Default_Conent.contains(word2)) {
                        curMatchContent = Default_Conent;
                        tip = "Default_Conent";
                    } else if (GBK_Conent.contains(word2)) {
                        curMatchContent = GBK_Conent;
                        tip = "GBK_Conent";
                    }

                    wifiLog_Content = ReadFileContent(wifiLogFile);
                    isContainWord = curMatchContent.contains(word2);
                }

                boolean conainWord = curMatchContent.contains(word2);
                System.out.println(
                        "tipB[" + tip + "]  conainWord=" + conainWord + "   curMatchContent=" + curMatchContent);

                if (wifiLogFile.exists() && curMatchContent.contains(word2)) {
                    // System.out.println("wifiLogFile 文件存在");
                    readWifiObjectFromString(curMatchContent, wifiItemList);
                    ArrayList<String> wifiList = transactWifiList(wifiItemList);
                    System.out.println("getWifiInfoList() __A__  wifiList.size= " + wifiList.size() + "wifiLogExist = "
                            + wifiLogExist + "isContainWord=" + isContainWord + "  curMatchContent=" + curMatchContent);

                    if (wifiList != null && wifiList.size() > 0) {
                        wifiList.addAll(wifiList);
                    }

//	              	return wifiList;

                }
                System.out.println("getWifiInfoList() __B__  getWifiInfoList().size= " + wifiInfoList.size()
                        + "   wifiLogExist = " + wifiLogExist + "  isContainWord=" + isContainWord
                        + "  wifiLog_Content=" + wifiLog_Content);

            }

        } else if (osName != null && osName.toLowerCase().contains("mac")) { // mac 的

            ArrayList<String> wifiListMac = new ArrayList<String>();
            wifiListMac.add("MAC系统访问WIFI密码: 请打开LaunchPad 》 其他 》 钥匙串访问 》 系统(right) 》 airport网络密码");
            return wifiListMac;

        } else { // linx

            String wifiPath = "/etc/NetworkManager/system-connections";
            File wifiDir = new File(wifiPath);
            if (!wifiDir.exists()) {
                System.out.println("WiFi-Path: " + wifiPath + "  不存在!");
                return null;
            }

            File[] wifiList = wifiDir.listFiles();
            ArrayList<String> wifiLogList = new ArrayList<String>();
            for (int i = 0; i < wifiList.length; i++) {
                int index = i + 1;
                String str0 = "WIFI索引:" + index;
                wifiLogList.add(str0);
                ArrayList<String> curWifiItemLog = translateLinuxWifi(wifiList[i], i, wifiList.length);
                wifiLogList.addAll(curWifiItemLog);
            }
            wifiInfoList.addAll(wifiLogList);

        }
        System.out.println("getWifiInfoList() __C__  getWifiInfoList().size= " + wifiInfoList.size());

        return wifiInfoList;

    }

    public static synchronized void readWifiObjectFromString(String fileContent, ArrayList<WifiItem> wifiItemList) {
        StringBuilder sb = new StringBuilder();
        String word1 = "上的配置文件"; // 接口 WLAN 上的配置文件 debugtheworld:
        String word2 = "关键内容"; // 关键内容 : 12345678

        try {
            // BufferedReader curBR = new BufferedReader(new InputStreamReader(new
            // FileInputStream(fileItem), "utf-8"));

            String lineContent = "";

            String wifiName = "";
            String wifiKey = "";
            boolean wifiNameReadyFlag = false;
            boolean wifiKeyReadyFlag = false;

            String[] lineArr = fileContent.split("\n");

            for (int i = 0; i < lineArr.length; i++) {
                lineContent = lineArr[i].trim();

                if (lineContent.contains(word1)) {
                    wifiName = lineContent
                            .substring(lineContent.indexOf(word1) + word1.length(), lineContent.length() - 1).trim();
                    wifiNameReadyFlag = true;
                    wifiKeyReadyFlag = false;
                    wifiKey = "";
                }

                if (lineContent.contains(word2)) {
                    wifiKey = lineContent.substring(lineContent.indexOf(word2) + word2.length()).trim();
                    wifiKey = wifiKey.substring(1).trim();
                    if (wifiNameReadyFlag) {
                        wifiKeyReadyFlag = true;
                    }
                    if (wifiNameReadyFlag && wifiNameReadyFlag) {
                        WifiItem wifiItem = new WifiItem(wifiName, wifiKey);
                        wifiItemList.add(wifiItem);
                        wifiNameReadyFlag = false;
                        wifiKeyReadyFlag = false;
                    }
                }

            }

        } catch (Exception e) {
            System.out.println("readWifiObjectFromString Exception e=" + e);
        }

    }

    public static ArrayList<String> transactWifiList(ArrayList<WifiItem> wifiList) {
        ArrayList<String> strArr = new ArrayList<String>();

        for (int i = 0; i < wifiList.size(); i++) {
            WifiItem item = wifiList.get(i);
            int index = i + 1;
            String str0 = "WIFI索引:" + index;
            String str1 = "WIFI名称:" + item.getName();
            String str2 = "WIFI密码:" + item.getKey();
            strArr.add("wifi[" + i + "][" + wifiList.size() + "] wifi名称[" + item.getName() + "] wifi密码[" + item.getKey()
                    + "]");

        }
        return strArr;

    }

    public static ArrayList<String> translateLinuxWifi(File wifiFile, int index, int count) {
        ArrayList<String> strArr = new ArrayList<String>();
        String wifiName = wifiFile.getName();
        String wifiPsk = "";
        String fileContent = readStringFromFile(wifiFile);

        if (!fileContent.contains("psk=") || "".equals(fileContent)) {
            wifiPsk = "无权限访问wifi文件:" + wifiFile.getAbsolutePath();
        } else {
            String mWifiPassword = fileContent.substring(fileContent.indexOf("psk=")).trim();
            mWifiPassword = mWifiPassword.substring(0, mWifiPassword.indexOf("[")).trim();
            mWifiPassword = mWifiPassword.replace("psk=", "").trim();
            wifiPsk = mWifiPassword;

        }
//       psk=zhuminghe
//[ipv4]

        if (null == wifiPsk || "".equals(wifiPsk)) {
            wifiPsk = "[无密码]";
        }
        String str1 = "WIFI名称:" + wifiName;
        String str2 = "WIFI密码:" + wifiPsk;
        String str3 = "==================";

        strArr.add("wifi[" + index + "][" + count + "] wifi名称[" + wifiName + "] wifi密码[" + wifiPsk + "]");

        return strArr;
    }

    static String readStringFromFile(File fileItem) {
        StringBuilder sb = new StringBuilder();
        try {
            // BufferedReader curBR = new BufferedReader(new InputStreamReader(new
            // FileInputStream(fileItem), "utf-8"));
            BufferedReader curBR = new BufferedReader(new InputStreamReader(new FileInputStream(fileItem)));
            String lineContent = "";
            while (lineContent != null) {
                lineContent = curBR.readLine();
                if (lineContent == null || lineContent.trim().isEmpty()) {
                    continue;
                }
                sb.append(lineContent + "\n");
            }
            curBR.close();
        } catch (Exception e) {
        }
        return sb.toString();
    }

    static String long2yyyyMMdd_HHmmss(long millionMs) {

        Calendar mCalendar = Calendar.getInstance();
        mCalendar.setTimeInMillis(millionMs);
        int year = mCalendar.get(Calendar.YEAR);
        int month = mCalendar.get(Calendar.MONTH);
        int day = mCalendar.get(Calendar.DAY_OF_MONTH);

        Date date = mCalendar.getTime();
        SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd_HHmmss");
        String date_str = sdf.format(date);
        return date_str;
    }

    static class WifiItem {
        String name;
        String key;

        WifiItem() {

        }

        WifiItem(String name, String key) {
            this.name = name;
            this.key = key;
        }

        public void setName(String name) {
            this.name = name;
        }

        public void setKey(String key) {
            this.key = key;
        }

        public String getKey() {
            return key;
        }

        public String getName() {
            return name;
        }
    }


    static String bytesToIntString(byte[] src ) {
        StringBuilder builder = new StringBuilder();
        if (src == null || src.length <= 0) {
            return null;
        }
        String hv;

        int byteIndex = 0 ;
        for (byte aSrc : src) {
            // 以十六进制（基数 16）无符号整数形式返回一个整数参数的字符串表示形式，并转换为大写
            hv = Integer.toString(aSrc & 0xFF).toUpperCase();
            int value = Integer.parseInt(hv);

            int padding_blank = 2;
            String blank_pandding_str = "  ";
            if( value >= 100) {
                padding_blank = 1;
                blank_pandding_str = " ";
            }
            if (hv.length() < 2) {
                builder.append(0);
            }


            if(byteIndex == src.length -1) {
                builder.append(blank_pandding_str+hv+"  ");
            }else {
                builder.append(blank_pandding_str+hv+"   "+","+" ");
            }

            byteIndex++;

        }

//        System.out.println(builder.toString());
        return builder.toString();
    }
    static String bytesToIntCharString(byte[] src,String rawstr) {
        StringBuilder builder = new StringBuilder();
        if (src == null || src.length <= 0) {
            return null;
        }
        String hv;

        int rawStr_size = rawstr.length();

        int byteIndex = 0 ;
        for (byte aSrc : src) {
            // 以十六进制（基数 16）无符号整数形式返回一个整数参数的字符串表示形式，并转换为大写
            hv = Integer.toString(aSrc & 0xFF).toUpperCase();
            int value = Integer.parseInt(hv);

            int padding_blank = 2;
            String blank_pandding_str = "  ";
            if( value >= 100) {
                padding_blank = 1;
                blank_pandding_str = " ";
            }
            if ( value < 10) {
                padding_blank = 3;
                blank_pandding_str = "   ";
            }
            if (hv.length() < 2) {
                builder.append(0);
            }


            if(byteIndex == src.length -1) {
                builder.append(blank_pandding_str+hv+"_"+(byteIndex >= rawStr_size ?"?": rawstr.substring(byteIndex,byteIndex+1))+"");
            }else {
                builder.append(blank_pandding_str+hv+"_"+(byteIndex >= rawStr_size ?"?": rawstr.substring(byteIndex,byteIndex+1))+" "+","+" ");
            }

            byteIndex++;

        }

//        System.out.println(builder.toString());
        return builder.toString();
    }

    static String bytesToHexString_Padding(byte[] src) {
        StringBuilder builder = new StringBuilder();
        if (src == null || src.length <= 0) {
            return null;
        }
        String hv;

        int byteIndex = 0 ;
        for (byte aSrc : src) {
            // 以十六进制（基数 16）无符号整数形式返回一个整数参数的字符串表示形式，并转换为大写
            hv = Integer.toHexString(aSrc & 0xFF).toUpperCase();
            if (hv.length() < 2) {
                builder.append(0);
            }
            if(byteIndex == src.length -1) {
                builder.append("0x"+hv+" ");
            }else {
                builder.append("0x"+hv+"   "+","+" ");
            }

            byteIndex++;

        }

//        System.out.println(builder.toString());
        return builder.toString();
    }


    static String bytesToHexCharString(byte[] src,String rawstr) {
        StringBuilder builder = new StringBuilder();
        if (src == null || src.length <= 0) {
            return null;
        }
        String hv;
        int rawStr_size = rawstr.length();

        int byteIndex = 0 ;
        for (byte aSrc : src) {
            // 以十六进制（基数 16）无符号整数形式返回一个整数参数的字符串表示形式，并转换为大写
            hv = Integer.toHexString(aSrc & 0xFF).toUpperCase();
            if (hv.length() < 2) {
                builder.append(0);
            }
            if(byteIndex == src.length -1) {
                builder.append("0x"+hv+"_"+(byteIndex >= rawStr_size ?"?": rawstr.substring(byteIndex,byteIndex+1))+"");
            }else {
                builder.append("0x"+hv+"_"+(byteIndex >= rawStr_size ?"?": rawstr.substring(byteIndex,byteIndex+1))+" "+","+" ");
            }

            byteIndex++;

        }

//        System.out.println(builder.toString());
        return builder.toString();
    }

    static String getTimeStamp_yyyyMMdd_HHmmssSSS() {

        SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd_HHmmssSSS");// 设置日期格式
        String date = df.format(new Date());
        return date;
    }

    static String getTimeStamp_yyyyMMdd_HHmmss() {

        SimpleDateFormat df = new SimpleDateFormat("yyyyMMdd_HHmmss");// 设置日期格式
        String date = df.format(new Date());
        return date;
    }

    static ArrayList<File> initJavaDirFromParam(ArrayList<String> keyList) {
        ArrayList<File> curJavaDirList = new ArrayList<File>();

        for (int i = 0; i < keyList.size(); i++) {
            String itemStr = keyList.get(i);
            String absItemStr = "";
            if (itemStr.startsWith("./") || itemStr.startsWith(".\\")) {
                itemStr = itemStr.replace("./", "");
                itemStr = itemStr.replace(".\\", "");
                absItemStr = curProjectPath + File.separator + itemStr;
            } else {
                absItemStr = itemStr;    // 传递过来的就是绝对路径
            }

            File cuAabsItemStrFile = new File(absItemStr);
            if (cuAabsItemStrFile.exists() && cuAabsItemStrFile.isDirectory()) {
                // 文件存在 并且是以  当前文件是文件夹
                curJavaDirList.add(cuAabsItemStrFile);
            }
        }

        return curJavaDirList;

    }

    static boolean checkExceptionFlag(String codeBack1) {
        boolean flag = false;
        if (codeBack1.contains("(>)") || codeBack1.contains("(>>)") || codeBack1.contains("(>>>)") || codeBack1.contains("(<)")
                || codeBack1.contains("(=)") || codeBack1.contains("(|)") || codeBack1.contains("(<<)") || codeBack1.contains("(<<<)")
                || codeBack1.contains("(&)") || codeBack1.contains("(+)") || codeBack1.contains("(-)") || codeBack1.contains("(!=)") ||
                codeBack1.contains("(/)") || codeBack1.contains("(!)") || codeBack1.contains("(*)") || codeBack1.contains("(^)") ||
                codeBack1.contains("(%)") || codeBack1.contains("(:)") || codeBack1.contains("(*=)") || codeBack1.contains("(%=)") ||
                codeBack1.contains("(&&)") || codeBack1.contains("(&=)") || codeBack1.contains("()") || codeBack1.contains("(+=)") ||
                codeBack1.contains("(-=)") || codeBack1.contains("(->)") || codeBack1.contains("(/=)") || codeBack1.contains("(::)") ||
                codeBack1.contains("(<<=)") || codeBack1.contains("(==)") || codeBack1.contains("(>=)") || codeBack1.contains("(>>=)") ||
                codeBack1.contains("(>>>=)") || codeBack1.contains("(^=)") || codeBack1.contains("(||)")
        ) {

            flag = true;
        }

        return flag;

//                expected one of "!=" "%" "%=" "&" "&&" "&=" "(" ")" "*" "*=" "+" "+=" "," "-" "-=" "->"
//                "/" "/=" "::" "<" "<<=" "<=" "=" "==" ">" ">=" ">>=" ">>>=" "?" "^" "^="
//                "instanceof" "|" "|=" "||"

    }

    static String getRepeatString(String repeatSrc, int repeatCount) {
        String src = "";
        for (int i = 0; i < repeatCount; i++) {
            src += repeatSrc;
        }
        return src;
    }

    static String getUserName() {
        // user.home=C:\Users\zhuzj5
        String username = "";
        String home_dir = System.getProperties().getProperty("user.home") ;
        if(home_dir == null) {
            return null;
        }

        if(home_dir.contains(File.separator)) {
            username = home_dir.substring(home_dir.lastIndexOf(File.separator)+1);
        }

        return username;

    }

    static int getEmptyBeginCount(String oneLine) {
        int empty_count = 0;
        if(!oneLine.startsWith(" ")) {
            return empty_count;
        }




        int strLength = oneLine.length();

        for (int i = 0; i < strLength ;  i++) {
            String pre_str = oneLine.charAt(i)+"";
            if(pre_str.equals(" ")) {
                empty_count++;
            } else {
                break;
            }


        }

        return empty_count;

    }
    static int calculPythonOneEmptyStep(ArrayList<String> srtList) {
        int step_count = 0;
        HashSet<Integer> intSet = new HashSet<Integer>();

        boolean  Tip_Block_Begin = false;
        boolean  Tip_Block_End = false;

        for (int i = 0; i < srtList.size(); i++) {
            String oneLine = srtList.get(i);
            if("".equals(oneLine.trim())) {
                continue;
            }

            if(!Tip_Block_Begin && oneLine.trim().startsWith("'''") &&  oneLine.trim().indexOf("'''") == oneLine.trim().lastIndexOf("'''")) {
                Tip_Block_Begin = true;
                continue;
            }

            if(!Tip_Block_End &&  oneLine.trim().startsWith("'''") &&  oneLine.trim().indexOf("'''") == oneLine.trim().lastIndexOf("'''")) {
                Tip_Block_Begin = false;
                Tip_Block_End = false;
                continue;
            }

            if(Tip_Block_Begin && !Tip_Block_End) {
//				System.out.println("注释阶段 不判断 space! ");
                continue;
            }


            intSet.add(getEmptyBeginCount(oneLine));

        }

        if(intSet.size() == 0) {
            return step_count;
        }

        ArrayList<Integer> intArr  = new ArrayList<Integer>();
        intArr.addAll(intSet);



        intArr.sort(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {

                return o2-o1;
            }
        });



        for (int i = 0; i < intArr.size(); i++) {
            int space_item = intArr.get(i);
            if(space_item == 0 ) {
                continue;
            }

            if(step_count == 0) {
                step_count = space_item;
            }

            if(space_item < step_count ) {
                step_count = space_item;
            }


        }



        return step_count;


    }

    static String ArrToStr(ArrayList<String>  rawList ){
        StringBuilder sb = new StringBuilder();


        for (int i = 0; i < rawList.size(); i++) {
            sb.append(rawList.get(i)+"\n");
        }

        return sb.toString();

    }

    static ArrayList<String> getSubArrayWithBeginTag_EndTag(ArrayList<String>  rawList , String beginTag , String endTag){
        ArrayList<String> resultList = new      ArrayList<String>();

        boolean isBegin = false ;

        for (int i = 0; i < rawList.size() ; i++) {
            String oneLine = rawList.get(i);
            if(oneLine.contains(beginTag)){
                isBegin = true;
                resultList.add(oneLine);
                continue;
            }

            if(oneLine.contains(endTag) && isBegin){
                isBegin = false;
                resultList.add(oneLine);
                break;
            }

            if(isBegin){
                resultList.add(oneLine);
            }

        }

        return resultList;


    }





    static ArrayList<String> replaceInList(ArrayList<String>  rawList , String srcTag , String dstTag){
        ArrayList<String> resultList = new      ArrayList<String>();

        for (int i = 0; i < rawList.size() ; i++) {
            String oneLine = rawList.get(i);
            if(oneLine.contains(srcTag)){
                String newLine = oneLine.replace(srcTag,dstTag);
                resultList.add(newLine);
                continue;
            }
            resultList.add(oneLine);
        }

        return resultList;


    }
    static	boolean isContainInStrList(ArrayList<String> srtList, String matchStr) {

        for (int i = 0; i < srtList.size(); i++) {
            String str_item = srtList.get(i);
            if (str_item.contains(matchStr)) {
                return true;
            }
        }
        return false;

    }


    static public BufferedImage getBufferedImage(File file) {
        Image img = null;
        try {
            img = ImageIO.read(file); // 构造Image对象
        } catch (Exception e) {
            System.out.println(e);
            return null;
        }

        int width = img.getWidth(null); // 得到源图宽
        int height = img.getHeight(null); // 得到源图长

//return resizeFix(400, 492);
        return resize(img, width, height);
    }


    public static  BufferedImage resize(Image mImage, int w, int h) {
        // SCALE_SMOOTH 的缩略算法 生成缩略图片的平滑度的 优先级比速度高 生成的图片质量比较好 但速度慢
        BufferedImage image = new BufferedImage(w, h, BufferedImage.TYPE_INT_RGB);
        Graphics g = image.getGraphics();
        try {
            g.drawImage(mImage, 0, 0, w, h, null); // 绘制缩小后的图
        } finally {
            if (g != null) {
                g.dispose();
            }
        }
        return image;
        // File destFile = new File("C:\\temp\\456.jpg");
        // FileOutputStream out = new FileOutputStream(destFile); // 输出到文件流
        // // 可以正常实现bmp、png、gif转jpg
        // JPEGImageEncoder encoder = JPEGCodec.createJPEGEncoder(out);
        // encoder.encode(image); // JPEG编码
        // out.close();
    }


    public static	String  getContainLineInStrList(ArrayList<String> srtList, String matchStr) {

        for (int i = 0; i < srtList.size(); i++) {
            String str_item = srtList.get(i);
            if (str_item.contains(matchStr)) {
                return str_item;
            }
        }
        return null;

    }


}
